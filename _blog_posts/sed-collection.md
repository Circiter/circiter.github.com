---
layout: post
title: "Небольшая коллекция sed-скриптов."
tags: эзотерика программирование sed
toc: true
sig: true
xdate: "апрель, 2020"
---

# Нецелевое использование поточного редактора.

На данной странице представлен краткий аннотированный список некоторых непрактичных сценариев для
широко известного поточного редактора [sed][sed]. В работе этой утилиты основное место занимает команда
`s/<шаблон>/<замещающий_текст>/` (вместо символа `/` может использоваться и другой разделитель),
ищущая и заменяющая фрагмент текста, удовлетворяющий некоторому регулярному выражению-шаблону.

Эта комманда, могущая показаться далёкой по своей функциональности от обеспечения
Тьюринг-полноты входного языка sed, вместе с метками и коммандами перехода (условного и безусловного)
всё же делает данный редактор вычислительно-универсальным. Фактически, он может рассматриваться в
качестве реализации [нормальных алгорифмов Маркова][nma] (хотя это и не общепринятое мнение), а
полнота по-Тьюрингу обуславливает саму возможность всех произошедших с sed приключений
[с его нестандартным использованием].

В основном, здесь представлены мои скрипты, но в конце приводится список некоторых из похожих
на них в своей непрактичности (а нередко кратно превышающих мои поделки в своей удивительности
и технологической сложности реализации) скриптов других авторов.

Сложно, а быть может уже и вовсе невозможно сказать, какие ещё необычные сценарии писались за всю
историю существования этого редактора, использовавшегося с начала/середины семидесятых годов
прошлого века; так что остаётся лишь продолжать неспешные поиски аналогичных артефактов и, конечно,
писать свои.

Итак, моя учетная запись на GitHub содержит следующие репозитории со скриптами для sed:

## [ocr-in-sed](https://github.com/Circiter/ocr-in-sed)

Этот скрипт написан под впечатлением от однострочной C-программы некоего Эрика Копчинского
([Eryk Kopczynski](http://www.mimuw.edu.pl/~erykk)), написанной для небезызвестного
конкурса [ioccc](http://ioccc.org) за 2004 год и выполняющей оптическое распознавание
текста находя эйлерову характеристику его <<триангуляции>> (насколько
вообще можно говорить о триангуляции для картинки в стиле ASCII-арт).

Да, меня тоже сначала сбила с толку возможность распознавания на основе именно этого
топологического инварианта, очевидно имеющего одинаковые значения вообще для всех планарных
графов; поэтому интересующихся пока переадресую на статью (S.B.Gray, Local Properties
of Binary Images in Two Dimensions, 1971), предположительно являющуюся основой для программы
Копчинского. По-сути, авторы расчитывают инвариант, равный разности между количеством связных
областей и количеством дырок, но расчитывают его подсчитывая различные чисто локальные конфигурации
пикселей в $2\times 2$-окне, пробегая им по всему изображению (в статье этот сверточный подход
распространен и на $3\times 3$-окна, но у Копчинского применено маленькое окно).

Увы, особая простота этой логики сильно ограничивает функциональность основанной на ней программы
распознования символов... И кроме целых из, скажем так, не очень большого промежутка $[8; 11]$ эта
OCR-программа ничего распознать толком не может.

В любом случая, я решил реализовать этот же алгоритм, написав аналогичный скрипт для sed;
естественно вообще не стремясь к однострочности.

## [drawing-in-sed](https://github.com/Circiter/drawing-in-sed)

Простой графический редактор, выполняющий комманды со стандартного ввода и реализующий
некоторое подмножество/версию [черепашьей графики](http://en.wikipedia.org/wiki/Turtle_graphics) и
[систем Линденмайера](http://en.wikipedia.org/wiki/L-system). Сгодится для рисования 
некоторых геометрических фигур, символов, фракталов. Не самое очевидное применение sed,
не так ли?

## [computus-in-sed](https://github.com/Circiter/computus-in-sed)

А это почти полезный скрипт, [расчитывающий](http://ru.wikipedia.org/wiki/пасхалия) дату православной
Пасхи. Теоретически, может быть легко модифицирован для расчета дат католической, еврейской,
астрономической Пасхи. Больше информации можно найти в
[отдельном сообщении](http://circiter.github.io/computus-in-sed).

## [langton-ant-in-sed](https://github.com/Circiter/langton-and-in-sed)

Симуляция известного автомата [<<муравей Лангтона>>](http://en.wikipedia.org/wiki/Langton%27s_ant),
интересного, среди прочего, своей Тьюринг-полнотой и интересной открытой проблемой, связанной с
аттракторами (<<дорога>> с периодом 104 шага) этой динамической системы для всех конечных
начальных конфигураций.

## [elementary-ca-in-sed](https://github.com/Circiter/elementary-ca-in-sed)

[Элементарные](http://en.wikipedia.org/wiki/elementary_cellular_automaton) одномерные конечные
автоматы по-Вольфраму. Достаточно полезная возможность для sed, позволяющая создавать узоры,
генерировать псевдослучайные числа, моделировать некоторые физические процессы.

## [life-in-sed](https://github.com/Circiter/life-in-sed)

[Игра "жизнь"](http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) Конвея, теперь и на sed.

## [music-in-sed](https://github.com/Circiter/music-in-sed)

Пианино на sed! Кто же не делал что-то вроде `cat /dev/urandom > /dev/audio` или
`sudo cat /dev/mem > /dev/audio`? Редактор sed вполне может приняв со стандартного ввода
нотную запись, синтезировать последовательность символов, которая будучи отправленной в
[oss](http://www.opensound.com)-устройство `/dev/audio` (или его аналог), приводит к проигрыванию
соответствующей мелодии через звуковую карту. Всё очень просто. :)

Поводом для написания этого скрипта явилось [сообщение](http://kmkeen.com/awk-music) Kyle Keen об
этом способе генерации звука. Но там был применен полноценный язык программирования awk,
позволивший легко получить более качественный чем у меня звук за счет использования треугольной формы
сигнала. Так появилась музыкальная программа-синтезатор на гораздо более ограниченном sed, именно
в силу ограниченности и представляющем больший спортивный интерес.

## [maze-in-sed](https://github.com/Circiter/maze-in-sed)

В попытке понять написанную на sed одним [предположительно Сингапурским]
[хакером](https://github.com/xsot) программу поиска выхода из лабиринта я
написал свою версию, включив в поставку [пока не полностью работоспособный]
комплементарный генератор лабиринтов (естественно тоже на sed).

## [sieve-in-sed](https://github.com/Circiter/sieve-in-sed)

[Решето Эратосфена](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) на sed. Кроме собственно
решета, реализованного в `sieve.sed`, в репозитории можно найти скрипт `factor.sed`, разлагающий
данное число на его простые делители.

## [superpermutations-in-sed](https://github.com/Circiter/superpermutations-in-sed)

Генерация [вообще говоря, не являющихся минимальными]
[суперперестановок](http://en.wikipedia.org/wiki/superpermutation).

## [cw-in-sed](https://github.com/Circiter/cw-in-sed)

Этот скрипт принимает на вход текстовое сообщение и генерирует тональный телеграфный сигнал
(код Морзе), проигрываемый звуковой картой компьютера по принципу, описанному выше в разделе
о синтезаторе мелодий.

## [r2d2-in-sed](https://github.com/Circiter/r2d2-in-sed)

Синтезатор <<речи>> робота [r2d2](http://en.wikipedia.org/wiki/R2-D2) из вселенной <<Звёздных Войн>>
Д.Лукаса. Применен тот же принцип генерации текстового потока, озвучиваемого перенаправлением в
`/dev/audio`. В отличии от программы-пианино или от генератора <<морзянки>>, здесь кроме чистых нот
(на самом деле всего-лишь прямоугольного сигнала вместо синусоиды) имеется возможность создания
белого шума, а также возможность случайного выбора нот.

Интересно, можно ли научить r2d2 говорить [по-человечески]? Пора внести синтезатор речи в TODO-список. :)

## [infix-compiler-in-sed](https://github.com/Circiter/infix-compiler-in-sed)

Даже будучи *текстовым* редактором, sed не предоставляет удобных инструментов для разбора
(синтаксического анализа) контекстно-свободных грамматик. Наиболее простой метод разбора, а именно
рекурсивно-нисходящий анализ, сложен в реализации на sed из-за отсутствия адекватной поддержки
рекурсии. Однако в теории ничто не мешает написать рекурсивно-нисходящий парсер, и даже компилятор,
для какого-нибудь простого языка, например для арифметических формул (с обычной инфиксной нотацией).

Конкретно этот проект является маленьким (и страшно неэффективным) компилятором формул, принимающим
арифметическое выражение (скажем, `(1+2)*3`) и продуцирующим настоящий машинный код ([пока] только для
x86-архитектуры и для 32 битного Linux в качестве ОС). На данный момент, мой скрипт не умеет
генерировать полноценный исполняемый файл (хотя это в принципе и возможно), поэтому для добавления
всех необходимых заголовков я рекомендую воспользоваться
Perl-скриптом [m2elf.pl](https://github.com/XlogicX/m2elf).

## [banner-in-sed](https://github.com/Circiter/banner-in-sed)

Упрощенный аналог утилит типа `banner`/`sysvbanner` или [figlet](http://www.figlet.org). Для данной строки печатает
её <<ASCII-art>> вариант (c большими символами), просто склеивая соответствующие её знакам фрагменты
текста из специально подготовленного <<шрифта>>. Поддерживается автоматическая коррекция межбуквенных
интервалов, т.е. автокернинг (с возможностью наблюдения за  бесполезной, но забавной анимацией
этого процесса).

## [quine-kleene-generator](https://github.com/Circiter/quine-kleene-generator)

Генератор (неэффективных) квайнов для sed. Правда, сам генератор представляет собой набор как 
sed-скриптов, так и скриптов оболочки. Для генерации квайнов используется доказательство второй 
рекурсивной теоремы Клини о неподвижных точках частично-рекурсивных функций. N.B., квайны 
получаются очень большими по размеру, но генератор всё-равно оказался полезен в моих небольших 
экспериментах/упражнениях по теории вычислимости.

Подробности можно найти в серии сообщений [<<Занимательное квайноводство>>](http://circiter.github.io/quinelogy-part-1).

--------

Кроме этого на <http://gist.github.com/Circiter/> хранятся следующие <<минирепозитории>> (gists):

* [sleep-sort.sed](https://gist.github.com/Circiter/ffa8c2875457c1f45da4c08268e7e076) -- реализация
   алгоритма <<спящей сортировки>>.
* [von-neumann-extractor.sed](https://gist.github.com/Circiter/09f0866d18e77d487c3308fcfce0be5c)
   -- скрипт преобразует данную $2n$-битную последовательность в $n$-битную с выравниванием 
  частот/количеств единиц и нулей. Скрипт написан по мотивам работы (Von Neumann, Various 
  techniques used in connection with random digits, 1951).
* [dec-to-bin.sed](https://gist.github.com/Circiter/8d19dee9ca046ceae534f40e2ec10ff0) -- перевод 
   десятичного числа в двоичную систему счисления.
* [dec-to-hex.sed](https://gist.github.com/Circiter/28532a371eeea8d497c53ae81b8d7a80) -- основанный на предыдущем скрипте
  (`dec-to-bin.sed`) код преобразования числа из десятичной системы счисления в шестнадцатиричную. При необходимости
  оба примера сравнительно легко обобщаются и на другие системы счисления по основанию 2 (e.g. на восьмиричную).
* [permutations.sed](https://gist.github.com/Circiter/ab4f8538d3882562e38a2e7525acc480) -- перестановки,
   самые обычные перестановки.
* [up-n-down.sed](https://gist.github.com/Circiter/aadaad1cc3ddce7cf13b333a65b0f78b) -- экспериментальный
   способ перемещения вверх и вниз в sed путем матричного транспонирования буфера редактирования.
* [transpose.sed](https://gist.github.com/Circiter/93281adfd2cdf142da5837d1dec6c770) -- транспонирование
   матрицы.
* [sliding-window.sed](https://gist.github.com/Circiter/77951d75b6b0e3b4ecc9b689e17863c3) -- другой
   подход к перемещению вверх и вниз. Последняя строка матрицы дублируется и используется как референсный
   счетчик. От текущей клетки движутся два маркера в противоположных направлениях (вправо и влево),
   на каждом шаге декрементируя референсный счётчик. Как только счётчик обнулится, мы можем утверждать,
   что один (левый) маркер находится над текущей клеткой (т.е. выше неё), правый -- под ней. Далее вокруг
   текущей клетки выделяется 8-окрестность $3\times 3$, окрашивается, отображается. И так для всех клеток с их
   последовательным обходом (слева-направо, сверху-вниз).
   <br><br>
   Сам я последнее время использую другой подход к вертикальной навигации в sed, основанный на
   добавлении маркеров в начало каждой строки с последующим синхронным перемещением всех маркеров
   вправо до столкновения одного из них с текущей выбранной клеткой. В этот момент мы можем двигаться
   вверх-вниз вдоль маркеров, затем удалить их и начать работать с другой клеткой (счетчик не нужен).
   Элементарно.

*Nota bene,* я почти всегда пишу на диалекте [GNU sed](http://www.gnu.org/software/sed), что, 
увы, создаёт проблемы с использованием моих sed-скриптов на всяких там Mac'ах, BSD'ях и этих 
ваших Android'ах. Возможен ли конвертер (может быть даже написанный, о ужас, на самом sed) из 
GNU в Posix и смогло ли бы это решить проблему портабельности?

Ближайшие по смыслу найденные мною проекты -- <http://lvogel.free.fr/sed/sedcheck.sed> за 
авторством [Laurent Vogel](http://lvogel.free.fr), проверяющий скрипты на Posix-совместимость; и 
транслятор <https://github.com/lhoursquentin/sed-bin>, конвертирующий sed в C (примечательно, 
что оба проекта сами являются sed-скриптами).

Наконец, транслятор <https://github.com/shinh/elvm> позволяет преобразовать C-код снова в sed. И 
хотя сам он и не написан на sed, но может оттранслировать самого себя с C на sed. Поэтому, можно 
считать, что sed-bin и elvm совместно могли бы использоваться для <<нормализации>> sed-скриптов.

*Post scriptum*. Многие из моих sed-сценариев, --- ровно как и настоящий список, --- носят чисто 
развлекательно-экспериментальный характер и перманентно находятся в режиме 
написания/дописывания; функциональность может менятся кардинально без предварительных 
уведомлений и рациональных обоснований.

--------------

# Скрипты других авторов.

На страницах <http://sed.sourceforge.net> и <http://sed.sourceforge.net/grabbag> (автор: Paolo Bonzini)
можно найти неплохую коллекцию sed-скриптов разной степени полезности. Стоить отметить некоторые из
представленных там вещей:

* <http://sed.sourceforge.net/grabbag/scripts/dc.sed> -- постфиксный калькулятор
   (использует обратную польскую нотацию); поддерживает арифметику, корни, перевод
   между системами счисления и т.д.
* <http://sed.sf.net/grabbag/tutorials/hanoi.htm> -- [Ханойские башни](en.wikipedia.org/wiki/Tower_of_Hanoi).
* <http://www.oocities.org/mettw/personal/software/src/sedhttpd.txt> -- http-сервер на sed.
* <http://sed.sourceforge.net/grabbag/scripts/turing.sed> -- машина Тьюринга на sed; да,
   это -- готовое [конструктивное] доказательство вычислительной универсальности языка sed.
* <http://sed.sourceforge.net/grabbag/scripts/sokoban.sed> -- широкоизвестная игра
   ![i18n-sokoban](/public/images/sokoban.png) (сокобан); эта реализация интересна, разумеется, 
   перемещением персонажа во всех направлениях (в т.ч. вверх-вниз), чего обычно на sed достичь 
   не так-то просто.
* <http://sed.sourceforge.net/grabbag/scripts/bf2c.sed> -- транслятор из, --- ну кто
   же его не знает, --- bf в C. (Т.к. bf является разновидностью универсальной машины Тьюринга,
   то такой транслятор тоже является простым доказательством Тьюринг-полноты sed.)

Так же на просторах интернета были найдены:

* [sedlisp](https://github.com/shinh/sedlisp) -- написанный японцем [Shinichiro Hamaji](https://github.com/shinh)
   интерпретатор небольшого подмножества lisp'а.
* [sel](https://github.com/mb64/sel) -- аналогичная реализация lisp-интерпретатора на sed, 
   написанная Mark Barbone.
* [sedcheck.sed](http://lvogel.free.fr/sed/sedcheck.sed) -- проверка скриптов
   на Posix-совместимость; автор: Laurent Vogel.
* [sed-bin](https://github.com/lhoursquentin/sed-bin) -- написанный на sed транслятор из sed в
   C; автор: Quentin L'Hours.
* [bf.sed](https://github.com/stedolan/bf.sed) -- написанный [Stephen Dolan](http://stedolan.net)
   компилятор bf, генерирующий x86-код, обернутый в готовый к выполнению elf-файл [для Linux].
* [SedChess](https://github.com/bolknote/SedChess) -- шахматы, реализованные
   [Евгением Степанищевым](https://github.com/bolknote) из Казани; больше 1000 строк. Описание 
   можно найти в [habr/191006](https://habr.com/ru/post/191006).
* [sedtris](https://github.com/uuner/sedtris) -- реализация игры <<тетрис>>, выполненная
   [Юлией Йомантайте](https://github.com/uuner) (из Нью-Йорка). У меня есть
   [производный репозиторий](https://github.com/Circiter/sedtris) (<<fork>>) с небольшим
   улучшением (добавлен ГПСЧ на основе клеточного автомата, реализующего <<правило 30>> по-Вольфраму).
* <https://gist.github.com/xsot/99a8a4304660916455ba2c2c774e623a> -- написанная
   Wei Heng (aka [xsot](htts://github.com/xsot)) программа решения лабиринтов (т.е. поиска пути,
   в данном случае обходом в ширину).
* <http://laurent.le-brun.eu/pub/path.sed> -- другая, более минималистичная, реализация обхода
   лабиринтов, написанная [Laurent Le Brun](http://laurent.le-brun.eu).
* [quine.sed](https://github.com/MakeNowJust/quine/blob/master/quine.sed) из
   [<<музея квайнов>>](https://github.com/MakeNowJust/quine) -- квайн на sed; самостоятельно его 
   написать [не так-то и просто](http://circiter.github.io/quinelogy-part-1), но у его 
   [автора](https://github.com/MakeNowJust), Tsuyusato Kitsune (см. <http://quine.codes/>), 
   богатый опыт в квайноводстве (им были написаны квайны для более чем 260 (да, двухсот 
   шестидесяти [или даже двухсот шестидесяти семи, кажется]) разных языков программирования).
*  <https://github.com/mame/quine-relay> -- <<итеративный>>
   многоязыковой квайн, или цепной квайн (авторы: [Yusuke Endoh](https://github.com/mame), даже 
   написавший [книжку](http://gihyo.jp/book/2015/978-4-7741-7643-7), на японском, об 
   эзотерическом программировании вообще и квайнах в частности; и 
   [hirekoke](https://twitter.com/hirekoke)), а именно программа, написанная на одном языке, при 
   запуске выдающая программу на другом языке, в свою очередь печатающую программу на третьем, и 
   т.д., пока последняя программа не напечатает снова самую первую. Конкретно этот многоязыковой 
   квайн, пробегает при своей работе 128 языков (на начало 2020 года), в том числе и sed.
   <br><br>
   К сожалению, хотя такие <<квайны>>, на первый взгляд, могут показаться достаточно сложными, 
   на деле же сложность их написания оказывается несоизмеримо меньше сложности обычных, истинных 
   квайнов. Также не следует путать такие программы с квайнами-полиглотами (квайн-полиглот, или, 
   как я его кратко называю, поликвайн, является корректной программой одновременно на 
   нескольких языках) и мультиквайнами (программами, печатающими подобные программы на разных 
   языках в зависимости от аргументов коммандной строки, в т.ч. ведущими себя как обычные квайны 
   будучи запущенными без аргументов).
   <br><br>
   (Термины <<итеративный/цепной квайн>>, <<поликвайн>>, <<мультиквайн>> нельзя назвать 
   общепринятыми и они используются здесь просто чтобы дать соответствующим понятиям подходящие 
   имена; официальной квайнологической терминологии, боюсь, пока нет.)
* <https://github.com/jinchizhong/sed-snake> -- игра <<змейка>>.
* <https://github.com/jinchizhong/sed-nqueens> -- классическая
   задачка о [расстановке нескольких ферзей][nqueens] на шахматной
   доске. Обычно решается с помощью обхода в глубину, что
   подразумевает использование рекурсии, поддержки которой
   в sed нет (и её как обычно приходится эмулировать с помощью
   искусственного <s>интеллекта</s> стека и комманды `b`).

[nma]: http://ru.wikipedia.org/wiki/нормальный_алгоритм
[sed]: http://en.wikipedia.org/wiki/sed
[nqueens]: http://en.wikipedia.org/wiki/Eight_queens_puzzle
