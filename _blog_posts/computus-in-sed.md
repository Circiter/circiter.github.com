---
layout: post
title: "Пасхалия в sed."
tags: программирование эзотерика sed математика
---

# Получение даты празднования Пасхи с использованием александрийской пасхалии

## Введение

Во время поста перед Пасхой решил написать сценарий (скрипт) `computus.sed` [3] для хорошо известного
поточного текстового редатора sed, расчитывающий дату празднования (в данном случае православной) Пасхи.

Пример использования скрипта `computus.sed`:
```sh
echo 2020 | ./computus.sed
# April, 19
```

Исходное определение даты праздования Пасхи выглядит не очень сложно [1, 2]. Согласно ему, день
празднования Пасхи приходится на первое воскресение после первого полнолуния, наступившего не ранее
весеннего равноденствия. Программный расчёт этой даты подразумевает моделирование движения земли и
луны, либо, что проще для реализации, аппроксимацию полу-эмпирическими формулами.

Проблема только усложняется тем, что эта дата --- т.н. астрономическая пасха --- из-за
принятого в церкви алгоритма расчета указанных астрономических событий (полнолуние, равноденствие) и
витиеватой истории календарных реформ сильно отличается от фактических дат (тоже сильно различающихся
между собой) празднования Пасхи в различных церквях/религиях.

Это обстоятельство вместе с [почти] полным отсутствием поддержки арифметики в sed сделало написание
этого скрипта несколько нетривиальной задачей.

Поэтому сначала был написан простой интерпретатор для постфиксного (обратная польская нотация, далее
кратко rpn) языка, использующего стек (но поддерживающего именованные переменные).

## Описание вспомогательного языка

Весь rpn-скрипт состоит из последовательности <<слов>>, разделенных пробелами. Слова могут быть
числами или коммандами. Слова перечисляются и обрабатываются (выполняются) слева-направо.

Целое положительное число в десятичной записи преобразуется в унарную запись и кладётся на вершину
стека.

Комманды:
- Сравнение: `eq`. Удаляет из стека два верхних элемента, сравнивает их и кладет на
   вершину стека единицу если аргументы равны, и ноль -- в противном случае.
- Работа с переменными: `set`, `get`. Синтаксис: `set_<variable>` и `get_<variable>`, где
   `<variable>` -- имя изменяемой или, соответственно, читаемой переменной (без угловых скобок).
   При записи, с вершины стека удаляется значение и записывается в указанную именованную переменную.
   При чтении значение из переменной добавляется на стек.
- Аддитивные арифметические операции: `plus`, `minus`. Эти операции удаляют два значения-аргументы
   со стека, складывают или находят из разность (причем вычитать можно только из большего меньшее),
   а результат кладут на стек.
- Мультипликативные операции: `div`, `mod`. Эти операции тоже берут со стека два значения и кладуд
   результат обратно на вершину. Операция `div` производит целочисленное деление,
   `mod` -- находит остаток от деления.
- Условный оператор: `if ... then`. При выполнении комманды `if` проверяется вершина стека и если
на вершине лежит ноль, то блок между `if` и <i>ближайшим</i>, расположенным правее, словом `then`
пропускается, иначе блок выполняется (N.B., вложенность не поддерживается).

На данный момент все арифметические операции производятся в унарной системе счисления.
К примеру, для проверки високосности 2020 года требуется среди прочего найти остаток от деления на 4,
а для этого требуется записать 2020 единиц в буфер редактирования и начать последовательно удалять
по 4 единицы за раз, пока не останется менее четырех единиц, что и будет требуемым остатком. Да, это
очень медленно, но обеспечивает особую простоту кода.

Аналогично, деление описывается следующим псевдокодом:
```C
a=pop_stack();
b=pop_stack();
c=0;
while(a>b)
{
    a-=b;
    c++
}
push_stack(c);
```

## Расчёт даты

В [1] приведен следующий алгоритм для расчета даты православной Пасхи (здесь добавлена частичная
коррекция даты для поддержки григорианского календаря или т.н. нового стиля):
$a\gets\text{Year}\mod4$\\
$b\gets\text{Year}\mod7$\\
$c\gets\text{Year}\mod19$\\
$d\gets(19c+15)\mod30$\\
$e\gets(2a+4b+d+34)\mod7$\\
$t\gets d+e+114+13$\\
$\text{Month}\gets\lfloor 1/31\rfloor$\\
$\text{Day}\gets(t\mod31)+1$

Для получения дат по григорианскому календарю я просто добавил слагаемое 13 в присваивание
$t\gets d+e+114+13$. Т.е. в таком виде этот код не будет правильно работать для дат до 1 февраля
1918 года, условно конечно, т.к. официально календарь был введен 24 января и начал действовать с
31 января, сместив дату сразу на 13 дней (после 31 января было уже 14 февраля). Теоретически, это
не сложно исправить.

Дословная трансляция вышеприведенных формул на уже описанный в предыдущем разделе
проблемно-ориентированный миниязык может быть такой:
```
set_year get_year 4 mod set_a
get_year 7 mod set_b
get_year 19 mod set_c
19 get_c mul 15 plus 30 mod set_b
2 get_a mul 4 get_b mul plus 34 plus get_d minus 7 mod set_e
get_d get_e plus 114 plus 13 plus set_t
get_t 31 div set_mont
get_t 31 mod 1 plus set_day
```

Несмотря на учёт перехода на <<новый стиль>>, здесь всё ещё остается проблема с датой Пасхи,
приходящейся на май (исходные формулы вообще не могут давать майских дней). <i>Ad-hoc</i> коррекция
для таких дат может выглядеть следующим образом:
```
get_month 5 eq if get_day 1 plus set_day then
get_mont 4 eq if get_day 31 eq if
5 set_month 1 set_day then then
```

Это соответствует такому C-образному псевдокоду:
```C
if(month==5)
    day++
else if(month==4)
    if(day==31)
    {
        month=5
        day=1
    }
```

В конце rpn-скрипта мы просто кладем готовые месяц и день на стек для дальнейшей печати (с
преобразованием номера месяца в строку):
`get_month get_day`

## Тестирование

В репозитории можно найти файл-словарь `test-easter-dates.txt` с некоторыми проверочными датами и
скрипт `dictionary-test.sh` для автоматического тестирования с их использованием. Спешу лишь
предупредить о достаточно большом времени, требуемом для завершения работы скрипта даже для
относительно небольшого диапазона дат, включенных в указанный файл (1994--2034 гг.)

Кроме этого был написан на perl простой скрипт-обёртка `computus.pl`, принимающий год в качестве
аргумента коммандной строки, расчитывающий дату празднования Пасхи с помощью модуля Dates::Easter [4]
и возвращающий её в том же формате, что и `computus.sed`. Он может использоваться для сравнительного
тестирования моего скрипта, а с целью упрощения этой процедуры для диапазонов дат, можно воспользоваться
сценарием оболочки `range-test.sh`.

Пример:
```sh
./computus.pl 2020
# April, 19
./range-test.sh 2018 2021
# 4 tests performed, 4 tests passed, 0 tests failed.
```

Для меня пока остаётся открытым вопрос о работоспособности скрипта `computus.sed` для
всего XXI века, а также для дат, предшествовавших реформе 1918 года, вплоть до времен разработки
и начала применения пасхалии (хотя конкретно этот алгоритм не будет работать для времени более раннего
чем 1583 год). К слову, `computus.pl` согласуется с моим для текущего века, но
расходится с моим на один день для века XIX, что однако не связано, по видимому, с вопросом о новом
стиле --- в начала XX века, скрипты дают одинаковые даты, а это, возможно, свидетельствует о
наличии в perl-модуле `Dates::Easter` той же ошибки/недоработки, что и в моём случае.

## Возможные улучшения

За счёт использования стекового dsl-языка представляется относительно несложной задача адаптации
настоящего скрипта к другим вариантам Пасхи, включая католическую и еврейскую. Поддержку
астрономической Пасхи прямым моделированием планетарного движения на sed реализовать сложнее, но
можно подобрать, как уже было отмечено, приближенные формулы. Например, ядро расчета еврейской Пасхи
достаточно точно соответствует астрономической дате (что, однако, нивелируется соглашениями о
невозможности празднования Песах в определенные дни недели).

Другим очевидным направлением для улучшения обсуждаемого sed-сценария является ускорение его работы,
например переходом к десятичной или хотя-бы двоичной системе счисления. В постфиксном калькуляторе
`dc.sed` [5], написанного Greg Ubben, вся необходимая арифметика уже реализована (и работает с
огромной скоростью, в отличии от моей унарной реализации <<счётных палочек>>).

Наконец, было бы неплохо исправить описанные в предыдущих разделах ошибки с расчётом дат Пасхи в веке
XIX и далее вглубь веков.

Ссылки:
[1] Jean Meeus, Astronomical Algorithms, 1991
[2] http://ru.wikipedia.org/wiki/пасхалия
[3] https://github.com/Circiter/computus-in-sed
[4] http://search.cpan.org/dist/Date-Easter
[5] http://sourceforge.net/grabbag/scripts/dc.sed
