---
layout: post
title: "Занимательное квайноводство. Часть I."
xdate: "июль, 2020"
sig: true
toc: true
tags: неподвижные-точки sed эзотерика программирование квайноводство теория-вычислимости математика философия саморепликация

abstract: В этом сообщении (в первой части серии сообщений), после краткого введения в некоторые 
 основы теории вычислимости, в основном описываются результаты простого эксперимента по 
 автоматизированному конструированию квайна с использованием второй рекурсивной теоремы Клини.

 В качестве целевого языка выбран язык поточного редактора [GNU] sed. Изложение, однако, не 
 специфично для этого языка и может трактоваться в более широком контексте. Фактически, в 
 предлагаемом цикле сообщений излагаются некоторые подходы к систематическому конструированию 
 квайнов.
---

# Введение в квайнологию

Всем известно <<стандартное>> упражнение в программировании, заключающееся в написании 
программы, печатающей свой собственный текст. За такими самореплицирующимися программами 
достаточно давно закрепилось название <<квайн>> (также встречаются варианты 
написания/произношения <<куайн>>, <<квин>>, <<куин>>) введенное в известной книге Хофштадтера 
[26] в честь философа Куайна (Уиллард Ван Орман Куайн = Willard Van Orman Quine).

Сами квайны при этом появились раньше. Может быть их историю следовало бы вести с работ фон 
Неймана по самореплицирующимся [клеточным] автоматам [9, 48] или даже с работ Чёрча и Хаскеля...

Квайны являются немного парадоксальными программами, в соответствии с бытовой интуицией не 
могущими существовать, -- ведь может показаться, что программа не может вывести текст, имеющий 
длину, равную длине самой программы (должно остаться место для кода, выполняющего печать). И тем 
не менее они существуют (и не требуют сжатия данных, которое, в соответствии с фундаментальной 
теоремой компрессии, не всегда возможно).

Более того, теория вычислимости говорит, что квайны можно написать на *любом* [достаточно 
выразительном] языке программирования. На деле, конечно, сложность написания и размер 
результирующего кода сильно варьируются от языка к языку.

В качестве примеров квайнов можно привести такие поделки (авторы мне не известны):

Квайн на lisp:
```lisp
((lambda (x)
  (list x (list (quote quote) x)))
(quote
  (lambda (x)
    (list x (list (quote quote) x)))))
```

Квайн на стековом rpn-языке форт (forth):
```forth
s" 2dup 115 emit 34 emit 32 emit type 34 emit type cr bye"2dup 115 emit 34 emit 32 emit type 34 emit type cr bye
```

(Это одна длинная строка, могущая отображаться на нескольких экранных строках.)

Квайн на экспериментальном функциональном стековом rpn-языке joy [32]:
```
"dup.putchars.10 putch."
dup.putchars.10 putch.
```

Квайн для $\lambda$-исчисления(почти то же, что и выше на lisp): $$(\lambda x. x x) (\lambda x. 
x x)$$

В стандартной библиотеке языка C есть функция форматированного вывода `printf`, которая может 
быть использована [в качестве суррогата $S^m_n$-функции] для внедрения текста программы в него 
самого; что-то вроде `printf(f, f)`, только с учетом технических сложностей с вложенными 
кавычками для обрамления строк. По этому принципу построен такой известный однострочный 
миниквайн на C (здесь не указан заголовочный файл `stdio.h`, в котором определена `printf`, но в 
таком виде этот код всё-равно компилируется и работает):

```c
char*f="char*f=%c%s%c;main(){printf(f,34,f,34,10);}%c";main(){printf(f,34,f,34,10);}
```

Многие квайны (в т.ч. большинство из приведенных выше) злоупотребляют экранированием строк, 
специальными кодами символов (зависящими от используемой в системе кодировки, e.g. ASCII) и 
библиотечными функциями подстановки (замены подстрок), <<скрывающими>> существенную часть 
происходящих процессов. <<Идеологически>> более чистым подходом представляется ограничение 
строковых манипуляций конкатенацией строк при одновременной минимизации экранирований. Неплохим 
образчиком подобной стратегии написания квайнов является квайн (на pascal'е) от Dan Hoey (взятый 
мною из [50]):

```
program s;const bbb='program s;const bbb';a='a';b='b';bb=');writeln(';
aa='''';ab='=''';ba=''';';
aaa='begin writeln(bbb,ab,bbb,ba,a,ab,a,ba,b,ab,b,ba,b,b,ab,bb,ba';
aba='a,a,ab,aa,aa,ba,a,b,ab,ab,aa,ba,b,a,ab,aa,ba,ba';
abb='a,a,a,ab,aaa,ba);writeln(a,b,a,ab,aba,ba);writeln(a,b,b,ab,abb,ba';
baa='b,a,a,ab,baa,ba);writeln(b,a,b,ab,bab,ba);writeln(aaa,bb';
bab='aba,bb);writeln(abb);writeln(bb,baa);writeln(bb,bab)end.';
begin writeln(bbb,ab,bbb,ba,a,ab,a,ba,b,ab,b,ba,b,b,ab,bb,ba);writeln(
a,a,ab,aa,aa,ba,a,b,ab,ab,aa,ba,b,a,ab,aa,ba,ba);writeln(
a,a,a,ab,aaa,ba);writeln(a,b,a,ab,aba,ba);writeln(a,b,b,ab,abb,ba
);writeln(b,a,a,ab,baa,ba);writeln(b,a,b,ab,bab,ba);writeln(aaa,bb
);writeln(aba,bb);writeln(abb);writeln(bb,baa);writeln(bb,bab)end.

```

(N.B., на самом деле этот квайн записывается в одну строку.)

Неплохое введение в написание квайнов можно найти, например, в [1, 30]; а неплохую коллекцию 
-- в [30, 18].

## Искусство *versus* ремесло

Основной причиной проведения небольшого эксперимента, ставшего основой настоящего сообщения, 
явилось желание написать, или, точнее говоря, попробовать написать квайн на входном языке 
поточного редактора sed. Применение поисковых систем для поиска уже имеющихся решений привело к 
обнаружению квайна `quine.sed` [17] из <<музея квайнов>> [18] (автор: Tsuyusato Kitsune):

{% highlight plaintext %}
s/^/s11^113311;h;s221[1]221122g;s112[2]11222211g;G;s11^22([^3]*22)3322([^22n]*22).22(.*22)$1122122322211/;h;s\1[1]\/\g;s/2[2]/\\/g;G;s/^\([^3]*\)33\([^\n]*\).\(.*\)$/\1\3\2/
{% endhighlight %}

(N.B., это одна строка текста.)

Вряд ли у меня вышло бы улучшить (например, сократить) этот квайн. Более того, самостоятельная 
попытка написать нечто подобное тоже не увенчалась успехом. Поэтому было принято решение 
действовать более систематичным образом и воспользоваться уже имеющимся в распоряжении 
математики арсеналом готовых теоретических средств.

Вторая рекурсивная теорема Клини имеет своим следствием утверждение о существовании квайна для 
любого языка программирования, а конструктивный характер её доказательства дает готовый рецепт 
для написания такого <<саморепликатора>> (ниже об этом будет написано подробнее).

Стандартные пособия по теории вычислимости нередко не ограничиваются лишь утверждениями о 
существовании квайнов, и даже приводят конкретные примеры их конструирования, правда, выбирая 
при этом, как правило, <<удобные>> языки программирования, например, прагматические реализации 
$\lambda$-исчисления, такие как lisp и его производные.

Попадались интересные исключения, e.g. [35, 36], но для слишком абстрактных машин. Поэтому я 
решил повторить классический эксперимент с конструированием квайна на основе доказательства 
рекурсивной теоремы Клини, но выполнить этот эксперимент на языке sed (кстати, всё-равно 
оказавшемся достаточно удобным для этой задачи, в основном из-за возможности объединения 
скриптов их конкатенацией).

**Обновление (август, 2020):** *уже после написания черновика этого сообщения, примеры 
применения второй рекурсивной теоремы Клини к практическим языкам программирования всё-таки 
отыскались на просторах интернета. В [53] можно найти генератор квайнов на JavaScript 
(ECMAScript), а в [54] -- похожий генератор, но для C++. Причем в последнем примере, указанная 
утилита позиционируется как достаточно общий инструмент для добавления рефлексивных возможностей 
к языку, с ограниченной штатной рефлексией (i.e., сгенерированная программа может как просто 
печатать свой собственный текст, так и вычислять произвольные функции от него, скажем, находить 
свою длину).

Возможно читателю также будет интересна аналогичная утилита [55], преобразующая произвольную 
программу на C в квайн.
*

Результаты эксперимента говорят о возможности автоматической, или <<нетворческой>> генерации 
квайнов, в том числе и на sed.

## Эффективность и выбор названия серии сообщений.

Быть может некоторым показалось бы несколько более благозвучным слово вроде <<квайноделия>>, но 
<<квайноводство>> подходит куда лучше... От части потому, что, как и обещают стандартные вводные 
курсы по теории вычислимости, квайны, конструируемые прямым применением [второй рекурсивной] 
теоремы Клини, обычно получаются, мягко говоря, <<неэффективными>> (как по времени, так и по 
пространству).

## Постановка задачи

Пусть квайн хранится в исполняемом файле `quine`, полученным компиляцией его исходного текста из 
файла `quine.source`. Для меня достаточно чисто формального выполнения следующего теста:

```sh
./quine any_argument > quine.output
diff quine.source quine.output
```

или аналогичного теста для интерпретируемого языка (здесь `interpreter` -- исполняемый файл 
интерпретатора или аналогичная внутренняя комманда оболочки):

```sh
interpreter quine.source any_argument > quine.output
diff quine.source quine.output
```

Для sed это соответствует следующему тесту:

```sh
echo any_argument | sed -f quine.sed > quine.output
diff quine.sed quine.output
```

Проверку на тривиальность (в частности, на пустоту) можно выполнять и <<вручную>> (из-за 
плохой формализуемости и некоторой субъективности).

То есть, квайн конечного размера (скажем, помещающийся на жесткий диск) должен напечать свой 
собственный текст за конечное (и разумное время). Абсолютно не важно, будут ли исходный текст и 
скомпилированная программа весить несколько килобайт или несколько мегабайт. Гораздо важнее, 
чтобы квайн был истинным, т.е. был непустым, <<содержательным>>, и не использовал <<нечестные>> 
рефлексивные возможности (вроде чтения своего исходного текста из файла).

# Вводные замечания

В теории вычислимости особо важное место занимают несколько интересных теорем о вычислимых 
функциях. В этом сообщении я хотел бы кратко рассказать об этих теоремах и о некоторых их 
применениях.

Для некоторой программы с текстом $p$ соответствующую ей (частичную) вычислимую функцию обычно обозначают как 
$\varphi_p$, однако, воизбежание нагромождения нижних индексов далее будет использоваться 
несколько более удобное обозначение, широко применяющееся при изучении семантики языков 
программирования, а именно $\llbracket p\rrbracket$.

Обычно, в теории рекурсивных функций говорят о [гёделевском] номере программы, а не о её тексте, 
но далее будет использоваться более наглядное и привычное, по крайней мере для программистов, 
слово *текст*, иногда даже *исходный код*, без прямого отсыла к понятиям *кодировка* и 
*нумерация* из теории вычислимости. Более того, вразрез с традиционным словоупотреблением, в 
настоящем сообщении нередко программа и её текст будут отождествляться, -- здесь это просто одно 
и то же. (Краткости и простоты ради, это сообщение будет вообще несколько неформальным и не 
строгим.)

При одновременном рассмотрении нескольких языков программирования, как, например, при 
работе с трансляторами, можно указывать язык программирования в нижнем индексе 
семантических скобок, e.g., $\llbracket\cdot\rrbracket_\varphi$. (Кстати, в литературе 
встречается и более необычная нотация, например, вообще не используюшая какие-либо индексы и 
скобки, для экономии места.)

Символом $\bot$ будет обозначено незавершающееся вычисление, т.е. $\bot$ -- это значение 
бесконечного цикла. Равенство $\llbracket a\rrbracket=\llbracket b\rrbracket$ есть сокращение 
для $\forall x\ \llbracket a\rrbracket(x) = \llbracket b\rrbracket(x)$. (Подразумевается, что 
для некоторых $x$, может выполнятся $\llbracket a\rrbracket(x)=\bot$ и $\llbracket 
b\rrbracket(x)=\bot$.)

## Теорема об универсальной функции

Сначала хотелось бы упомянуть теорему о существовании универсальной программы, а фактически о 
возможности написания интерпретаторов для любых подходящих (Тьюринг-полных) языков 
программирования, причем подразумевается, что интерпретатор пишется на его же входном языке. 
Более формально, эта теорема утверждает, что существуют вычислимая функция --- *универсальная 
функция* --- $u$, а также соответствующая ей программа-интерпретатор $I$, такие, что для любой 
программы $p$, интерпретатор может быть запущен с несколькими аргументами, первый из которых 
равен $p$, а оставшиеся суть просто аргументы для этой программы. Так запущенный интерпретатор 
должен возвратить тот же результат, что и сама программа $p$ при тех же аргументах.

То есть, $\exists u, I\colon\forall p\ u(p, x)=\llbracket I\rrbracket(p, x)=\llbracket 
p\rrbracket(x)$. Доказательство здесь приводиться не будет (оно может проводится просто 
предъявлением готового интерпретатора для машины Тьюринга, т.е. путем построение т.н. 
универсальной машины Тьюринга, симулирующей работу любой другой машины Тьюринга; N.B., сама 
теорема не зависит от языка программирования и требует лишь его полноты по-Тьюрингу).

Фактически, эта теорема говорит, что частичная функция $\llbracket x \rrbracket(y_0,\ldots)$ 
сама является вычислимой функцией $f(x, y_0, \ldots)$.

(Использование теоремы об универсальной функции в данном сообщении будет весьма ограниченным; 
здесь без неё можно было бы и обойтись.)

## S-m-n теорема Клини

Другой, не менее важной теоремой является т.н. $S^m_n$ теорема (известная также как теорема о 
параметризации или итеративная теорема) [14, 3], утверждающая, что может быть написана 
программа, уменьшающая количество аргументов путем фиксации значений некоторых из них: для 
программы $p$, реализующей функцию $p'$ с $m+n$ аргументами и для заданных значений 
$a_1,\ldots,a_m$ для первых $m$ аргументов существует программа $g$ для специализированной 
$n$-местной функции, удовлетворяющая $\llbracket g\rrbracket(b_1,\ldots,b_n) = 
p'(a_1,\ldots,a_m, b_1,\ldots,b_n)$ для любых $b_i$.

Также существует примитивно рекурсивная функция, --- собственно, $S^m_n$-функция, --- 
преобразующая программу $p$ в программу $g$.

То есть, для программы $p$ выполняется $\llbracket S^m_n(p, 
a_1,\ldots,a_m)\rrbracket(b_1,\ldots,b_n) = \llbracket p\rrbracket(a_1,\ldots,a_m, 
b_1,\ldots,b_n)$.

Далее пригодится частный случай $S^1_1$ с фиксацией всего одного из двух аргументов.

Нетрудно видеть, что $S^m_n$ теорема, по-существу, реализует частичные вычисления (специализацию 
программ) [4, 5], т.е. дает возможность выполнить часть вычислений, зависящих от фиксируемого 
аргумента(-ов), заранее, до выполнения программы (что может быть использовано, например, для 
оптимизации кода). Есть некоторое сходство между частичной специализацией и *каррингом* из 
функционального программирования.

Доказательство $S^m_n$ теоремы конструктивно и может быть основано на явном выписывании 
программы (e.g. для машины Тьюринга), присваивающей определенные значения исключаемым аргументам 
и обеспечивающей запуск программы при поступлении недостающих данных (такого тривиального 
алгоритма недостаточно для написания оптимизирующего специализатора; но он может быть улучшен).

(Как и для предыдущей теоремы, само доказательство здесь приводится не будет, а интересующимся 
рекомендуется обратиться к первоисточникам или более современным материалам по теории 
вычислимости.)

Стоит отметить, что вышеприведенные теоремы во многом схожи, и даже в некотором смысле 
<<взаимо-обратны>> -- теорема об универсальной функции преобразует <<статический>> параметр --- 
программу --- в <<динамический>> аргумент, который может затем принимать любое значение; 
$S^m_n$-теорема, напротив, преобразует динамический аргумент в статический, приписывая ему 
априори заданное значение.

Эта симметрия хорошо видна если выписать ключевые уравнения обоих теорем одно под другим 
(здесь, для краткости, используется $S^1_1$-функция):
{% tex block %}
\begin{align*}
\llbracket I\rrbracket(p, x, y) &= \llbracket p\rrbracket(x, y)\\
\llbracket S^1_1(p, x)\rrbracket(y) &= \llbracket p\rrbracket(x, y).
\end{align*}
{% endtex %}

В некотором смысле, они при этом всё-же различны -- кроме структурных различий формул, 
$S^m_n$-функция является примитивно рекурсивной.

# Неподвижные точки вычислимых функций

Далее описывается теорема о существовании неподвижных точек частично-рекурсивных функций (т.е. 
вычислимых на компьютере), известная также как вторая рекурсивная теорема Клини [14]; здесь 
приводится несколько упрощенная её версия, впрочем, полностью достаточная для решения 
поставленных задач.

**Вторая рекурсивная теорема Клини.**

Для любой частично-рекурсивной функции $f(\cdot, \cdot)$ существует программа $p$ (<<неподвижная 
точка>>), такая, что $$\forall z \ \llbracket p\rrbracket(z)=f(p, z).\eqno (1)$$

**Доказательство.**

Напишем программу $e$, такую, что $\llbracket e\rrbracket(x, y)=f(S^1_1(x, x), y)$. Тогда 
$p=S^1_1(e, e)$.

Действительно, если запустим $p$ для какого-нибудь аргумента $z$, то получим $\llbracket 
p\rrbracket(z)=\llbracket S^1_1(e, e)\rrbracket(z)$. По определению $S^1_1$-функции, $\llbracket 
S^1_1(e, e)\rrbracket(z)=\llbracket e\rrbracket(e, z)$. Теперь применим определение для $e$ и 
получим, что $\llbracket e\rrbracket(e, z)=f(S^1_1(e, e), z)=f(p, z)$. Понятно, что эта цепочка 
уравнений по транзитивности приводит к $\llbracket p\rrbracket(z)=f(p, z)$. $\blacksquare$

В данном сообщении особый интерес представляет частный случай $f(x, y)=x$, порождающий квайны: 
легко видеть, что при этом $\llbracket p\rrbracket(z)=f(p, z)=p$, то есть программа $p$ при 
запуске печатает сама себя, как и положено квайну.

Иногда пригождается другая версия этой теоремы (при определенном выборе языка, строго 
говоря, не эквивалентная теореме Клини; см. [39]), предложенная в [19]:

**Теорема Роджерса.**

Для любой рекурсивной вычислимой функции $f(\cdot)$ существует неподвижная точка $p$, т.е. такая 
программа $p$, что $\forall z \llbracket p\rrbracket(z)=\llbracket f(p)\rrbracket(z)$.

**Доказательство.**

Определим функцию $h(e)$ так, что $$\llbracket h(e)\rrbracket = \big\llbracket\llbracket 
e\rrbracket(e)\big\rrbracket.\eqno (2)$$ Теперь напишем программу $e$, такую, что $\forall z$ 
выполняется $$\llbracket e\rrbracket(z) = f\big(h(z)\big).\eqno (3)$$ Утверждается, что $p=h(e)$ 
-- есть искомая неподвижная точка.

Подстановка (3) в правую часть (2) дает $\big\llbracket\llbracket e\rrbracket(e) 
\big\rrbracket=\llbracket f\big(h(e)\big) \rrbracket$ и $\llbracket 
h(e)\rrbracket=\llbracket f\big(h(e)\big)\rrbracket$. Последнее уравнение при обозначении 
$p=h(e)$ уже соответствует определению неподвижной точки из условия этой теоремы, т.е., 
$\llbracket p\rrbracket=\llbracket f(p)\rrbracket$. $\blacksquare$

Из теоремы Клини и теоремы об универсальной функции следует теорема Роджерса, а из теоремы 
Роджерса и $S^m_n$-теоремы -- теорема Клини. (Но есть нюансы [39].)

Для применения теоремы Роджерса к случаю с квайнами, удобно, следуя [2], ввести оператор 
$\operatorname{quote}$, для данного аргумента конструирующий программу, печатающую этот 
аргумент. Т.е. определение оператора $\operatorname{quote}$ выглядит как 
$\llbracket\operatorname{quote} z\rrbracket=z$ [и соответствует одноименному оператору из, e.g., 
lisp'а].

Квайны суть неподвижные точки этого оператора [в смысле формулировки теоремы Роджерса].

**Доказательство.**

Пусть $q$ -- неподвижная точка $\operatorname{quote}$, т.е. $\forall z$ выполняется 
$\llbracket\operatorname{quote} q\rrbracket(z) = \llbracket q\rrbracket(z).$ Подстановка 
определения $\operatorname{quote}$ в это уравнение дает $\llbracket\operatorname{quote} 
q\rrbracket(z)=q=\llbracket q\rrbracket(z)$. Но $q=\llbracket q\rrbracket(z)$ и есть определение 
квайна. $\blacksquare$

**Примечание.**

Вообще, в математике, неподвижной точкой функции $f(\cdot)$ обычно называют значение 
$x$, такое, что $f(x)=x$ (i.e., $f$ оставляет $x$ неизменным). Поэтому <<неподвижные точки>> из 
теорем 1 и 2 не совсем соответствуют такому общепринятому определению.

Тем не менее, термин *неподвижная точка* хорошо отражает суть этих теорем -- некоторое 
преобразование не меняет значение аргумента, т.е. оставляет его неподвижным (более того, из 
$f(x)=x$ следует $\llbracket f(x)\rrbracket=\llbracket x\rrbracket$, i.e. неподвижные точки по 
Роджерсу очень близки к обычному определению)

Я лишь намереваюсь, в рамках этой серии сообщений, для удобства ввести обозначения для этих 
<<нестандартных>> неподвижных точек, а именно, пусть операторы $\operatorname{kfix} f$ и 
$\operatorname{rfix} f$ обозначают неподвижные точки [функции $f$] из теорем Клини и Роджерса, 
соответственно. В контексте, требующем работы с несколькими неподвижными точками, эти операторы 
будут обозначать множества неподвижных точек. Обозначение $\operatorname{fix} f$ будет 
использоваться для множества традиционных неподвижных точек, $\operatorname{fix} f=\{x\colon 
f(x)=x\}$.

# Главный эксперимент

В [42] приведен следующий эксперимент по квайногенерации на lisp (автор кода мне не известен):
```lisp
(define g (quote (lambda (x y) x))) ; g(x, y) = x

(define s11 (quote (lambda (f x) (list (quote lambda)
    (quote (y)) (list f x (quote y)))))) ; from s-m-n theorem

(define m (list (quote lambda) (quote (x y))
    (list g (list s11 (quote x) (quote x)) (quote y))))

(define quine (eval (list s11 m m)))

; tests
(eval (list quine nil))
(eval (list g quine nil))
```

(В [47] можно найти невероятную коллекцию аналогичных экспериментов со второй рекурсивный 
теоремой Клини, выполненных на языке scheme, диалекте lisp'а.)

Этот фрагмент кода просто воспроизводит доказательство второй рекурсивной теоремы Клини. 
Аналогичным образом я действовал и при повторении этого эксперимента на sed. Соответствующий код 
может быть найден в GitHub-репозитории [46]. Конкретно, в репозитории содержится ряд скриптов, 
`*.sed` и `*.sh`, назначение каждого из которых рассмотренно ниже.

Редактор sed направляет данные со стандартного ввода в основной буфер редактирования (т.н. *the 
pattern space*). И т.к. мне не известен способ передачи традиционных аргументов коммандной 
строки скрипту для этого редактора, то именно чтение со стандартного ввода было применено в 
качестве единственного механизма передачи аргументов. При этом, из-за необходимости передачи 
нескольких аргументов, понадобилось либо ввести разделитель/терминатор (e.g. нулевой байт), либо 
приписывать значение длины перед каждым аргументом. Как ни странно, изначально был выбран второй 
метод, в основном из-за отсутствия необходимости в экранировании разделителя.

Итак, далее приведен перечень скриптов с их кратким описанием:

- `construct-input.sh` принимает на вход список файлов со значениями аргументов и формирует 
   пакет аргументов из них, т.е. читает эти значения и посылает на стандартный вывод, снабдив 
   заголовками (длинами). Формат пакета данных с аргументами выглядит так:
   <br>
   ```
   <длина аргумента 1>...<длина аргумента n><аргумент 1>...<аргумент n>
   ```
   <br>
   Длина каждого аргумента представлена двоичным шестнадцатиразрядным числом (т.е. этот формат 
   не отличается универсальностью, но этого хватает для практического применения).
- Скрипт `s11.sed` [тривиально] реализует $S^1_1$-функцию. Этот сценарий принимает исходную 
   программу $p$ в первом аргументе и фиксируемый аргумент $x$ для неё -- во втором своем 
   аргументе. Результатом работы скрипта будет другая программа, полученная путем приписывания к 
   $p$ небольшого <<инъектора>> -- фрагмента кода, встраивающего ранее принятый аргумент $x$ (и 
   теперь являющийся частью инъектора) перед новым аргументом $y$ (который будет передан 
   формируемой программе при её запуске). После модификации пакета аргументов, инъектор передаёт 
   управление программе $p$ так, что она <<видит>> пару аргументов $x$ и $y$, несмотря на то, 
   что при запуске ей был передан единственный аргумент $y$.
   <br>
   Небольшая техническая сложность заключается в необходимости экранирования специальных 
   символов в аргументе $x$ при формировании инъектора (с $x$, встроенным в него). Экранирование 
   производится в соответствии с синтаксисом регулярных выражений sed, путем добавления 
   символа`\` перед некоторыми символами, вроде того же `\` или перевода строки `\n`.
- `minifier.sed` используется для удаления ненужных символов (пустые строки, комментарии). При 
   генерации квайна этот скрипт применяется для *опционального* <<сжатия>> скриптов `s11.sed` и 
   `duplicate-first.sed`, что впоследствии уменьшает размер и увеличивает скорость работы 
   результирующего квайна.
- `is-quine.sh` -- простой shell-скрипт, проверяющий переданный ему в аргументах sed-скрипт и 
   определяющий, является ли он квайном.
- `generate.sh` производит <<минификацию>> скриптов `s11.sed` и `duplicate-first.sed`, после 
   чего запускает `generate-q.sh`, а после его завершения проверяет готовый продукт --- квайн в 
   файле `q.sed` --- с помощью скрипта `is-quine.sh`
- `duplicate-first.sed` принимает два аргумента $x$ и $y$ и заменяет второй первым, т.е., 
   игнорирует $y$ и формирует пакет из двух одинаковых аргументов $x$ и $x$.
- `generate-e.sh` конструирует программу $e$ из доказательства теоремы Клини. Для этого 
   [минифицированный, сжатый] код программы `duplicate-first.sed` добавляется в начало [тоже 
   сжатого] `s11.sed` и объединённый код сохраняется в `e.sed`. При запуске $e$, как и 
   требуется, будет выполняться $\llbracket e\rrbracket(m, x) = S^1_1(m, m)$, т.е. сначала 
   второй аргумент будет заменен первым (с помощью кода из `duplicate-first.sed`), затем 
   управление будет передано коду $S^1_1$-функции из `s11.sed`.
- `generate-q.sh` сначала запускает `generate-e.sh` для создания `e.sed`, потом запускает 
   `s11.sed` (или его сжатую версию, хотя здесь это не имеет значения) передав ему в качестве 
   обоих его аргументов содержимое только что сгенерированного `e.sed`. (N.B., `generate-e.sh` 
   использовал содержимое `s11.sed` для генерации `e.sed` на его основе; в данном же случае, 
   скрипту `generate-q.sh` не требуется доступ к тексту `s11.sed`, но лишь возможность его 
   выполнения; по той же причине здесь не используется `duplicate-first.sed`)
- `first-only.sed` из двух переданных ему аргументов возвращает только первый. Реализует 
   $\mathrm{K}$-комбинатор из комбинаторной логики и $\mathrm{SKI}$-исчисления. В 
   дистрибутив/репозиторий включен просто для демонстрации, хотя, в соответствии с 
   доказательством теоремы Клини, является реализацией функции $f(x, y)=x$, позже 
   использовавшейся для доказательства существования квайна.
- `concat.sed` возвращет объединённые значения обоих аргументов; никакие заголовки в результат 
   не включаются. На деле, `concat.sed` включен в репозиторий только для демонстрации -- скрипт 
   `generate-e.sh` не использует `concat.sed`, а производит объединение текстов просто 
   последовательным копированием оных в целевой файл.

(Заметьте, последние два скрипта, `first-only.sed` и `concat.sed` концептуально не являются 
лишними и они могли бы быть использованы, но по-факту, в ходе оптимизации, были заменены 
аналогичными средствами коммандной оболочки, -- для эффективности.)

Для генерации квайна достаточно запустить `./generate.sh`, в результате чего в том же каталоге 
[через некоторое время] должен появиться файл `q.sed`, являющийся искомым квайном на sed.

# Промежуточные итоги

Описание основного эксперимента завершено (и я рекомендую немного поизучать код скриптов из 
репозитория). Но о квайнах рассказать можно ещё многое. А некоторые вопросы остаются 
вовсе малоизученными, фактически, открытыми.

Несмотря на приведенные доказательста теорем о неподвижных точках (Клини и Роджерса), кому-то, 
может быть, хотелось бы глубже понять структуру этих и подобных им доказательств. Поэтому ниже я 
приведу некоторые дополнительные сведения с примерами. К концу сообщения я попробуя немного 
задеть некоторые из философских аспектов квайнов и теории вычислимости. И, пожалуй, завершу 
изложение попыткой сформулировать интересующие меня, но пока не имеющие официального ответа 
открытые вопросы.

Надеюсь, это не последнее сообщение этой серии. Поэтому, темы, не затронутые здесь, будут, по 
возможности, обсуждаться позже в других частях.

# Дополнительная теория

## Проблема остановки

Проблемой останова(-ки) называют задачу определения завершаемости произвольной программы по её 
коду. Известна теорема об алгоритмической неразрешимости такой задачи, т.е. о невозможности 
построения алгоритма, устанавливающего для произвольной программы конечность времени её 
выполнения [8].

**Доказательство.**

В пользу этого утверждения можно привести такие доводы. Определим функцию $h(n, x)$ которая в 
качестве своих аргументов принимает код некоторой программы $n$ и входные данные $x$ этой 
программы, после чего возвращает 1 если эта программа завершается за конечное время, и 0 -- если 
программа <<зависает>>.

Пусть $f(x, y)$ -- любая вычислимая (реализуемая в виде компьютерной программы) функция двух 
аргументов, способная обрабатывать тексты программ. Определим ещё одну функцию g(x) следующим 
образом: $$g(x)=\begin{cases}0, & f(x, x)=0\\\bot.\end{cases}$$.

Т.е. $g$ передаёт свой аргумент функции $f$ и если та возвращает ноль, то ноль возвращает и $g$, 
но в противном случае $g$ возвращает неопределенное значение, а именно зависает, входя в 
бесконечный цикл. Важно, что для вычисления $g$ можно написать программу, e.g. такую (C-образный 
псевдокод):

```c
int g(x)
{
    if(f(x, x)==0)
        return 0;
    else
        while(1);
}
```

Так как $f$ тоже реализуема в виде программы, то в приведенном коде для $g$, получение значения 
$f(x, x)$ можно считать обычным вызовом подпрограммы. Все остальные действия (проверка на 
равенство нулю, возврат результата, условный переход, бесконечный цикл) тоже выполнимы на любом 
комппьютере.

Теперь мы можем передать функции $g$ её собственный текст; тогда, если $f(g, g)=0$, то и 
$g(g)=0$. Другими словами, в этом случае $g$ возвращает результат и завершается, т.е. $h(g, 
g)=1$. Если же $f(g, g)=1$, то $g(g)$ зависает и таким образом $h(g, g)=0$.

В любом случае, из этого получается, что $f(g, g)\neq h(g, g)$. Таким образом, функция $h$ не 
совпадает с вычислимой $f$. А из произвольности выбора функции $f$ немедленно вытекает, что 
функция $h$ не совпадает вообще ни с одной вычислимой функцией, т.е. $h$ невычислима (в смысле 
несуществования программы, вычисляющей значение этой функции для любых входных данных). 
$\blacksquare$

## Диагонализация

Эта схема доказательства фактически основана на процедуре диагонализации [6]. Если у нас есть 
некоторая бесконечная матрица $a_{xy}$, то мы можем построить вектор $b$ не совпадающий ни с 
одной из строк матрицы. Для этого достаточно лишь каким-то образом преобразовать элементы 
диагонали (отсюда название метода) матрицы $a$ так, чтобы для любого $z$ выполнялось $b_z\neq 
a_{zz}$ (например, $b_z=1+a_{zz}$).

Действительно, предположим, что $b$ равен одной из строк матрицы $a$. Это означает, что 
существует такой индекс $z$, что $b_i=a_{zi}$ для любого $i$. Однако, по-построению $b$, при 
$i=z$ имеет место неравенство $b_z\neq a_{zz}$; противоречие.

## Теорема Кантора

Изначально, диагональный метод был разработан и применен Кантором [7] для доказательства 
существования множеств, больших любого счетного бесконечного множества, или, точнее говоря, для 
доказательства несуществования сюръекции $\mathbb{N}\to\wp(\mathbb{N})$, где $\wp(\mathbb{N})$ 
-- булеан множества $\mathbb{N}$. В более общем виде, теорема кантора говорит о несуществовании 
сюръекции $X\to Y^X$, где $X$, $Y$ -- некоторые множества (причем $Y$ должно быть невырожденным, 
например, в смысле существования беспорядка $Y\to Y$, т.е., перестановки без неподвижных точек), 
а $Y^X$ -- множество всех функций $X\to Y$ (структурно, обозначение $Y^X$ соответствует формуле 
$|Y|^{|X|}$ для подсчета количества таких функций).

Применительно же к проблеме останова, в качестве бесконечной матрицы используются значения $f(x, 
y)$, т.е. строки соответствуют функциям. Причем диагональные значения оборачиваются в функцию 
$g$ так, чтобы функция останова $h$ возвращала результаты, всегда не равные этим значениям. Это и 
позволяет достичь противоречия (c.f. <<парадокс лжеца>>).

## Теорема Ловера

Уильям Ловер предложил [43] обобщенную теорему из которой следуют многие другие результаты 
диагонализации, включая и проблему останова и теорему Гёделя о неполноте и некоторые другие. См. 
[44] для изложения тех же результатов на языке теории множеств (работа [43] сформулирована с 
существенным привлечением теории категорий).

# Немного о пределах познаваемости

Проблема останова разрешима для многих систем, например, для конечных автоматов, 
коими, кстати говоря, и являются реальные компьютеры. Правда, в силу огромного количества 
состояний таких автоматов, они, с практической точки зрения, хорошо моделируются машиной 
Тьюринга (или эквивалентными моделями, типа лямбда-исчисления). Поэтому, многие теоретические 
результаты, вытекающие из проблемы останова или доказываемые редукцией к ней, по прежнему 
применимы в обычном программировании.

Также проблема останова может быть вполне разрешимой для определенных частных случаев. Например, 
в теории, антивирусы невозможны (это доказывается редукцией к проблеме остановки), но они 
всё-таки <s>вертятся</s> существуют как программные продукты (в том числе, благодаря 
<<маркетингу>>, наверное). В теории, невозможно написать программу-детектор, безошибочно 
определяющую, что другая программа печатает на экране, например, слово <<привет>> [28, 29]. Но 
ведь многие бы без труда написали такой детектор. Даже сами доказательства теорем, в силу 
соответствия Карри-Ховарда, вообще говоря, требуют решения проблемы остановки. Но ведь 
математики как-то доказывают теоремы! Иногда при помощи компьютера (и автоматизированно и даже 
автоматически).

Эти исключения не являются ошибками или фактами, опровергающими упомянутые контринтуитивные 
утверждения (содержащие квантор всеобщности). А положительные результаты имеют вполне конкретное 
применение. Компиляторы, интерпретаторы, квайны и многие другие интересные артефакты теории 
вычислимости существуют не только теоретически, но и имеют осязаемые реализации в виде реальных 
кусков кода и даже устройств (e.g. те же компьютеры). А теорема Гёделя о неполноте говорит, что 
некоторые теоремы просто не могут быть доказаны, -- не стоит даже и пытаться.

Наконец, диагонализация внесла некоторый вклад и в более абстрактные области философии. 
Например, применением диагонального процесса к демону Лапласа --- <<древнему>> суперкомпьютеру, 
имеющему неограниченный доступ к любой информации обо всех частицах вселенной --- была 
установлена <<монотеистическая>> теорема о невозможности существования более чем одного демона 
Лапласа [27].

В следующих сообщениях этой серии я напишу о некоторых из этих [как классических, так и 
относительно новых] результатов подробнее.

# Другие подходы и <<слегка открытые>> вопросы

В этом разделе обсуждаются достаточно простые, но до сих пор представляющие некоторый 
исследовательский интерес альтернативные подходы к конструированию квайнов. Некоторые из 
рассмотренных здесь вопросов могут быть тривиальными и, возможно, представляющими сложность лишь 
для меня; другие -- могут оказаться объективно стоящими дальнейшей проработки.

Более подробно все эти воросы будет или не будут освещены в следующем(-их) сообщении(-ях) этой 
серии.

## <<Креационизм>> vs. <<абиогенез>>

Я условно назвал совокупность методов (как ручных, так и автоматических), применяемых для 
конструирования квайнов и основанных на существенном привнесении специально подготовленной 
внешней информации/знаний в этот процесс [квайнологическим] <<креационизмом>>. Традиционное 
написание квайна вручную, а также его конструирования на основе второй рекурсивной теоремы Клини 
-- суть примеры креационисткого подхода в квайнологии. В них требуется существенный контроль со 
стороны программиста.

В подразделах же, приведенных ниже, акцент сделан на автоматическом итеративном конструировании 
квайнов (если оно возможно). <<Абиогенетическое>>, самостоятельное <<зарождение>> квайнов 
потенциально могло бы представлять некоторую ценность в ряде областей. Так, например, 
квайнологический абиогенез был бы интересен в таком разделе информационной безопасности как 
компьютерная вирусология; он был бы применим в автономных системах (e.g., самомодифицирующееся 
ПО каких-нибудь марсоходов) и, возможно, интересен экзобиологам (в том смысле, что квайны, 
будучи <<дистиллированной>> моделью жизни, подошли бы для изучения тварей с *terra incognita*, 
-- будь-то океанские впадины, астероиды, космическая пыль/мусор, или любые другие субстраты).

## Кимианские квайны и итеративное вычисление неподвижной точки

Хофштадтер в [26] не только ввел термин квайн, но и описал там же ещё одну разновидность 
самореплицирующегося кода -- кимианские квайны, названные в честь Скотта Кима (Scott Kim), 
подсказавшего эту идею Хофштадтеру.

Кимианский квайн представляет собой текст, который будучи поданым на вход 
компилятора/интерпретатора, не распознается как корректный исходный текст, а приводит к выводу 
сообщения об ошибке [31]. Причём такое сообщение побуквенно совпадает с самим кимианским 
квайном. Т.е. при попытке запуска или компиляции, подобный код всё-таки воспроизводит себя, как 
и положено квайну.

Если обозначить среду исполнения для кимианского квайна (e.g., компилятор, интерпретатор или 
коммандную оболочку) как функцию $F(x)$, принимающую и возвращающую текстовую строку, то 
некоторый кимианский квайн $q$ будет неподвижной точкой этой функции: $F(q)=q$.

Интересно, что в данном случае $q$ может быть вычислен итерированием функции $F$ начиная с 
подходящего (иногда пустого) начального приближения. Т.е. алгоритм конструирования 
кимианского квайна должен будет вычислить $q=\lim_{k\to\infty}F^k(\varepsilon)$, где 
$F^k(x)=F\big(F^{k-1}(x)\big)$, $F^0(x)=x$ для некоторого начального значения $\varepsilon$.

Следует заметить, что такая функция $F(x)$ определена для всех $x$ (и к тому же всегда 
завершается, если речь идет о компиляторе без поддержки вычислительно-универсальных 
металингвистических средств, --- например, подобных C++ шаблонам, --- могущих приводить к 
<<зависанию>> компилятора).

В минирепозитории (gist) [33] можно найти простую реализацию подобного метода итеративного 
конструирования кимианского квайна, выполненную на языке коммандной оболочки bash. Скрипт 
принимает в качестве аргумента путь до исполняемого файла интерпретатора или компилятора, 
запускает его и передает ему имя файла, хранящего начальное приближение. Результат из потоков 
вывода сохраняется в этот же файл если этот результат отличается от содержимого файла, после 
чего процесс повторяется. И так до стабилизации процесса, т.е. пока данный интерпретатор не 
будет выдавать тот же текст, который он получил на вход.

Эксперименты показывают, что таким способом неподвижная точки находится не всегда. И это не 
удивительно. Теорема о неподвижной точке может быть переформулирована в форме утверждения о том, 
что алгоритм преобразования программного кода не может всегда возвращать программу, отличную от 
данной. И если неподвижная точка существует, то итерирование применения этого алгоритма *может* 
породить последовательность программ, сходящуюся к неподвижной точке. Но последовательность 
может сойтись и к какому-нибудь циклу. Т.е. даже если $\exists x\colon F(x)=x$, то возможно 
существует последовательность $x_0, \ldots, x_n$ такая, что $F(x_i)=x_{i+1}$ и $F(x_n)=x_0$. 
Причем, возможно, что $\exists i, k\colon F^k(\varepsilon)=x_i$.

Обсуждаемый скрипт [33] имеют рудиментарную поддержку определения таких циклов, но для меня 
остается открытым вопрос о возможности автоматического <<преобразования>> такого цикла в 
настоящую неподвижную точку (формально, в цикл из одного элемента).

## Другие конструктивные теоремы о неподвижной точке

Пожалуй, это самый спекулятивный и неформальный подраздел этого сообщения. Здесь перечисляются 
некоторые известные теоремы о неподвижных точках, которые, возможно, могли бы быть применены для 
конструирования квайнов. Сама эта возможность находится под вопросом, но эти теоремы всё-же 
заслуживают упоминания в таком контексте.

### Первая рекурсивная теорема Клини

(Этот раздел написан по мотивам соответствующего материала из [50].)

Для функций $f_0\colon D_0\to R_0$ и $f_1\colon D_1\to R_1$, таких, что $D_0\subseteq D_1$, 
$R_0\subseteq R_1$ и $\forall x\in D_0\ f_0(x)=f_1(x)$ введем обозначение $f_0\sqsubseteq f_1$, 
читающееся как <<$f_1$ продолжает $f_0$>>.

Функция называется конечной если она имеет конечную область определения. *Конечной частью* 
функции $f$ назовём конечную функцию $\theta\sqsubseteq f$. Сопоставим функции $\theta$ 
натуральное число $g(\theta)$.

Подразумевается, что существует алгоритм, который по числам $z$ и $x$ вычисляет $\theta(x)$ если 
существует $\theta$, такая, что $z=g(\theta)$ и $\theta$ определена в точке $x$.

Оператор $F$ называется рекурсивным оператором если существует вычислимая функция $\phi(z, x)$, 
такая, что $\forall f, x, y\ F(f)(x)=y$ тогда и только тогда, когда существует конечная 
$\theta\sqsubseteq f$, такая, что $\phi\big(g(\theta), x\big)=y$.

Оператор $F$ непрерывен если $\forall f, x, y\ F(f)(x)=y$ тогда и только тогда, когда существует 
конечная $\theta\sqsubseteq f$, такая, что $F(\theta)(x)=y$.

Оператор $F$ называют монотонным, если $\forall f,g\ f\sqsubseteq g\Rightarrow F(f)\sqsubseteq 
F(g)$.

**Утверждение (без доказательства).**

Рекурсивные операторы непрерывны и монотонны.

**Теорема (без доказательства).**

Для любого рекурсивного оператора $F$ существует наименьшая неподвижная точка $f$, т.е. $F(f)=f$ 
и если для какой-нибудь другой функции $g$ выполняется $F(g)=g$, то $f\sqsubseteq g$. 
(Рекурсивная, т.е. всюду определенная функция $f$ автоматически будет единственной неподвижной 
точкой.)

Для демонстрации связи с квайнами в [50] по-сути предлагается попробовать в качестве 
рекурсивного оператора взять оператор, аналогичный оператору $\operatorname{quote}$, 
определенному в разделе о теореме Роджерса (см. выше). Оператор $\operatorname{quote}$ преобразует
программу $p$ в программу, печатающую текст $p$, а по только что изложенной первой 
рекурсивной теореме Клини, $\operatorname{quote}$ должен иметь неподвижную точку $q$, такую, что 
$\operatorname{quote} q=q$. Т.е. программа $q$ равна программе, печатающей себя; другими 
словами, $q$ есть квайн.

Здесь уместно прокомментировать согласованность этого вывода с данным выше определением 
рекурсивного оператора, ведь $\operatorname{quote}$ действует не на множестве вычислимых 
функций, а на множестве исходных текстов программ. Идея состоит в том, что оператор 
$\operatorname{quote}$, преобразуя некоторую программу $p_0$ в программу $p_1$, порождает 
рекурсивный оператор $\Phi$, преобразующий функцию $f_0=\llbracket p_0\rrbracket$ в функцию 
$f_1=\llbracket p_1\rrbracket$. Пусть $\varphi$ -- универсальная функция для выбранного языка 
программирования (т.е. $\varphi_p=\llbracket p\rrbracket$), тогда вышеописанную идею можно 
проиллюстрировать следующей диаграммой:
{% tex block %}
{% raw %}
\begin{tikzpicture}[xscale=1.5]
\path node (m00) at (0,0) {$p_0$}
    node (m01) at (0,1) {$f_0$}
    node (m10) at (1,0) {$p_1$}
    node (m11) at (1,1) {$f_1$};
\draw[->] (m00) -- node[left]{$\varphi$} (m01);
\draw[->] (m10) -- node[right]{$\varphi$} (m11);
\draw[->] (m00) -- node[below]{$\operatorname{quote}$} (m10);
\draw[->] (m01) -- node[above]{$\Phi$} (m11);
\end{tikzpicture}
{% endraw %}
{% endtex %}

К оператору $\Phi$ напрямую применима первая рекурсивная теорема, т.е. существует $f$, такая, 
что $f=\Phi(f)$. Из этого следует, что существуют программы $q_0$ и $q_1$, причем 
$$q_1=\operatorname{quote} q_0.\eqno (4)$$ Т.к., $f=\llbracket q_0\rrbracket$ и 
$f=\llbracket q_1\rrbracket$, то $$\llbracket q_0\rrbracket=\llbracket q_1\rrbracket.\eqno 
(5)$$ Подставляя (4) в (5) и применяя определение оператора $\operatorname{quote}$ получаем 
$\forall z\ \llbracket q_0\rrbracket(z) = \llbracket\operatorname{quote} q_0\rrbracket(z) = 
q_0$, т.е. $q_0$ удовлетворяет <<уравнению квайна>> $\llbracket q_0\rrbracket(z)=q_0$ и, 
соответственно, является квайном.

(Для меня остается открытым вопрос о возможности применения первой рекурсивной теоремы для 
автоматического конструирования квайнов, как в случае со второй рекурсивной теоремой.)

### Теорема Клини о неподвижной точке [из теории решёток]

Произвольное отображение $F\colon M\to M$, непрерывное по Скотту и определенное на полном 
частично упорядоченном множестве $M$ с отношением порядка $\sqsubseteq$ имеет наименьшую 
неподвижную точку.

Непрерывность по Скотту означает существование $\sup F(S)$ и выполнение  $F(\sup S)=\sup F(S)$ 
для всякого направленного подмножества $S\subseteq M$.

### Теорема Кнастера-Тарского

В [37] приведена теорема о существовании неподвижных точек монотонных отображений на полной 
решетке. Пусть $F\colon L\to L$ -- монотонное отображение на полной решетке $L$ с отношением 
частичного порядка $\sqsubseteq$. Т.е. $\forall X, Y\in L, X\sqsubseteq Y\Rightarrow 
F(X)\sqsubseteq F(Y)$. Теорема Тарского утверждает, что $\operatorname{fix} F$, i.e. множество 
неподвижных точек отображения $F$, само является непустой полной решеткой.

В [38] доказана конструктивная версия этой теоремы. До этой работы, неподвижные точки монотонных 
отображений уже конструировали как $\sup F^i(\bot)$, где $i\in\mathbb{N}$, а $\bot=\inf L$. Но 
это требовало от $F$ непрерывности по Скотту. В [38] же доказывается теорема, которая не требует 
от $F$ этого свойства и утверждая, что $\operatorname{fix} F$ является полной решеткой 
относительно $\sqsubseteq$, предлагает, среди прочего, рецепт вычисления неподвижной точки в 
виде $\inf\operatorname{fix} F=\lim F^k(\bot)$.

Здесь $\lim F^k(\bot)$ определяется как предел стационарной последовательности 
$X^\delta=F(X^{\delta-1})$ при $X^0=\bot$. Считается, что $X^\delta=\sup_{\alpha<\delta} 
X^\alpha$ для предельного ординала $\delta$. Под стационарностью понимается, что начиная с 
некоторго индекса, элементы последовательности имеют одно и то же значение. Для корректного 
погружения в использованные в [38] трансфинитные определения необходимо чтение оригинальной 
статьи.

(Эти результаты обобщаются на случай полных частично упорядоченных множеств, только 
направленные, а не произвольные подмножества которых обязаны иметь супремум.)

## Комбинатор неподвижной точки в лямбда-исчислении

В $\lambda$-исчислении [34] для реализации рекурсии используются комбинаторы неподвижной точки, 
в основном $\mathrm{Y}$-комбинатор. Этот комбинатор определяется уравнением $\mathrm{Y} f\equiv 
f(\mathrm{Y} f)$ и в соответствии с этим определением вычисляет неподвижную точку функции $f$, 
т.е. такое выражение $x$, что $f x=x$.

Если конкретная реализация $\lambda$-исчисления поддерживает рекурсивные определения именованных 
символов, то вышеприведенного определения достаточно для работы с $\mathrm{Y}$-комбинатором 
(могут возразить, что в таком случае он не особо-то и нужен; однако, здесь $Y$-комбинатор может 
служить полезной обёрткой для некоторых функций, позволяющей, к примеру, добавить временное 
хранение промежуточных результатов с целью исключения их повторного вычисления, --- т.е., 
кэширование, --- и, соответственно, получить ускорение в духе динамического программирования).

В чистом же $\lambda$-исчислении требуется определить $\mathrm{Y}$-комбинатор в явном виде, 
например как $\mathrm{Y}\equiv \lambda f.\big(\lambda x. f (x x)\big) \big(\lambda x. f (x 
x)\big)$ (известный как комбинатор Карри или парадоксальный комбинатор) или, в случае 
использования императивного языка, задействовать [энергичный] комбинатор Тьюринга $\Theta_v=a 
a$, где $a\equiv\lambda x.\lambda y.y(\lambda z. x x y z)$.

**Теорема о неподвижной точке.**

Несмотря на неочевидность этого утверждения, в нетипизированном $\lambda$-исчислении любое 
выражение имеет неподвижную точку (хотя бы одну).

**Доказательство.**

Пусть $A\equiv\lambda x.\lambda y. y (x x y)$. Комбинатор Тьюринга есть $\mathrm{\Theta}\equiv A 
A$. Утверждается, что для любого $\lambda$-выражения $F$, выражение $N=\mathrm{\Theta} F$ есть 
его неподвижная точка. Чтобы увидеть это, запишем следующую цепочку уравнений:

{% tex block %}
\begin{align*}
N=\mathrm{\Theta} F&= A A F =\\
&=\big(\lambda x. \lambda y.y (x x y)\big) A F \rightsquigarrow
F (A A F)=F(\mathrm{\Theta} F)=F N,
\end{align*}
{% endtex %}

где $\rightsquigarrow$ обозначает последовательность из нуля или нескольких шагов 
$\beta$-редукции. $\blacksquare$

Теперь $\mathrm{Y}$-комбинатор может быть применен для вычисления значений функций, вызывающих 
сами себя, в среде, не имеющей возможности выполнять именованный рекурсивный вызов или вообще не 
поддерживающей именование объектов.

Например, если требуется вычислить функцию $f= \lambda x.(\ldots f\ldots)$, вызывающую саму себя 
по имени $f$, то можно определить новую функцию $F$, принимающую $f$ как аргумент: 
$F\equiv\lambda f.\lambda x.(\ldots f\ldots)$ (а при использовании индексов де Брёйна или 
бинарного лямбда-исчисления мы можем избавиться и от именованных переменных вовсе). После 
определения $F$ мы можем вычислить $f$ как $f=\mathrm{Y} F$, потому что $f$ есть неподвижная 
точка $F$, т.е., $F f=\lambda x.(\ldots f\ldots)=f$, а $\mathrm{Y} F$, как было сказано выше, 
как раз и находит такую неподвижную точку. Желающие могут непосредственной подстановкой 
убедиться, что в этом случае действительно выполняется $F (\mathrm{Y} F)=\mathrm{Y} F$.

Учитывая универсальность $\lambda$-исчисления и вышеприведенную теорему о неподвижной точке [в 
$\lambda$-исчислении], естественно возникает идея об использовании комбинатора неподвижной точки 
для конструирования квайнов. (См. также [2, 47].)

(Утверждение о существовании комбинатора неподвижной точки практически эквивалентно 
вышеприведенный первой рекурсивной теореме Клини, но выглядит более конкретным.)

## Логическое программирование в ограничениях

В [12, 49] приводится интересный метод генерации квайнов с использованием логического 
программирования. Авторы использовали язык логического программирования miniKanren [52], 
позволяющий написать на нём аналог <<основного уравнения квайнов>> $\llbracket q\rrbracket(x)=q$ 
и дать системе решить его относительно $q.$

С использованием реализации miniKanren, выполненной на языке scheme, квайны можно 
генерировать примерно так (`q.scm` взят из [49]):

```scheme
(load "q.scm")
(run 1 (q) (eval-expo q '() q)))
```

Квайны вычисляются быстро (за секунду) и имеют малые размеры.

## Эволюционные алгоритмы

Крайне интересной представляется потенциальная возможность генерации квайнов с помощью 
генетических алгоритмов. Среди многих проблем, возникающих при генерации программ эволюционными 
методами, выделяется проблема сохранения допустимости или синтаксической <<корректности>> 
программ при действии генетических операторов (кроссовер, мутация).

В этом смысле, одним из наиболее пригодных представлений для инкрементной эволюционной 
генерации, являются искусственные нейронные сети (далее ИНС или нейросети). Будучи сетями 
однотипных нелинейных сумматоров, работа которых зависит от весов связей (синапсов) между ними, 
нейросети продолжают сохранять работоспособность даже при почти случайных 
изменениях/<<повреждениях>> в матрице их весовых коэффициентов. Это довольно сильно 
контрастирует с традиционными языками программирования, программы на которых с гораздо большей 
вероятностью подвержены выходу из строя при малейших необдуманных модификациях их исходного 
текста.

Квайны в виде нейросетей уже известны. В [41] описана ИНС, обучающаяся выводить значения своих 
же синаптических коэффициентов. Я же хотел бы здесь сосредоточится на другом способе генерации 
квайнов, а именно на конструировании программ посредством применения генетических алгоритмов к 
промежуточному представлению на основе нейросетей.

Есть интересный экспериментальный язык Anne, [40], придуманный специально для работы с 
нейросетями и транслятор neuralbf [16, 51] того же автора, преобразующий программу на bf в 
описание рекуррентной ИНС. Последняя работа (кому-то могущая показаться несерьёзной) 
фокусируется на применении генетических алгоритмов для совершенствования и исправления уже 
написанных вручную программ (вместо их генерации без начального приближения).

## Цепные квайны

Назовём *цепным квайном* (или итеративным квайном) с периодом $n$, последовательность $n$ программ
$q_0,\ \ldots,\ q_{n-1}$, такую, что $\forall i\in [0;n[\ \forall x\ \llbracket q_i 
\rrbracket(x) = q_{i+1}$ и $q_n=q_0$.

**Теорема (без доказательства).**

Цепные квайны существуют для любого периода $n$.

Всякий, кто пытался писать квайны и цепные квайны, не мог не отметить некоторое отличие в 
сложности их написания -- цепные квайны [при $n>1$] обычно проще истинных квайнов (i.e., тоже 
цепных квайнов, но с периодом $n=1$).

Соответственно, не может не возникнуть вопрос о реализуемости полностью автоматического 
преобразования данной последовательности $\{q_i\}_i$ в настоящий квайн $q=\llbracket 
q\rrbracket(x),\ \forall x$.

## Генератор квайнов, не зависимый от языка

В разделе о конструировании квайнов на основе второй рекурсивной теоремы Клини, приводился 
готовый рецепт, алгоритм генерации квайна для конкретного заранее выбранного языка 
программирования. (Похожий алгоритм возможен и в контексте доказательства теоремы Роджерса.) 
Возможно, что слово <<алгоритм>> здесь можно понимать более формально и буквально.

Представляется интересным вопрос о существовании программы $G$, --- <<квайнтификатора>>, --- 
генерирующей квайн на указанном языке $L$ с использованием некоторого количества образцов кода 
на этом языке. Причем и разумной спецификацией языка $L$ и одновременно образцом кода на нём 
может служить интерпретатор языка $L$ (существующий по теореме об универсальной функции).

Чуть более формально задача может быть поставлена так. Пусть дан интерпретатор $I_L$ языка $L$, 
написанный на своем же входном языке, т.е. для любой программы $p$ на языка $L$ выполняется 
$\llbracket I_L\rrbracket_L(p, x)=\llbracket p\rrbracket_L(x)$. Пусть также $I_L$ оттранслирован 
на референсный язык (семантические скобки без индекса) и существует на нём в виде программы 
$I'_L$. В этом случае справедливо $\llbracket I'_L\rrbracket(p, x)=\llbracket p\rrbracket_L(x)$.

Спрашивается, как может выглядеть программа $G$, такая, что $q=\llbracket G\rrbracket (I_L, 
I'_L)$ и $\llbracket I'_L\rrbracket (q, x)=q$? Выше мы видели, что $q$ есть неподвижная точка 
(по Роджерсу) оператора $\mathrm{quote}$. При попытке реализовать $\mathrm{quote}$ выясняется, 
что структура соответствующей программы сильно схожа со структурой интерпретатора. Возможно, это 
сходство можно использовать для написания $G$... Но это требует дальнейшего обдумывания.

# Заключение

Целью этого сообщения была демонстрация возможности автоматического конструирования квайнов на 
языке редактора sed с использованием доказательства второй рекурсивной теоремы Клини в качестве 
основы. Результат проведенного эксперимента можно считать положительным, хотя *автоматическим* 
такой способ написания квайнов можно назвать только в смысле достаточности запуска единственного 
скрипта `generate.sh` и ликвидации наиболее сложной, если можно так выразиться, творческой 
составляющей в конструировании самореплицирующейся системы.

В целом, сообщение уже немного вышло за рамки очерченных целей. Но о квайнах можно сказать 
больше... В следующих сообщениях этой серии.

# Ссылки

- [1] <http://www.madore.org/~david/computers/quine.html>
- [2] <http://math.berkeley.edu/~kmill/blog/blog_2018_5_31_universality_quines.html>
- [3] <http://en.wikipedia.org/wiki/Smn_theorem>
- [4] <http://en.wikipedia.org/wiki/partial_evaluation>
- [5] <http://fi.ftmr.info>
- [6] <http://ru.wikipedia.org/wiki/диагональный_аргумент>
- [7] <http://ru.wikipedia.org/wiki/теорема_Кантора>
- [8] <http://ru.wikipedia.org/wiki/проблема_остановки>
- [9] <http://ru.wikipedia.org/wiki/автомат_фон_Неймана>
- [10] <http://ru.wikipedia.org/wiki/зонд_фон_Неймана>
- [11] Jiazhen Cai, Robert Paige, Program derivation by fixed point computation, 1989
- [12] William E.Byrd, Eric Holk, Daniel P.Friedman, miniKanren, live and untagged: Quine generation via relational interpreters, 2012
- [13] P.Cousot, R.Cousot, Constructive verstions of Tarski's fixed point theorems, 1979
- [14] S.C.Kleene, Introduction to Meta-Mathematics, 1952
- [15] A.Tarski, A lattice-theoretical fixpoint theorem and its application, 1955
- [16] <http://www.domob.eu/projects/neuralbf.php>
- [17] <https://github.com/MakeNowJust/quine/blob/master/quine.sed>
- [18] <https://github.com/MakeNowJust/quine>
- [19] H.Rogers, Theory of Recursive Functions and Effective Computability
- [20] T.A.Hansen, T.Nikolajsen, J.L.Traff, N.D.Jones, Experiments with Implementation of two Theoretical Constructions
- [21] G.Bonfante, M.Kaczmarek, J-Y.Marion, Toward an Abstract Computer Virology
- [22] G.Bonfante, M.Kaczmarek, J-Y.Marion, A Classification of Viruses through Recursion Theorems, 2007
- [23] Julia L. Lawall, Olivier Danvy, Continuation-Based Partial Evaluation
- [24] Anders Bondorf, Improving Binding Times Without Explicit CPS-Conversion
- [25] D.A.Wheeler, Fully Countering Trusting Trust through Diverse Double-Compiling, 2009
- [26] Douglas R.Hofstadter, Goedel, Escher, Bach: an Eternal Golden Braid, 1979
- [27] P.-M. Binder, Theories of almost everything, 2008
- [28] H.G.Rice, Classes of recursively enumerable sets and their decision problems, 1953
- [29] <https://en.wikipedia.org/wiki/Rice_theorem>
- [30] Gary P.Thompson II, The quine page 
   (self-reproducing code), <http://www.nyx.net/~gthompso/quine.htm>
- [31] <http://www.nyx.net/~gthompso/self_kim.txt>
- [32] <http://www.latrobe.edu.au/phimvt/joy>
- [33] <https://gist.github.com/Circiter/7152686>
- [34] <http://en.wikipedia.org/wiki/lambda_calculus>
- [35] Lawrence S.Moss, Recursion Theorems and Self-Replication Via Text Register Machine 
   Programs
- [36] Neil Jones, Computer implementation and application of Kleene's s-m-n and recursion 
   theorem.
- [37] A.Tarski, A lattice theoretical fixpoint theorem and its applications, 1955
- [38] P.Cousot, R.Cousot, Constructive versions of Tarski's fixed point theorems, 1979
- [39] J.Case, S.E.Moelius III, Program Self-Reference in Constructive Scott Subdomains, 2009
- [40] <http://compann.sourceforge.net>
- [41] O.Chang, H.Lipson, Neural Network Quine, 2018
- [42] <http://en.wikipedia.org/wiki/quine>
- [43] F.William Lawvere, Diagonal arguments and cartesian closed categories, 1969
- [44] Noson S.Yanofsky, A Universal Approach to Self-Referential Paradoxes, Incompleteness and 
   Fixed Points, 2003
- [45] Jean-Yves Marion, From Turing machines to computer viruses, 2012
- [46] <https://github.com/Circiter/quine-kleene-generator>
- [47] Kleene Second Recursion Theorem: A Functional Pearl // Proc. ACM 
   Program. Lang., Vol 1, 2018
- [48] Дж. фон Нейман, Теория самовоспроизводящихся автоматов, 1971
- [49] <https://github.com/webyrd/quines>
- [50] В.М.Зюзьков, Теория алгоритмов: Учебное пособие, 2005
- [51] <https://gitlab.com/domob/neuralbf>
- [52] <https://github.com/miniKanren>
- [53] <http://www.michaelwehar.com/quines>
- [54] <http://www.keithschwarz.com/kleene>
- [55] <http://www.nyx.net/~gthompso/quine-1.1.0.tar.gz>
