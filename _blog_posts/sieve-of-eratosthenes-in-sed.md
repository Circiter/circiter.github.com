---
layout: post
title: "Решето Эратосфена на sed."
sig: true
toc: true
xdate: "сентябрь, 2020"
tags: программирование математика эзотерика sed теория-чисел trivia гипотеза-Коллатца 3x+1 математические-болезни
abstract: Описывается сценарий для широкоизвестного текстового редактора sed, генерирующий 
          простые числа с помощью решета Эратосфена. На основе данной реализации решета написан 
          скрипт факторизации чисел, а также скрипты, реализующие альтернативные подходы к 
          обнаружению/детектированию анаграмм и к численной симуляции динамической системы из 
          гипотезы Коллатца.
---

# Введение

Иногда в сценариях (скриптах) для поточного редактора sed требуются простые числа. И, учитывая 
отсутствие в sed нормальной поддержки арифметики, использование решета Эратосфена выглядит 
удачным решением для генерации простых чисел прямо в sed-скрипте. Поверхностный поиск в 
поисковых машинах интернета не дал конкретных результатов, поэтому я решил написать этот скрипт 
самостоятельно, а в этой заметке рассказать о его работе.

Скрипт (`sieve.sed`) получился довольно компактным, по крайней мере в том смысле, что код печати 
результатов занимает лишь немного меньше половины всего исходного текста. Интересно, что на 
основе этой реализации решета не составляет труда написать утилиту факторизации чисел (см. 
`factor.sed`). Фактически, первая версия `factor.sed` была получена удалением кода печати 
результатов (i.e. удалением почти половины кода, см. выше) и добавлением всего одной 
строчки/инструкции в код решета. Она печатала факторы в унарной системе счисления и не 
определяла степени найденных простых делителей (т.е., строго говоря, находила не все делители). 
Её улучшение потребовало некоторых усилий и привело к некоторому увеличению и дублированию кода 
(другими словами, существует потенциал для сокращения объема кода `factor.sed`).

# Теоретическая основа просеивания

Работа решета заключается в итеративном удалении --- вычеркивании --- составных чисел из 
текущего рабочего множества чисел $M_i\subset\mathbb{N}$. На каждом шаге $i$ удаляются все 
числа, кратные очередному найденному простому числу $p_i$. Новым простым числом $p_{i+1}$ 
становится наименьшее невычеркнутое число, большее $p_i$: $p_{i+1}=\min\mathcal{M}_{i+1}$, где 
$\mathcal{M}_{i+1}=\{m\in M_{i+1} \mid m>p_i\}$. Если же $\mathcal{M}=\varnothing$, то процесс 
завершается, а последнее множество $M=M_{i+1}$ (N.B., равное $\{p_i\}_i$) становится результатом 
его работы.

В качестве начального приближения выбирается интервал $M_0=[2; n]$ для данного $n$, --- длины 
решета, --- и полагается $p_0=2$.

Более структурированно:
{% tex block %}
\begin{align*}
1.\ &M\gets [2; n]\\
2.\ &p\gets 2\\ 
3.\ &M\gets M\setminus\{x=kp\}_{k=2}\\
4.\ &\mathcal{M}\gets \{m\in M \mid m>p\}\\
5.\ &\mathcal{M}=\varnothing \Rightarrow \operatorname{return} M\\
6.\ &p\gets \min\mathcal{M}\\
7.\ &\operatorname{goto} 3.
\end{align*}
{% endtex %}

Утверждается, что $M=\{p\in\mathbb{P} \mid p\leqslant n\}$, где $\mathbb{P}$ -- множество 
простых чисел.

**Набросок доказательства**

Озвученный алгоритм порождает индуктивное доказательство.

База: $p_0=\min M_0=2$.

Предположение индукции: $\{m\in M_{i+1} \mid m\leqslant p_i\} = \mathbb{P}_{\leqslant p_i}$, где 
$M_{i+1}=M_i\setminus\{kp_i\}_{k=2}$. Эта рекуррентная формула своим следствием имеет $$\forall 
j\leqslant i,\ k>1\ kp_j\notin M_{i+1}.\eqno (1)$$

Шаг индукции: необходимо показать, что $p_{i+1}$ -- следующее простое число. Итак, допустим мы 
выбрали $p_{i+1} = \min\mathcal{M}_{i+1}$. Факторизуем его, $p_{i+1}=\prod_j\rho_j$, где 
$\rho_j\in\mathbb{P}$. Формула (1) говорит, что числа, кратные простым $p\leqslant p_i$ уже 
удалены из $M_{i+1}$, а значит и из $\mathcal{M}_{i+1}$; поэтому $\rho_j>p_i$.

(Имеется в виду, что для некоторого $j$, $\rho_j$ можно вынести за знак произведения: 
$\rho_j\prod_{k\neq j}\rho_k$, и именно поэтому $\rho_j$ не может быть меньше или равен $p_i$ -- 
такие кратные уже вычеркнуты; если же $\rho_j$ есть единственный множитель, то тем более он 
должен быть больше $p_i$ -- по определению множества $\mathcal{M}_{i+1}$, по которому и берется 
минимум для нахождения разлагаемого $p_{i+1}$.)

Также понятно, что множители $\rho_j$ не превышают самого числа $p_{i+1}$, т.е. $\rho_j\leqslant 
p_{i+1}$.

Конкретно, из $\rho_j\leqslant p_{i+1}$ и нефакторизуемости $\rho_j\in\mathbb{P}$ следует, что 
$\rho_j\in M_{i+1}$ (i.e., $\rho_j$ никогда не вычеркивалось и не будет вычеркиваться). А из 
$\rho_j>p_i$ следует, что $\rho_j\in\mathcal{M}_{i+1}$. При этом, если $\rho_j<p_{i+1}$ (а не 
$\rho_j=p_{i+1}$), то это противоречит минимальности $p_{i+1}=\min\mathcal{M}_{i+1}$.

Значит, от противного, $\rho_j=p_{i+1}$. Т.е. $p_{i+1}\in\mathbb{P}$ и других простых между 
$p_i$ и $p_{i+1}$ нет (иначе они не были бы вычеркнуты на предыдущих шагах и входили бы в 
$\mathcal{M}_{i+1}$, что опять противоречило бы минимальности $p_{i+1}$ в $\mathcal{M}$). 
$\blacksquare$

# Реализация

## Принцип работы `sieve.sed`

Общий пошаговый вид алгоритма:

- Чтение длины решета (конвертация десятичного числа в унарное).
- Просеивание бинарной строки, полученной на основе унарного числа из предыдущего шага.
  + Поиск следующего простого, т.е. первой ближайшей единицы, лежащей правее текущего простого.
  + Вычеркивание чисел, кратных найденному простому; под вычеркиванием понимается изменение 1 на 
    0 в соответствующих позициях решета.
- Печать решета.
  + Решето проходится слева-направо.
  + На каждом шаге инкрементируется счетчик (изначально обнулённый).
  + Если в текущей позиции решета записана единица, то значание счётчика выводится на экран.

Возможно есть смысл немного детализировать работу решета на этапе поиска следующего простого 
числа. Сначала перед решетом приписывается маркер `#`. Далее, в уже частично заполненном решете 
отыскивается первая единица, лежащая правее маркера `#`, после чего этот маркер перемещается на 
позицию сразу после этой единицы. Длина части решета, лежащей левее маркера есть новое простое 
число. Этот префикс копируется на следующую строчку и может считаться записью найденного 
простого числа в унарной системе счисления.

После символа `#` добавляется вспомогательный маркер `@`, а в начало следующей строки -- маркер 
`:`, после чего оба маркера начинают сдвигаться вправо на один символ за раз. Если маркер `:` 
оказывается в конце второй строки, а `@` ещё не дошёл до конца первой, то маркер `@` с 
необходимостью оказывается сразу после следующего составного числа и мы можем записать в эту 
позицию ноль, независимо от значения, которое было там ранее.

Процесс перемещения маркеров `@` и `:` продолжается до вычеркивания всех множителей текущего 
простого числа, после чего эти маркеры удаляются и описанный процесс повторяется.

## Принцип работы `factor.sed`

Этот скрипт написан на основе вышеописанного `sieve.sed`, но код обнаружения нового 
простого числа слегка модифицирован, а после него добавлен код определения показателя степени 
для найденного простого множителя.

Число, подлежащее факторизации используется просто в качестве длины решета. Понятно, что простые 
входящее в этого решето (и только они) будут входить в разложение данного числа на простые 
множители.

Поиск следующего простого отличается от аналогичного кода в скрипте `sieve.sed` фактически лишь 
тем, что при обнаружении простого числа обнуляется отдельный счетчик, а при вычеркивании каждого 
составного числа этот счётчик инкрементируется. Очевидно, что после вычеркивания всех множителей 
текущего простого числа (не выходящих за пределы решета, естественно) значение счётчика будет 
равно целой части результата деления исходного факторизуемого числа на текущий простой 
множитель.

Далее мы должны просто продолжать делить значение этого счётчика на текущее простое число, пока 
счётчик не обнулится. Причём после каждой операции деления мы снова переходим к коду, 
выполненному после обнаружения текущего простого числа (т.е. мы печатаем тоже самое простое 
число ещё раз, делим счётчик на это простое и т.д.).

В результате, скрипт печатает текущий простой множитель нужное количество раз, а после печати 
всех простых множителей, мы получаем полное разложение исходного числа, равного длине решета.

# Больше эзотерики

Также были написаны два демонстрационных скрипта, `anagram.sed` и `collatz.sed`, использующих 
простые числа и факторизацию для решения задач, в которых в явном виде простые числа обычно не 
применяют. Первый скрипт (вместо которого, естественно, гораздо эффективнее было бы использовать 
композицию сортировки символов в строках и сравнения результирующих строк-последовательностей) 
реализует идею из [2, 7] и эксплуатирует основную теорему арифметики [6] для детектирования 
анаграмм, т.е. для определения, являются ли две данные строки-последовательности перестановками 
друг-друга. Каждому символу последовательностей сопоставляется единственным образом некоторое 
простое число, после чего все эти числа, соответствующие символам из конкретной строки, 
перемножаются. Основная теорема арифметики вместе с коммутативностью умножения гарантируют, что 
анаграммы будут давать одинаковые произведения-сигнатуры.

Ранее написанный алгоритм просеивания был модифицирован/упрощён для работы только с двоичными 
числами. Для умножения двоичных чисел я использовал код из gist'а [5].

Второй скрипт, `collatz.sed`, реализует известную динамическую систему из гипотезы $3x+1$ (см. 
[3]), но вместо привычных операций $3x+1$ и $x/2$ используются манипуляции с простыми числами, 
на мой взгляд лучше показывающие истинную теоретико-числовую суть гипотезы Коллатца.

Пусть дана функция $$T(x)=\begin{cases}3x+1, & x\equiv 1\pmod 2\\x/2.\end{cases}$$

Гипотеза Коллатца утверждает, что $\forall x\in\mathbb{N}\ \exists k\in\mathbb{N}\ T^k(x)=1$. 
Более точно, похоже, что для всех натуральных $x$ итерации $T(x)$ сходятся к циклу $1\to 4\to 2\ 
\to 1$.

Если при каждом применении $T(x)$ сначала производить разложение $x$ на простые множители, то 
деление на два будет сводится к вычеркиванию двойки (на деле, можно заодно вычеркивать все 
двойки сразу) из факторизации. Операция $3x+1$ будет соответствовать приписыванию тройки, 
перемножению оставшихся факторов и прибавлению единицы к результату.

Прибавление единицы гарантирует, что результат не будет делиться на всё, на что делилось число 
$x$, или, другими словами, в факторизации результата операции $3x+1$ будут задействованы совсем 
другие множители, ни одного из которых не было в факторизации $x$. Добавление же тройки 
гарантирует, что в разложении $3x+1$ никаких троек тоже не будет, даже если их и не было в 
разложении $x$ изначально.

Если достаточно разнообразных множителей для формирования $3x+1$ не найдется, это будет 
означать, что после вычеркивания двоек у нас останется пустая факторизация, т.е. результат 
превратится в единицу.

(Фактически, мы имеем дело с гонкой двух процессов -- процессом <<генерации>> простых чисел, 
скажем, решетом, и процессом их <<потребления>> за счёт прибавления единицы; судя по 
экспериментам, процесс потребления работает быстрее -- в какой-то момент, независимо от 
стартового значения, новых простых не оказывается в наличии и итерации сходятся к уже 
упоминавшемуся циклу $1, 4, 2, 1, \ldots$)

Возможно небольшое обобщение этой динамической системы -- вместо гарантированного исключения 
только троек в факторизации результата очередной итерации, можно исключать все простые, не 
превышающие некоторого данного параметра $m$ (e.g., при $m=7$ этот вариант гипотезы Коллатца, 
кроме вычеркивания двоек, будет гарантировать отсутствие факторов 3, 5 и 7 на каждом шаге). 
Качественное поведение оказывается похожим на поведение оригинальной динамической системы -- 
траектория почему-то всегда <<падает>> на единицу.

(Гипотеза $3x+1$ по праву относится к классу задач, многими называемыми <<математическими 
болезнями>>; в таких задачах сочетается предельная простота формулировки условия с неподдающейся 
многим математикам сложностью решения, а в данном случае, по всей видимости, вообще с полной 
неготовностью современной математики к доказательству этой гипотезы.)

# Комплектация поставки

* `plain-sieve.sed` -- принимает длину решета и возвращает бинарную последовательность с 
  единицами только в позициях, соответствующих простым числам (самая первая, левая позиция 
  соответствует единице и поэтому всегда равна 0).
  
  Пример: `echo 10 | ./plain-sieve.sed` вернёт `0110101000` (единицы в позициях 2, 3, 5 и 7).
  
* `sieve.sed` -- основной скрипт (кратко описанный в разделе <<Реализация>>; см. выше), 
  принимающий длину решета и возвращающий (точнее говоря, печатающий) список (с разделением 
  переводом строки) простых чисел, не превышающих данной длины.
  
  Пример: `echo 10 | ./sieve.sed` возвращает:

  ```
  2
  3
  5
  7
  ```

* `binary-sieve.sed` -- скрипт аналогичен предыдущему, но работает в двоичной системе счисления 
  (i.e. и длину решета принимает в виде бинарного числа и простые числа печатает тоже в 
  двоичной записи; это немного упрощает код чтения и печати чисел) .
  
  Пример: `echo 1010 | ./binary-sieve.sed`

  ```
  10
  11
  101
  111
  ```
  
  Действительно, $1010_2=10$, $10_2=2$, $11_2=3$, $101_2=5$ и $111_2=7$.

* `anagram.sed` и `collatz.sed` были описаны в предыдущем разделе этого сообщения. Скрипт 
  `anagram.sed` сейчас поддерживает только латинские символы, а `collatz.sed` печатает только 
  <<ключевые>> точки траектории $3x+1$, т.е. строит последовательность итерируя отображение 
  $x\mapsto 3\frac{x}{2^{k(x)}}+1$, где $k(x)$ есть степень множителя 2 в факторизации числа 
  $x$. E.g. для начального числа $10=1010_2$ будет построена последовательность $1010_2\to 
  10000_2\to 1$, i.e. 10 будет поделено на 2, затем этот результат без печати на экране будет 
  утроен и инкрементирован, что даст 16 ($10000_2$), а это последнее число будет напечатано и 
  сразу же [целочисленно] разделено на максимально возможную здесь степень двойки, $2^4$, что 
  даст последнюю точку траектории, 1.

* `anagrams.txt` -- примеры анаграмм для тестирования `anagram.sed`.

* `factor.sed` -- производит разложение данного числа на простые множители (работа скрипта уже
  была описана в резделе <<Реализация>>).
  
  Пример: `echo 18 | ./factor.sed`

  ```
  2
  3
  3
  ```

  Как и ожидалось, $18=2\cdot 3\cdot 3$.

* `factor-hack-unary.sed` -- простой скрипт, вместо решета использующий <<обратные ссылки>> в
  регулярном выражении (следуя [4, 8, 9]) для факторизации числа, представленного в унарной 
  системе счисления.
  
  Примечание: здесь используются расширенные <<регулярные>> выражения, поддерживающие ссылки 
  вида `\1`, `\2`, etc., и не являющиеся именно регулярными в привычном смысле -- такие 
  выражения с обратными ссылками не удастся скомпилировать в конечный автомат.
  
  Скрипт на самом деле имеет дело со списком чисел (разделенных переводом строки), подлежащих 
  разложению. Но разложению подвергается только одно из них, помеченное специальным маркером.
  
  Для числа $n$ используется регулярное выражение, аналогичное выражению {% raw 
  %}`/^(11+)(\1+)$/`{% endraw %}. Как видно, оно выделяет некую группу из не менее чем двух 
  единиц при помощи подвыражения `(11+)`, т.е. выделяет один множитель $a$ (возможно составной), 
  и с помощью подвыражения `(\1+)` проверяет, можно ли представить оставшуюся часть числа 
  конкатенацией некоторого ненулевого количества копий этой группы (без остатка).

  Если это не удалось сделать, то $n$ либо равно единице, либо является простым. В противном 
  случае скрипт производит деление числа на найденный множитель: $b=n/a$. Для этого, в цикле, 
  найденная ранее группа единиц, находящаяся в самом начале числа, заменяется на подходящий 
  маркер (в данном случае используется символ `_`). Т.о., по завершению цикла, количество 
  символов подчеркивания равно $b$ и заменой `s/_/1/g` можно получить этот второй, возможно тоже 
  составной множитель. Множитель $b$ добавляется в список чисел.
  
  Теперь скрипт рекурсивно обрабатывает найденный множитель $a$ (пометив его специальным 
  маркером и начав факторизацию заново) по уже описанной схеме и продолжает процесс, перемащая 
  маркер к следующему числу в списке при каждой <<неудачной>> факторизации (т.е. когда 
  помеченный множитель оказывается простым или равным единице), пока всё исходное число не 
  окажется разложенным на простые множители.
  
  В других диалектах регулярных выражений могут поддерживаться те или иные средства управления 
  жадностью -- так в источнике [9] вместо `11+` применено подвыражение `11+?`, которое как раз и 
  указывает механизму сопоставления с образцом действовать нежадно, минимизируя длину найденной 
  подстроки; но в sed таких средств, кажется, нет, а в данном конкретном случае, за счёт 
  рекурсивной обработки всё вновь получаемых множителей, неопределенной жадности вполне 
  достаточно.
  
  Интересно, что если для сопоставления с образцом `11+` используется гарантированно жадная 
  стратегия, то, коль скоро это соответствует максимизации $a$ в разложении $n=a\cdot b$, это 
  минимизирует $b$ и обеспечивает т.о. его простоту. Данное наблюдение могло бы позволить слегка 
  сократить и ускорить скрипт, но я не воспользовался такой возможностью (потому что всё и так 
  работает, да ещё и не зависит от стратегии поиска, выбранной конкретной реализацией регулярных 
  выражений).
  
  Пример работы скрипта: `echo 111111111111111111 | ./factor-hack-unary.sed`

  ```
  111
  111
  11
  ```
  
  Так и должно быть: $18=3\cdot 3\cdot 2$.

# Ссылки

<div class="bib">

- [1] <http://ru.wikipedia.org/wiki/решето_Эратосфена>
- [2] <http://skerritt.blog/an-algorithm-for-finding-anagrams>
- [3] <http://ru.wikipedia.org/wiki/гипотеза_Коллатца>
- [4] <http://news.ycombinator.com/item?id=9039537>
- [5] <https://gist.github.com/Circiter/042264eb9e9ee360d0eafa10eedf3f21>
- [6] <http://en.wikipedia.org/wiki/fundamental_theorem_of_arithmetic>
- [7] <http://quanterocapital.com/anagrams-mathematically-speaking>
- [8] <http://montreal.pm.org/tech/neil_kandalgaonkar.shtml>
- [9] <http://www.mit.edu:8008/bloom-picayune.mit.edu/perl/10138>

</div>

