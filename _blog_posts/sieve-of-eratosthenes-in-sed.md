---
layout: post
title: "Решето Эратосфена на sed."
sig: true
toc: true
xdate: "сентябрь, 2020"
tags: программирование математика эзотерика sed теория-чисел trivia гипотеза-Коллатца 3x+1 математические-болезни
abstract: Описывается сценарий для широкоизвестного текстового редактора sed, генерирующий 
          простые числа с помощью решета Эратосфена. На основе данной реализации решета написан 
          скрипт факторизации чисел, а также скрипты, реализующие альтернативные подходы к 
          обнаружению/детектированию анаграмм и к численной симуляции динамической системы из 
          гипотезы Коллатца. В конце сообщения речь идёт о возможных оптимизациях решета 
          Эратосфена, и, в частности, описывается решето Эйлера, тоже реализованное в виде 
          скрипта для sed.
---

# Введение

Иногда в сценариях (скриптах) для поточного редактора sed требуются простые числа. И, учитывая 
отсутствие в sed нормальной поддержки арифметики, использование решета Эратосфена {% cite 
wiki-sieve %} выглядит удачным решением для генерации простых чисел прямо в sed-скрипте. 
Поверхностный поиск в поисковых машинах интернета не дал конкретных результатов, поэтому я решил 
написать этот скрипт самостоятельно, а в этой заметке рассказать о его работе.

Скрипт (`sieve.sed`) получился довольно компактным, по крайней мере в том смысле, что код печати 
результатов занимает лишь немного меньше половины всего исходного текста. Интересно, что на 
основе этой реализации решета не составляет труда написать утилиту факторизации чисел (см. 
`factor.sed`). Фактически, первая версия `factor.sed` была получена удалением кода печати 
результатов (i.e. удалением почти половины кода, см. выше) и добавлением всего одной 
строчки/инструкции в код решета. Она печатала факторы в унарной системе счисления и не 
определяла степени найденных простых делителей (т.е., строго говоря, находила не все делители). 
Её улучшение потребовало некоторых усилий и привело к некоторому увеличению и дублированию кода 
(другими словами, существует потенциал для сокращения объема кода `factor.sed`).

(Обсуждаемые скрипты могут быть найдены в {% cite sieve-in-sed %}.)

# Теоретическая основа просеивания

Работа решета заключается в итеративном удалении --- вычеркивании --- составных чисел из 
текущего рабочего множества чисел $M_i\subset\mathbb{N}$. На каждом шаге $i$ удаляются все 
числа, кратные очередному найденному простому числу $p_i$. Новым простым числом $p_{i+1}$ 
становится наименьшее невычеркнутое число, большее $p_i$: $p_{i+1}=\min\mathcal{M}_{i+1}$, где 
$\mathcal{M}_{i+1}=\{m\in M_{i+1} \mid m>p_i\}$. Если же $\mathcal{M}=\varnothing$, то процесс 
завершается, а последнее множество $M=M_{i+1}$ (N.B., равное $\{p_i\}_i$) становится результатом 
его работы.

В качестве начального приближения выбирается интервал $M_0=[2; n]$ для данного $n$, --- длины 
решета, --- и полагается $p_0=2$.

Более структурированно:
{% tex block %}
\begin{align*}
1.\ &M\gets [2; n]\\
2.\ &p\gets 2\\ 
3.\ &M\gets M\setminus\{x=kp\}_{k=2}\\
4.\ &\mathcal{M}\gets \{m\in M \mid m>p\}\\
5.\ &\mathcal{M}=\varnothing \Rightarrow \operatorname{return}\ M\\
6.\ &p\gets \min\mathcal{M}\\
7.\ &\operatorname{goto}\ 3.
\end{align*}
{% endtex %}

Утверждается, что $M=\{p\in\mathbb{P} \mid p\leqslant n\}$, где $\mathbb{P}$ -- множество 
простых чисел.

**Набросок доказательства**

Озвученный алгоритм порождает индуктивное доказательство.

База: $p_0=\min M_0=2$.

Предположение индукции: $\{m\in M_{i+1} \mid m\leqslant p_i\} = \mathbb{P}_{\leqslant p_i}$, где 
$M_{i+1}=M_i\setminus\{kp_i\}_{k=2}$. Эта рекуррентная формула своим следствием имеет $$\forall 
j\leqslant i,\ k>1\ kp_j\notin M_{i+1}.\eqno (1)$$

Шаг индукции: необходимо показать, что $p_{i+1}$ -- следующее простое число. Итак, допустим мы 
выбрали $p_{i+1} = \min\mathcal{M}_{i+1}$. Факторизуем его, $p_{i+1}=\prod_j\rho_j$, где 
$\rho_j\in\mathbb{P}$. Формула (1) говорит, что числа, кратные простым $p\leqslant p_i$ уже 
удалены из $M_{i+1}$, а значит и из $\mathcal{M}_{i+1}$; поэтому $\rho_j>p_i$.

(Имеется в виду, что для некоторого $j$, $\rho_j$ можно вынести за знак произведения: 
$\rho_j\prod_{k\neq j}\rho_k$, и именно поэтому $\rho_j$ не может быть меньше или равен $p_i$ -- 
такие кратные уже вычеркнуты; если же $\rho_j$ есть единственный множитель, то тем более он 
должен быть больше $p_i$ -- по определению множества $\mathcal{M}_{i+1}$, по которому и берется 
минимум для нахождения разлагаемого $p_{i+1}$.)

Также понятно, что множители $\rho_j$ не превышают самого числа $p_{i+1}$, т.е. $\rho_j\leqslant 
p_{i+1}$.

Конкретно, из $\rho_j\leqslant p_{i+1}$ и нефакторизуемости $\rho_j\in\mathbb{P}$ следует, что 
$\rho_j\in M_{i+1}$ (i.e., $\rho_j$ никогда не вычеркивалось и не будет вычеркиваться). А из 
$\rho_j>p_i$ следует, что $\rho_j\in\mathcal{M}_{i+1}$. При этом, если $\rho_j<p_{i+1}$ (а не 
$\rho_j=p_{i+1}$), то это противоречит минимальности $p_{i+1}=\min\mathcal{M}_{i+1}$.

Значит, от противного, $\rho_j=p_{i+1}$. Т.е. $p_{i+1}\in\mathbb{P}$ и других простых между 
$p_i$ и $p_{i+1}$ нет (иначе они не были бы вычеркнуты на предыдущих шагах и входили бы в 
$\mathcal{M}_{i+1}$, что опять противоречило бы минимальности $p_{i+1}$ в $\mathcal{M}$). 
$\blacksquare$

# Реализация

## Принцип работы `sieve.sed`

Общий пошаговый вид алгоритма:

- Чтение длины решета (конвертация десятичного числа в унарное).
- Просеивание бинарной строки, полученной на основе унарного числа из предыдущего шага.
  + Поиск следующего простого, т.е. первой ближайшей единицы, лежащей правее текущего простого.
  + Вычеркивание чисел, кратных найденному простому; под вычеркиванием понимается изменение 1 на 
    0 в соответствующих позициях решета.
- Печать решета.
  + Решето проходится слева-направо.
  + На каждом шаге инкрементируется счетчик (изначально обнулённый).
  + Если в текущей позиции решета записана единица, то значание счётчика выводится на экран.

Возможно есть смысл немного детализировать работу решета на этапе поиска следующего простого 
числа. Сначала перед решетом приписывается маркер `#`. Далее, в уже частично заполненном решете 
отыскивается первая единица, лежащая правее маркера `#`, после чего этот маркер перемещается на 
позицию сразу после этой единицы. Длина части решета, лежащей левее маркера есть новое простое 
число. Этот префикс копируется на следующую строчку и может считаться записью найденного 
простого числа в унарной системе счисления.

После символа `#` добавляется вспомогательный маркер `@`, а в начало следующей строки -- маркер 
`:`, после чего оба маркера начинают сдвигаться вправо на один символ за раз. Если маркер `:` 
оказывается в конце второй строки, а `@` ещё не дошёл до конца первой, то маркер `@` с 
необходимостью оказывается сразу после следующего составного числа и мы можем записать в эту 
позицию ноль, независимо от значения, которое было там ранее. Теперь маркер `:` возвращается в 
начало второй строки.

Процесс перемещения маркеров `@` и `:` продолжается до вычеркивания всех множителей текущего 
простого числа (i.e., пока `@` не дойдёт до конца первой строки), после чего эти маркеры 
удаляются и описанный процесс повторяется.

## Принцип работы `factor.sed`

Этот скрипт написан на основе вышеописанного `sieve.sed`, но код обнаружения нового 
простого числа слегка модифицирован, а после него добавлен код определения показателя степени 
для найденного простого множителя.

Число, подлежащее факторизации используется просто в качестве длины решета. Понятно, что 
простые, входящие в этого решето (и только они) будут входить в разложение данного числа на 
простые множители.

Поиск следующего простого отличается от аналогичного кода в скрипте `sieve.sed` фактически лишь 
тем, что при обнаружении простого числа обнуляется отдельный счетчик, а при вычеркивании каждого 
составного числа этот счётчик инкрементируется. Очевидно, что после вычеркивания всех множителей 
текущего простого числа (не выходящих за пределы решета, естественно) значение счётчика будет 
равно целой части результата деления исходного факторизуемого числа на текущий простой 
множитель.

Далее мы должны просто продолжать делить значение этого счётчика на текущее простое число, пока 
счётчик не обнулится. Причём после каждой операции деления мы снова переходим к коду, 
выполненному после обнаружения текущего простого числа (т.е. мы печатаем тоже самое простое 
число ещё раз, делим счётчик на это простое и т.д.).

В результате, скрипт печатает текущий простой множитель нужное количество раз, а после печати 
всех простых множителей, мы получаем полное разложение исходного числа, равного длине решета.

# Больше эзотерики

Также были написаны два демонстрационных скрипта, `anagram.sed` и `collatz.sed`, использующих 
простые числа и факторизацию для решения задач, в которых в явном виде простые числа обычно не 
применяют. Первый скрипт (вместо которого, естественно, гораздо эффективнее было бы использовать 
композицию сортировки символов в строках и сравнения результирующих строк-последовательностей) 
реализует идею из {% cite anagrams-alg anagrams-math %} и эксплуатирует основную теорему 
арифметики {% cite wiki-fta %} для детектирования анаграмм, т.е. для определения, являются ли 
две данные строки-последовательности перестановками друг-друга. Каждому символу 
последовательностей сопоставляется единственным образом некоторое простое число, после чего все 
эти числа, соответствующие символам из конкретной строки, перемножаются. Основная теорема 
арифметики вместе с коммутативностью умножения гарантируют, что анаграммы будут давать 
одинаковые произведения-сигнатуры.

Ранее написанный алгоритм просеивания был модифицирован/упрощён для работы только с двоичными 
числами. Для умножения двоичных чисел я использовал код из gist'а {% cite gist-mult %}.

Второй скрипт, `collatz.sed`, реализует известную динамическую систему из гипотезы $3x+1$ (см. 
{% cite wiki-collatz lagarias2010 %}), но вместо привычных операций $3x+1$ и $x/2$ используются 
манипуляции с простыми числами, на мой взгляд лучше показывающие истинную теоретико-числовую 
суть гипотезы Коллатца.

Пусть дана функция $$T(x)=\begin{cases}3x+1, & x\equiv 1\pmod 2\\x/2.\end{cases}$$

Гипотеза Коллатца утверждает, что $\forall x\in\mathbb{N}\ \exists k\in\mathbb{N}\ T^k(x)=1$. 
Более точно, похоже, что для всех натуральных $x$ итерации $T(x)$ сходятся к циклу $1\to 4\to 2\ 
\to 1$.

Если при каждом применении $T(x)$ сначала производить разложение $x$ на простые множители, то 
деление на два будет сводится к вычеркиванию двойки (на деле, можно заодно вычеркивать все 
двойки сразу) из факторизации. Операция $3x+1$ будет соответствовать приписыванию тройки, 
перемножению оставшихся факторов и прибавлению единицы к результату.

Прибавление единицы гарантирует, что результат не будет делиться на всё, на что делилось число 
$x$, или, другими словами, в факторизации результата операции $3x+1$ будут задействованы совсем 
другие множители, ни одного из которых не было в факторизации $x$; с использованием наибольшего 
общего делителя, $\text{НОД}(x, 3x+1)=1$. Добавление же тройки гарантирует, что в 
разложении $3x+1$ никаких троек тоже не будет, даже если их и не было в разложении $x$ 
изначально.

Если достаточно разнообразных множителей для формирования $3x+1$ не найдется, это будет 
означать, что после вычеркивания двоек у нас останется пустая факторизация, т.е. результат 
превратится в единицу.

(Фактически, мы имеем дело с гонкой двух процессов -- процессом <<генерации>> простых чисел, 
скажем, решетом, и процессом их <<потребления>> за счёт прибавления единицы; судя по 
экспериментам, процесс потребления работает быстрее -- в какой-то момент, независимо от 
стартового значения, новых простых не оказывается в наличии и итерации сходятся к уже 
упоминавшемуся циклу $1, 4, 2, 1, \ldots$)

Гипотеза $3x+1$ по праву относится к классу задач, многими называемыми <<математическими 
болезнями>>; в таких задачах сочетается предельная простота формулировки условия с неподдающейся 
многим математикам сложностью решения, а в данном случае, по всей видимости, вообще с полной 
неготовностью современной математики к доказательству этой гипотезы.

# Об оптимизации

В этом сообщении и в предложенных скриптах вообще не применяются распространённые оптимизации 
решета Эратосфена. Но для полноты картины, наверное стоит упомянуть возможные направления для 
улучшения. Во-первых, можно ограничиться рассмотрением только чисел $m$, таких, что $\forall 
p\in\mathbb{P}_{\leqslant h}\ \text{НОД}(m, p)=1$ для некоторого $h\geqslant 2$; 
e.g., при $h=2$ это соответствует игнорированию всех чётных чисел, больших двух, всегда 
по-определению являющихся составными.

Во-вторых, перебор кратных для нечётных простых чисел $p$ можно вести с шагом $2p$, а не $p$; 
при использовании вышеописанного обобщения на случай чисел $m$, взаимно простых с несколькими 
первыми простыми числами [не превышающими $h$], можно генерировать кратные так, чтобы они 
тоже были взаимно простыми с числами из $\mathbb{P}_{\leqslant h}$. См. также {% cite 
wiki-wheel %}.

В-третьих, процесс вычеркивания чисел, кратных очередному найденному простому $p$, можно 
начинать сразу с $p^2$, а не с $2p$; как следствие, не имеет смысла продолжать вычеркивание 
кратных если $p^2>n$. Т.е., множители для $p$, использующиеся при вычеркивании составных чисел, 
образуют множество $\big[p; \lfloor n/p\rfloor\big]$ (максимум здесь выбран так, чтобы после 
умножения на $p$ получилось $p\lfloor n/p\rfloor\leqslant n$, а минимум соответствует началу 
вычеркивания с $p^2$).

(Естественно, желающие могут попробовать добавить эти оптимизации в обсуждаемый скрипт, хотя с 
квадратами в sed, наверное, лучше не связываться).

## Решето Эйлера

Решето Эратосфена может вычеркивать одни и те же числа по нескольку раз. Эйлер придумал (для 
решаемой им в тот момент вполне практической математической задачи) модификацию {% cite 
euler1737 %} решета, позволяющую вычеркивать составные числа только один раз. Алгоритм можно 
описать так:
{% tex block %}
\begin{align*}
1.\ &i\gets 0\\
2.\ &L\gets [2; n]\\
3.\ &p_i\gets\min L\\
4.\ &N\gets p_iL\\
5.\ &L\gets L\setminus N\\
6.\ &L\gets L\setminus\{p_i\}\\
7.\ &L=\varnothing\Rightarrow\operatorname{return}\ \{p_j\}_{j=0}^i\\
8.\ &i\gets i+1\\
9.\ &\operatorname{goto}\ 3
\end{align*}
{% endtex %}

Здесь $n$ является длиной решета (как и в ранее описанном алгоритме для решета Эратосфена). 
Сгенерированные простые числа коллекционируются в множестве $\{p_j\}$, которое и возвращается 
при завершении работы алгоритма.

Все операции производятся с рабочим множеством чисел $L$, изначально равным отрезку $[2; n]$. На 
каждой итерации выбирается минимальный элемент $\min L$ этого множества и объявляется следующим 
простым числом (сразу же сохраняемым в $p_i$ при текущем значении $i$), после чего формируется 
новое множество произведений $N=p_iL=\{p_ix\mid x\in L\}$, т.е., числа кратные $p_i$, но ещё не 
ни разу не вычеркнутые, помечаются для последующего удаления. После этого, помеченные числа 
удаляются из рабочего множества с помощью теоретико-множественной операции вычитания $L\gets 
L\setminus N$. Ставший теперь ненужным элемент $p_i$, до сих пор остававшийся в множестве $L$ 
(т.к. до этого, при формировании вспомогательного множества помеченных чисел $N$, умножался как 
минимум на 2), удаляется из $L$. И если это множество стало пустым, то алгоритм завершается, в 
противном же случае инкрементируется счётчик итераций $i$ и процесс повторяется (с поиска нового 
минимального элемента $L$).

Несмотря на некоторые внешние различия, суть этого алгоритма всё та же: для каждого очередного 
простого числа из решета удаляются/вычеркиваются все числа, кратные ему, в результате чего 
следующее невычеркнутое число тоже оказывается простым. Итерирование этих манипуляций приводит к 
<<просеиванию>> исходного набора чисел и к удалению всех составных чисел (в решете Эйлера, в 
отличии от оригинального решета Эратосфена, простые числа тоже удаляются из рабочего множества, 
но по мере их обнаружения они накапливаются в другом множестве или, скажем, выводятся на 
печать).

Важно, что элементы, помечаемые для удаления (т.е. добавляемые в $N$), по прежнему участвуют в 
процессе пополнения множества $N$.

(Нижеследующий материал написан по мотивам {% cite sorenson1990 %}.)

Чем же обеспечивается главное свойство решета Эйлера, т.е. почему в $N$ никогда не попадают уже 
удаленные из $L$ числа? Если в $N$ попало число, большее $n$, то оно, очевидно, не может быть 
удалено повторно из $L$, так как там таких больших чисел просто не было изначально: $\forall 
x\in L\ x\leqslant n$ по построению. Если же $a\in N$ не превышает $n$, то исходя из смысла 
присваивания $N\gets p_iL$ (см. шаг 4 вышеприведенного алгоритма), $a=p_ib$, где $b\in L$.

Суть в том, что любое натуральное число $x$ можно единственным образом представить в виде 
$x=pf$, где $p$ -- наименьший простой делитель (фактор) числа $x$. При этом среди факторов числа 
$f$, очевидно, не будет чисел, меньших $p$. (Т.е. мы просто <<отсоединяем>> наименьший фактор 
$p$ от $x$ и формируем разложение $x=pf$ полагая $f=x/p$; тогда из основной теоремы арифметики 
{% cite wiki-fta%}, т.е. из единственности факторизации, как раз и следует единственность 
требуемого разложения $pf$.)

Применительно к решету, это означает, что для текущего найденного простого $p$, множество 
$\mathcal{L}(p)$ множителей, при перемножении $p$ на которые будут получаться новые составные 
числа, подлежащие вычеркиванию, равно $\mathcal{L}(p)=\{f\colon f\in[p; n], \forall q<p\ 
\text{НОД}(q, f)=1\}$.

Покажем, что такое определение $\mathcal{L}(p)$ совпадает с $L$ из алгоритма (см. выше). На 
каждой итерации, если $p=p_i$, то $\forall x\in L\ j<i\Rightarrow \text{НОД}(x, 
p_j)=1$, т.е. все числа из $L$, большие чем $p_i$ не делятся на простые меньшие $p_i$ ведь 
составные числа, делящиеся на $p_i$ уже были вычеркнуты на предыдущих итерациях алгоритма. 
(Здесь идет речь об $L$ до шага 5, т.е. до операции $L\gets L\setminus N$.)

Т.о., $L$ содержит числа из промежутка $[p; n]$, не делящиеся на простые, меньшие $p$, т.е. 
$L=\{f\colon f\in[p; n], \forall q<p\ \text{НОД}(q, f)=1\}$. Это совпадает с 
выражением для $\mathcal{L}(p)$.

Осталось показать, что $\forall x\in N=pL\ x\leqslant n\Rightarrow x\in L$, т.е., что подлежащие 
вычеркиванию числа $N$ уже присутствуют в $L$ (либо просто выходят за пределы решета) и их не 
придётся вычеркивать повторно. Как мы уже выяснили, каждый такой $x=pf$, для некоторого $f\in 
\mathcal{L}(p)=L$ единственен и так как на всех предыдущих итерациях алгоритма мы удаляли лишь 
числа, наименьший фактор которых был меньше $p$, то из $x\leqslant n$ и начального приближения 
для $L$, равного $[2; n]$, как раз и следует, что $x\in L$.

За более подробной информацией о решете Эйлера следует обратиться, e.g., к {% cite wiki-sieve 
gries-misra sorenson1990 %} . Интересно, что в некоторых работах, например, в той же {% cite 
gries-misra %}, прямые отсылы к Эйлеру отсутствуют, поэтому иногда говорят, что это решето 
неоднократно переизобреталось различными авторами.

Возможно, что причиной этого библиографического казуса является некоторая неявность введения 
решета в работе Эйлера. Эйлер игрался с $\zeta$-функцией Римана, разлагающейся в ряд Дирихле 
$$\zeta(s)=\sum_{k=1}^\infty k^{-s},\eqno(2)$$ для $s\in\mathbb{C}$. Для доказательства важного 
тождества $\zeta(s)=\prod_{p\in\mathbb{P}}(1-p^{-s})^{-1}$, Эйлер строил последовательность 
$\zeta_{i+1}=\zeta_i-(\min\{k\colon k\in L_i,\ k>1\})^{-s}\zeta_i$ начиная с $\zeta_0=\zeta(s)$. 
Здесь $L_i\subseteq\mathbb{N}$ -- такое множество, что $\zeta_i=\sum_{k\in L_i} k^{-s}$.

Сначала, естественно, $L_0=\mathbb{N}_{>0}$, и поэтому $\min\{k\colon k\in L_0,\ k>1\}$ равен 2, 
т.е. первому простому числу. Умножение $2^{-s}$ на сумму $\zeta_0$, равную $(2)$ даёт новую 
сумму, в которой все основания кратны двум. Соответственно, вычитание $\zeta_0-2^{-s}\zeta_0$ 
обнулит в $\zeta_0$ такие слагаемые (в данном случае, с чётными основаниями степеней). Если 
построить для только что полученной суммы $\zeta_1$ множество оснований $L_1$, то окажется, что 
$\min\{k\colon k\in L_1,\ k>1\}$ равно трём -- второму простому числу. Продолжая этот процесс мы 
будем на каждом шаге получать новое простое число и использовать его для обнуления/вычеркивания 
слагаемых с основаниями, кратными ему, фактически, воспроизводя просеивание Эратосфена/Эйлера 
без повторных вычеркиваний. (Кстати, нетрудно видеть, что здесь множество $L_i$ почти полностью 
соответствует множеству $L$ из разобранного ранее алгоритма решета Эйлера; разве что в $L_0$ 
есть лишняя единица...)

## Даёт ли решето Эйлера ускорение?

При работе решета Эратосфена требуется вычеркнуть числа, кратные всем простым $p\leqslant n$. 
Для каждого $p\in\mathbb{P}$, очевидно, требуется $n/p$ вычеркиваний. Т.о. для оценки количества 
требуемых операций нужно просуммировать это выражение по всем простым, не превышающим $n$, т.е. 
общее количество операций равно $\sum_{p\in\mathbb{P}_{\leqslant n}} \frac{n}{p}$. Известно, что 
$\sum_{p\in\mathbb{P}_{\leqslant n}}\frac1p = \log\log n +\mathcal{O}(1)$. Таким образом, 
временна&#x301;я асимптотическая сложность решета Эратосфена оценивается как 
$\mathcal{O}\big(n\log\log n\big)$, где $\log\log n$ выполняет роль среднего количества 
различных делителей числа $n$. (N.B., за $\mathcal{O}$-нотацией ещё прячется слагаемое 
$\mathcal{O}(n)$, т.е. время, требуемое на инициализацию решета построением множества $[2; n]$.)

Эта асимптотическая оценка становится линейной (если вычеркивание очередного числа выполняется 
за константное $\mathcal{O}(1)$ время) в случае решета Эйлера. Для языка программирования с 
дешёвым умножением это позволяет работать решету Эйлера быстрее (в теории): $\mathcal{O}(n)$ 
против $\mathcal{O}(n\log\log n)$.

Но sed, очевидно, не относится к таким языкам -- в нём вообще нет понятия умножения, хотя 
универсальность sed и позволяет реализовать умножение низкоуровневыми средствами. Причем, 
выбранный для рассматриваемой здесь реализации решета Эйлера способ умножения в унарной системе 
счисления, полностью нивелирует какие бы то ни было преимущества этого варианта решета.

Фактически, поличившийся код работает даже медленнее чем исходное решето Эратосфена или его 
наивная <<эйлерофикация>> заменой `s/1@/0@/` на `/1@/ s/1@/0@/`. :) Но раз он всё-таки был 
написан, то я включил файл `euler-sieve.sed` в основной репозиторий {% cite sieve-in-sed %}.

Решето Эйлера могло бы быть полезным в гипотетическом случае просеивания чисел, находящихся не в 
оперативной памяти, а на носителе типа flash-микросхем, имеющем ограничение на количество 
операций перезаписи содержимого. Кроме этого, можно вообразить ситуацию с просеиванием чисел в 
удалённой базе данных: в этом случае решето Эйлера позволяет минимизировать как восходящий (для 
отправки команд записи/вычеркивания), так и нисходящий (для считывания содержимого ячеек решета) 
сетевой трафик. Наконец, при теоретико-игровой интерпретации, это решето сгодилось бы при [даже 
ещё более гипотетической] игре типа <<морской бой>>, в которой состояние поля-решета 
замаскировано <<туманом войны>> и можно получать лишь прореженные сведения о последнем найденном 
простом числе. При этом нельзя попадать в <<своих>> (в простые числа) или тратить <<боеприпасы>> 
и время впустую в попытках вычеркивания уже вычеркнутых чисел.

Похоже, что у решета Эйлера в реальности два применения -- ускорение генерации простых чисел при 
использовании подходящих языков программирования типа C, и применение теоретическое (для чего, 
собственно, Эйлер и придумал это решето {% cite euler1737 %}), e.g. в задачах, требующих 
единственности каждого генерируемого решетом составного числа.

### Принцип работы `euler-sieve.sed`

Скрипт `euler-sieve.sed` получен из `sieve.sed` исправлением нескольких строчек. Набор 
вспомогательных маркеров был расширен с `#@:` до `#_@:,`. Маркет `#` как и прежде находится 
после очередного найденного простого числа. Справа от него находится маркер `_`, отмечающий 
очередной множитель, на который требуется умножить текущее простое число (N.B., если `_` стоит 
сразу после `#`, то это означает, что множителем будет само простое число, т.е. это 
соответствует вычислению $p^2$). Маркер движется вправо и устанавливается на следующее 
невычеркнутое число.

Для каждого положения маркеров `#` и `_`, префиксы, состоящие из символов, расположенных левее 
каждого из этих маркеров, копируются на две следующие за решетом строки. Из префиксов удаляются 
лишние символы (в т.ч. вышеупомянутые маркеры), а перед префиксами добавляются новые маркеры: 
маркер `:` перед первым префиксом и `,` -- перед вторым. Оба префикса, т.о., всего-лишь 
обозначают подлежащие перемножению числа [в унарной системе счисления]. Их произведение следует 
вычеркнуть из решета.

Для этого перед решетом добавляется маркер `@` (N.B., изначально *левее* маркеров `#` и `_`, что 
контрастирует с вышеописанным кодом для решета Эратосфена). Далее, в двух вложенных циклах 
начинают смещаться вправо маркеры `:` и `,`. Причем маркер `,` смещается на одну позицию когда 
маркер `:` доходит до конца его строки. После каждого смещения маркера `,` маркер `:` 
реинициализируется и вновь оказывается перед своей строкой. При каждом перемещении маркера `:` 
на одну позицию, на одну позицию вправо смещается и маркер `@`. Т.к. на пути маркера `@` лежат 
маркеры `#` и `_` (которых он гарантированно обгонит), то после окончания работы обоих циклов, 
т.е. по достижению маркером `,` конца своей строки, позиция `@` корректируется, смещаясь вправо 
на две позиции.

В конечном счета, маркер `@` оказывается сразу после составного числа, равного произведению двух 
выделенных префиксов и подлежащего вычеркиванию. Однако, если в реализации решета Эратосфена, на 
аналогичном этапе производилось, собственно, вычеркивание командой `s/1@/0@/`, то сейчас 
выбранный элемент решета лишь помечается к удалению, заменяясь не на `0`, а на `x`.

После всего этого мы можем перейти к новой итерации по перемещению маркера `_`, отмечающего 
следующий множитель для текущего простого числа (маркер `_` перепрыгивает к первому ненулевому 
символу, лежащему правее него). Если же правее маркера `_` не оказалось ни одного символа `1` 
или `x` (т.е. невычеркнутого, хотя, возможно, и помеченного числа), то все помеченные к удалению 
числа вычеркиваются окончательно командой `s/x/0/g` и мы переходим к следующей итерации смещения 
маркера `#`. Если правее от маркера `#` не оказывается простых чисел, т.е. если нет ячеек со 
значением `1`, то алгоритм просеивания завершает свою работу, передавая управление финальной 
части скрипта, производящей печать результатов.

# Комплектация поставки

* `plain-sieve.sed` -- принимает длину решета и возвращает бинарную последовательность с 
  единицами только в позициях, соответствующих простым числам (самая первая, левая позиция 
  соответствует единице и поэтому всегда равна 0).
  
  Пример: `echo 10 | ./plain-sieve.sed` вернёт `0110101000` (единицы в позициях 2, 3, 5 и 7).
  
* `sieve.sed` -- основной скрипт (кратко описанный в разделе <<Реализация>>; см. выше), 
  принимающий длину решета и возвращающий (точнее говоря, печатающий) список (с разделением 
  переводом строки) простых чисел, не превышающих данной длины.
  
  Пример: `echo 10 | ./sieve.sed` возвращает:

  ```
  2
  3
  5
  7
  ```

* `binary-sieve.sed` -- скрипт аналогичен предыдущему, но работает в двоичной системе счисления 
  (i.e. и длину решета принимает в виде бинарного числа и простые числа печатает тоже в 
  двоичной записи; это немного упрощает код чтения и печати чисел) .
  
  Пример:
  ```
  echo 1010 | ./binary-sieve.sed

  10
  11
  101
  111
  ```
  
  Действительно, $1010_2=10$, $10_2=2$, $11_2=3$, $101_2=5$ и $111_2=7$.

* `anagram.sed` и `collatz.sed` были описаны в предыдущем разделе этого сообщения. Скрипт 
  `anagram.sed` сейчас поддерживает только латинские символы, а `collatz.sed` печатает только 
  <<ключевые>> точки траектории $3x+1$, т.е. строит последовательность итерируя отображение 
  $x\mapsto 3x/2^{k(x)}+1$, где $k(x)$ есть [максимальная] степень множителя 2 в факторизации 
  числа $x$. E.g. для начального числа $10=1010_2$ будет построена последовательность $1010_2\to 
  10000_2\to 1$, i.e. 10 будет поделено на 2, затем этот результат без печати на экране будет 
  утроен и инкрементирован, что даст 16 ($10000_2$), а это последнее число будет напечатано и 
  сразу же [целочисленно] разделено на максимально возможную здесь степень двойки, $2^4$, что 
  даст последнюю точку траектории, 1.

* `anagrams.txt` -- примеры анаграмм для тестирования `anagram.sed`.

* `factor.sed` -- производит разложение данного числа на простые множители (работа скрипта уже
  была описана в резделе <<Реализация>>).
  
  Пример:
  ```
  echo 18 | ./factor.sed

  2
  3
  3
  ```

  Как и ожидалось, $18=2\cdot 3\cdot 3$.

* `factor-hack-unary.sed` -- простой скрипт, вместо решета использующий <<обратные ссылки>> в
  регулярном выражении (следуя {% cite factor-hack another-factor-hack nongreedy-factor %}) для 
  факторизации числа, представленного в унарной системе счисления.
  
  Примечание: здесь используются расширенные <<регулярные>> выражения, поддерживающие ссылки 
  вида `\1`, `\2`, etc., и не являющиеся именно регулярными в привычном смысле -- такие 
  выражения с обратными ссылками не удастся скомпилировать в конечный автомат.
  
  Скрипт на самом деле имеет дело со списком чисел (разделенных переводом строки), подлежащих 
  разложению. Но разложению подвергается только одно из них, помеченное специальным маркером.
  
  Для числа $n$ используется регулярное выражение, аналогичное выражению {% raw 
  %}`/^(11+)(\1+)$/`{% endraw %}. Как видно, оно выделяет некую группу из не менее чем двух 
  единиц при помощи подвыражения `(11+)`, т.е. выделяет один множитель $a$ (возможно составной), 
  и с помощью подвыражения `(\1+)` проверяет, можно ли представить оставшуюся часть числа 
  конкатенацией некоторого ненулевого количества копий этой группы (без остатка).

  Если это не удалось сделать, то $n$ либо равно единице, либо является простым. В противном 
  случае скрипт производит деление числа на найденный множитель: $b=n/a$. Для этого, в цикле, 
  найденная ранее группа единиц, находящаяся в самом начале числа, заменяется на подходящий 
  маркер (в данном случае используется символ `_`). Т.о., по завершению цикла, количество 
  символов подчеркивания равно $b$ и заменой `s/_/1/g` можно получить этот второй, возможно тоже 
  составной множитель. Множитель $b$ добавляется в список чисел.
  
  Теперь скрипт рекурсивно обрабатывает найденный множитель $a$ (пометив его специальным 
  маркером и начав факторизацию заново) по уже описанной схеме и продолжает процесс, перемащая 
  маркер к следующему числу в списке при каждой <<неудачной>> факторизации (т.е. когда 
  помеченный множитель оказывается простым или равным единице), пока всё исходное число не 
  окажется разложенным на простые множители.
  
  В других диалектах регулярных выражений могут поддерживаться те или иные средства управления 
  жадностью -- так в источнике {% cite nongreedy-factor %} вместо `11+` применено подвыражение 
  `11+?`, которое как раз и указывает механизму сопоставления с образцом действовать нежадно, 
  минимизируя длину найденной подстроки; но в sed таких средств, кажется, нет, а в данном 
  конкретном случае, за счёт рекурсивной обработки всё вновь получаемых множителей, 
  неопределенной жадности вполне достаточно.
  
  Интересно, что если для сопоставления с образцом `11+` используется гарантированно жадная 
  стратегия, то, коль скоро это соответствует максимизации $a$ в разложении $n=a\cdot b$, это 
  минимизирует $b$ и обеспечивает т.о. его простоту. Данное наблюдение могло бы позволить слегка 
  сократить и ускорить скрипт, но я не воспользовался такой возможностью (потому что всё и так 
  работает, да ещё и не зависит от стратегии поиска, выбранной конкретной реализацией регулярных 
  выражений).
  
  Пример работы скрипта:
  ```
  echo 111111111111111111 | ./factor-hack-unary.sed

  111
  111
  11
  ```
  
  Так и должно быть: $18=3\cdot 3\cdot 2$.

* `euler-sieve.sed` -- попытка реализации решета Эйлера. Детальное описание приведено в
  предыдущем разделе. С точки зрения запуска и использования, скрипт должен работать в точности 
  как и `sieve.sed` (см. выше).

# Ссылки

{% bibliography --cited_in_order --file sieve-of-eratosthenes-in-sed %}
