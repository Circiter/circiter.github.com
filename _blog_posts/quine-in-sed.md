---
layout: post
title: "Занимательное квайноводство. Часть I."
test: true
sig: true
abstract: "В этом сообщении (в первой части серии сообщений), после краткого введения в 
некоторые основы теории вычислимости, в основном описываются результаты простого эксперимента по 
автоматизированному конструированию квайна с использованием второй рекурсивной теоремы Клини. В 
качестве целевого языка выбран язык поточного редактора [GNU] sed. Изложение, однако, не 
специфично для этого языка и может трактоваться в более широком контексте. Фактически, в 
предлагаемом цикле сообщений излагаются некоторые подходы к систематическому конструированию 
квайнов."
xdate: "июль, 2020"
---
tags: "неподвижные точки" sed эзотерика программирование квайноводство "теория вычислимости" математика философия саморепликация

План:

s^m_n-теорема, частичная специализация, карринг/каррирование
Вторая [рекурсивная] теорема Клини 
Теорема Роджера
Квайны и сложность/универсальность; бесконечные циклы
Диагонализация (диагональный процесс Кантора, проблема остановки)
Квайны и комбинатор(ы) неподвижной точки 
Проекции Футамуры[-Турчина/Ершова]
Первая [рекурсивная] теорема Клини
Kimian-quines (Kimian Self Reproduction, Kimian Self-Rep)
Lawvere's fixed point theorem (Уильям Ловер)
Конструирование квайнов с помощью логического программирования в ограничениях
Генератор квайнов, <<квайнтификатор>>
Квайны и "Эшер, Гёдель, Бах"
Интроны
Вирусология
теорема Гёделя
Экзобиология, креационизм, абиогенез 
Эволюционные алгоритмы и квайны
Квайны и [самомодифицирующийся] искусственный интеллект; шутка про церковь неподвижной точки
Автоматы фон Неймана
Квайны и закон/юриспруденция (в контексте вирусологии и экологии/этики саморепликаторов)

---------

# Введение в квайнологию

Всем известно <<стандартное>> упражнение в программировании, заключающееся в написании 
программы, печатающей свой собственный текст. За такими самореплицирующимися программами 
достаточно давно закрепилось название <<квайн>> (также распространен вариант написания 
<<куайн>>) введенное в известной книге Хофштадтера [26] в честь философа Куайна (Уиллард Ван 
Орман Куайн = Willard Van Orman Quine).

Сами квайны при этом появились раньше. Может быть их историю следовало бы вести с докомпьютерной 
эры, а именно с работ фон Неймана по самореплицирующимся [клеточным] автоматам или даже с работ 
Хаскеля Карри...

Квайны могут показаться парадоксальными программами, в соответствии с бытовой интуицией не 
могущими существовать, -- ведь может показаться, что программа не может вывести текст, имеющий 
длину, равную длине самой программы (должно остаться место для кода, выполняющего печать). И тем 
не менее они существуют (и не требуют сжатия данных, которое, в соответствии с фундаментальной 
теоремой компрессии, не всегда возможно).

Более того, теория вычислимости говорит, что квайны можно написать на *любом* [достаточно 
выразительном] языке программирования. На деле, конечно, сложность написания и размер 
результирующего кода сильно варьируются от языка к языку. Если некоторые возможности языков 
программирования позволяют и вовсе написать ненастоящий, тривиальный квайн (e.g. квайн в виде 
пустой строки, или квайн, читающий свой текст из файла или с помощью специализированных 
рефлексивных возможностей некоторого языка программирования), то другие возможности позволяют 
значительно упростить написание даже истинных квайнов. Естественно, в выбранном языке или в 
некотором его подмножестве может и не оказаться подобных средств (но, ещё раз подчеркну, это 
лишь усложнит написание квина, но не сделает его невозможным).

В качестве примеров квайнов можно привести такие поделки (авторы мне не известны):

Квайн на lisp:
```lisp
((lambda (x)
  (list x (list (quote quote) x)))
(quote
  (lambda (x)
    (list x (list (quote quote) x)))))
```

Квайн на стековом rpn-языке форт (forth):
```forth
s" 2dup 115 emit 34 emit 32 emit type 34 emit type cr bye"2dup 115 emit 34 emit 32 emit type 34 emit type cr bye
```

Квайн на экспериментальном функциональном стековом rpn-языке joy [32]:
```
"dup.putchars.10 putch."
dup.putchars.10 putch.
```

Квайн для $\lambda$-исчисления: $(\lambda x. x x) (\lambda x. x x)$ (почти то же, что и выше 
на lisp).

В стандартной библиотеке языка C есть функция форматированного вывода `printf`, которая может 
быть использована [в качестве суррогата $S^m_n$-функции] для внедрения текста программы в него 
самого; что-то вроде `printf(f, f)`, только с учетом технических сложностей с вложенными 
кавычками для обрамления строк. По этому принципу построен такой известный однострочный 
миниквайн на C (здесь не указан заголовочный файл `stdio.h`, в котором определена `printf`, но в 
таком виде этот код всё-равно компилируется и работает):

```C
char*f="char*f=%c%s%c;main(){printf(f,34,f,34,10);}%c";main(){printf(f,34,f,34,10);}
```

## Искусство *versus* ремесло

Основной причиной проведения небольшого эксперимента, ставшего основой настоящего сообщения, 
явилось желание написать, или, точнее говоря, попробовать написать квайн на входном языке 
поточного редактора sed. Применение поисковых систем для поиска уже имеющихся решений привело к 
обнаружению квайна `quine.sed` [17] из <<музея квайнов>> [18] (автор: Tsuyusato Kitsune):

{% raw %}
```
s/^/s11^113311;h;s221[1]221122g;s112[2]11222211g;G;s11^22([^3]*22)3322([^22n]*22).22(.*22)$1122122322211/;h;s\1[1]\/\g;s/2[2]/\\/g;G;s/^\([^3]*\)33\([^\n]*\).\(.*\)$/\1\3\2/
```
{% endraw %}

Вряд ли у меня вышло бы улучшить (например, сократить) этот квайн. Более того, самостоятельная 
попытка написать нечто подобное тоже не увенчалась успехом. Поэтому было принято решение 
действовать более систематичным образом и воспользоваться уже имеющимся в распоряжении 
математики арсеналом готовых теоретических средств.

Вторая рекурсивная теорема Клини имеет своим следствием утверждение о существовании квайна для 
любого языка программирования, а конструктивный характер её доказательства дает готовый рецепт 
для написания такого <<саморепликатора>> (ниже об этом будет написано подробнее).

Стандартные пособия по теории вычислимости нередко не ограничиваются лишь утверждениями о 
существовании квайнов, и даже приводят конкретные примеры их конструирования, правда, выбирая 
при этом, как правило, <<удобные>> языки программирования, например, прагматические реализации 
$\lambda$-исчисления, такие как lisp и его производные.

Попадались интересные исключения, e.g. [35, 36], но для слишком абстрактных машин. Поэтому я 
решил повторить классический эксперимент с конструированием квайна на основе доказательства 
рекурсивной теоремы Клини, но выполнить этот эксперимент на языке sed (кстати, всё-равно 
оказавшимся достаточно удобным для этой задачи, в основном из-за возможности объединения 
скриптов их конкатенацией).

Результаты эксперимента говорят о возможности автоматической, или <<нетворческой>> генерации 
квайнов, в том числе и на sed.

## Эффективность и выбор названия серии сообщений.

Быть может некоторым показалось бы несколько более благозвучным слово вроде <<квайноделия>>, но 
<<квайноводство>> подходит куда лучше... От части потому, что, как и обещают стандартные вводные 
курсы по теории вычислимости, квайны, конструируемые прямым применением [второй рекурсивной] 
теоремы Клини, обычно получаются, мягко говоря, <<неэффективными>> (как по времени, так и по 
пространству).

## Постановка задачи

Пусть квайн хранится в исполняемом файле `quine`, полученным компиляцией его исходного текста из 
файла `quine.source`. Для меня достаточно чисто формального выполнения следующего теста:

```sh
./quine any_argument > quine.output
diff quine.source quine.output
```

или аналогичного теста для интерпретируемого языка (здесь `interpreter` -- исполняемые файл 
интерпретатора или аналогичная внутренняя комманда оболочки):

```sh
interpreter quine.source any_argument > quine.output
diff quine.source quine.output
```

Для sed это соответствует следующему тесту:

```sh
echo any_argument | sed -f quine.sed > quine.output
diff quine.sed quine.output
```

Проверку на тривиальность (в частности, на пустоту) можно выполнять и <<вручную>> (из-за 
плохой формализуемости и некоторой субъективности).

То есть, квайн конечного размера (скажем, помещающийся на жесткий диск) должен напечать свой 
собственный текст за конечное (и разумное время). Абсолютно не важно, будут ли исходный текст и 
скомпилированная программа весить несколько килобайт или несколько мегабайт. Гораздо важнее, 
чтобы квайн был истинным, т.е. был непустым, <<содержательным>>, и не использовал <<нечестные>> 
рефлексивные возможности (вроде чтения своего исходного текста из файла).

# Вводные замечания

В теории вычислимости особо важное место занимают несколько интересных теорем о вычислимых 
функциях. В этом сообщении я хотел бы кратко рассказать об этих теоремах и о некоторых их 
применениях.

Для некоторой программы с текстом $p$ соответствующую ей (частичную) вычислимую функцию обычно обозначают как 
$\varphi_p$, однако, воизбежание нагромождения нижних индексов далее будет использоваться 
несколько более удобное обозначение, широко применяющееся при изучении семантики языков 
программирования, а именно $\llbracket p\rrbracket$.

Обычно, в теории рекурсивных функций говорят о [гёделевском] номере программы, а не о её тексте, 
но далее будет использоваться более наглядное и привычное, по крайней мере для программистов, 
слово *текст*, иногда даже *исходный код*, без прямого отсыла к понятиям *кодировка* и 
*нумерация* из теории вычислимости. Более того, вразрез с традиционным словоупотреблением, в 
настоящем сообщении нередко программа и её текст будут отождествляться, -- здесь это просто одно 
и то же. (Краткости и простоты ради, это сообщение будет вообще несколько неформальным и не 
строгим.)

При одновременном рассмотрении нескольких языков программирования, как, например, при 
работе с трансляторами, можно указывать язык программирования в нижнем индексе 
семантических скобок, e.g., $\llbracket\cdot\rrbracket_\varphi$. (Кстати, в литературе 
встречается и более необычная нотация, например, вообще не используюшая какие-либо индексы и 
скобки, для экономии места.)

Символом $\bot$ будет обозначено незавершающееся вычисление, т.е. $\bot$ -- это значение 
бесконечного цикла. Равенство $\llbracket a\rrbracket=\llbracket b\rrbracket$ есть сокращение 
для $\forall x\ \llbracket a\rrbracket(x) = \llbracket b\rrbracket(x)$. (Подразумевается, что 
для некоторых $x$, может выполнятся $\llbracket a\rrbracket(x)=\bot$ и $\llbracket 
b\rrbracket(x)=\bot$.)

(При работы с функциями многих аргументов предполагается, что кортеж аргументов выражается через 
композицию вычислимых функций объединения аргументов в пары. Например, $f(x, y, z)$ можно 
воспринимать как применение $f$ к функции $(\cdot,\cdot)$, которая создает пару из $x$ и 
результата, возвращаемого функцией $(\cdot, \cdot)$, примененной к $y$ и $z$. Создание кортежей 
-- обратимая операция.)

## Теорема об универсальной функции

Сначала хотелось бы упомянуть теорему о существовании универсальной программы, а фактически о 
возможности написания интерпретаторов для любых подходящих (Тьюринг-полных) языков 
программирования, причем подразумевается, что интерпретатор пишется на его же входном языке. 
Более формально, эта теорема утверждает, что существуют вычислимая функция $u$, а также 
соответствующая ей программа-интерпретатор $I$, такие, что для любой программы $p$, 
интерпретатор может быть запущен с несколькми аргументами, первый из которых равен $p$, а 
оставшиеся суть просто аргументы для этой программы. Так запущенный интерпретатор должен 
возвратить тот же результат, что и сама программа $p$ при тех же аргументах.

То есть, $\exists I\colon\forall p\llbracket I\rrbracket(p, x)=\llbracket p\rrbracket(x)$. 
Доказательство здесь приводиться не будет (оно может проводится просто предъявлением готового 
интерпретатора для машины Тьюринга, т.е. путем построение т.н. универсальной машины Тьюринга; 
N.B., сама теорема не зависит от языка программирования и требует лишь его полноты по-Тьюрингу).

(Использование теоремы об универсальной функции в данном сообщении будет весьма ограниченным; 
здесь без неё можно было бы и обойтись.)

## S-m-n теорема Клини

Другой, не менее важной теоремой является т.н. $S^m_n$ теорема [14], утверждающая, что может 
быть написана программа, уменьшающая количество аргументов путем фиксации значений некоторых из 
них: для любой программы (Тьюринг-машины) для функции $f$ с $m+n$ аргументами и для заданных 
значений $a_1,\ldots,a_m$ для первых $m$ аргументов существует программа $g'$ для 
специализированной функции $g$, удовлетворяющая $\llbracket g'\rrbracket(b_1,\ldots,b_n) = 
f(a_1,\ldots,a_m, b_1,\ldots,b_n)$ для любых $b_i$.

Также существует вычислимая функция, --- собственно, 
$S^m_n$-функция, --- преобразующая программу для $f$ в программу для $g$.

То есть, для программы $p$, соответствующей функции $f$, выполняется $\llbracket S^m_n(p, 
a_1,\ldots,a_m)\rrbracket(b_1,\ldots,b_n) = \llbracket p\rrbracket(a_1,\ldots,a_m, 
b_1,\ldots,b_n)$.

Далее пригодится частный случай $S^1_1$ с фиксацией всего одного из двух аргументов.

Нетрудно видеть, что $S^m_n$ теорема, по-существу, реализует частичные вычисления (специализацию 
программ), т.е. дает возможность выполнить часть вычислений, зависящих от фиксируемого 
аргумента(-ов), заранее, до выполнения программы (что может быть использовано, например, для 
оптимизации кода). Есть некоторое сходство между частичной специализацией и *каррингом* из 
функционального программирования.

Доказательство $S^m_n$ теоремы конструктивно и может быть основано на явном выписывании 
программы (e.g. для машины Тьюринга), присваивающей определенные значения исключаемым аргументам 
и обеспечивающей запуск программы при поступлении недостающих данных (такого тривиального 
алгоритма недостаточно для написания оптимизирующего специализатора; но он может быть улучшен).

(Как и для предыдущей теоремы, само доказательство здесь приводится не будет, а интересующимся 
рекомендуется обратиться к первоисточникам или более современным материалам по теории 
вычислимости.)

Стоит отметить, что вышеприведенные теоремы во многом схожи, и даже в некотором смысле 
<<взаимо-обратны>> -- теорема об универсальной функции преобразует <<статический>> параметр --- 
программу --- в <<динамический>> аргумент, который может затем принимать любое значение; 
$S^m_n$-теорема, напротив, преобразует динамический аргумент в статический, приписывая ему 
априори заданное значение.

Эта симметрия хорошо видна если выписать ключевые уравнения обоих теорем одно под другим 
(здесь, для краткости, используется $S^1_1$-функция):
{% tex block %}
\begin{align*}
\llbracket I\rrbracket(p, x, y) &= \llbracket p\rrbracket(x, y)\\
\llbracket S^1_1(p, x)\rrbracket(y) &= \llbracket p\rrbracket(x, y).
\end{align*}
{% endtex %}

В некотором смысле, они при этом всё-же различны -- кроме структурных различий формул, $S^m_n$ 
теорема не требует Тьюринг-полноты используемого языка.

# Неподвижные точки вычислимых функций

Далее описывается теорема о существовании неподвижных точек частично-рекурсивных функций, 
известная также как вторая рекурсивная теорема Клини [14]; здесь приводится несколько упрощенная 
её версия, впрочем, полностью достаточная для решения поставленных задач.

Теорема1.

Для любой частично-рекурсивной функции $f(\cdot, \cdot)$ существует программа $p$ (<<неподвижная 
точка>>), такая, что $$\forall z \ \llbracket p\rrbracket(z)=f(p, z).\eqno (1)$$

Доказательство.

Напишем программу $e$, такую, что $\llbracket e\rrbracket(x, y)=f(S^1_1(x, x), y)$. Тогда 
$p=S^1_1(e, e)$.

Действительно, если запустим $p$ для какого-нибудь аргумента $z$, то получим $\llbracket 
p\rrbracket(z)=\llbracket S^1_1(e, e)\rrbracket(z)$. По определению $S^1_1$-функции, $\llbracket 
S^1_1(e, e)\rrbracket(z)=\llbracket e\rrbracket(e, z)$. Теперь применим определение для $e$ и 
получим, что $\llbracket e\rrbracket(e, z)=f(S^1_1(e, e), z)=f(p, z)$. Понятно, что эта цепочка 
уравнений по транзитивности приводит к $\llbracket p\rrbracket(z)=f(p, z)$. $\blacksquare$

В данном сообщении особый интерес представляет частный случай $f(x, y)=x$, порождающий квайны: 
легко видеть, что при этом $\llbracket p\rrbracket(z)=f(p, z)=p$, то есть программа $p$ при 
запуске печатает сама себя, как и положено квайну.

Иногда пригождается другая версия этой теоремы (при определенном выборе языка, строго 
говоря, не эквивалентная теореме Клини; см. [39]), предложенная в [19]:

Теорема 2 (теорема Роджерса).

Для любой рекурсивной вычислимой функции $f(\cdot)$ существует неподвижная точка $p$, т.е. такая 
программа $p$, что $\forall z \llbracket p\rrbracket(z)=\llbracket f(p)\rrbracket(z)$.

Доказательство.

Определим функцию $h(e)$ так, что $$\llbracket h(e)\rrbracket=\big\llbracket\llbracket 
e\rrbracket(e)\big\rrbracket.\eqno (2)$$ Теперь напишем программу $e$, такую, что $\forall z$ 
выполняется $$\llbracket e\rrbracket(z)=f\big(h(z)\big).\eqno (3)$$ Утверждается, что 
$p=h(e)$ -- есть искомая неподвижная точка.

Подстановка (3) в правую часть (2) дает $\big\llbracket\llbracket e\rrbracket(e) 
\big\rrbracket=\llbracket f\big(h(e)\big) \rrbracket$ и $\llbracket 
h(e)\rrbracket=\llbracket f\big(h(e)\big)\rrbracket$. Последнее уравнение при обозначении 
$p=h(e)$ уже соответствует определению неподвижной точки из условия этой теоремы, т.е., 
$\llbracket p\rrbracket=\llbracket f(p)\rrbracket$. $\blacksquare$

Из теоремы Клини и теоремы об универсальной функции следует теорема Роджерса, а из теоремы 
Роджерса и $s^m_n$-теоремы -- теорема Клини. (Но есть нюансы [39].)

Для применения теоремы Роджерса к случаю с квайнами, удобно, следуя [2], ввести оператор 
$\operatorname{quote}$, для данного аргумента конструирующий программу, печатающую этот 
аргумент. Т.е. определение оператора $\operatorname{quote}$ выглядит как 
$\llbracket\operatorname{quote} z\rrbracket=z$ [и соответствует одноименному оператору из, e.g., 
lisp'а].

Квайны суть неподвижные точки этого оператора [в смысле формулировки теоремы Роджерса].

Доказательство.

Пусть $q$ -- неподвижная точка $\operatorname{quote}$, т.е. $\forall z$ 
выполняется $\llbracket\operatorname{quote} q\rrbracket(z) = \llbracket q\rrbracket(z)$. 
Подстановка определения $\operatorname{quote}$ в это уравнение дает 
$\llbracket\operatorname{quote} q\rrbracket(z)=q=\llbracket q\rrbracket(z)$. Но $q=\llbracket 
q\rrbracket(z)$ и есть определение квайна. $\blacksquare$

Примечание.

Вообще, в математике, неподвижной точкой функции $f(\cdot)$ обычно называют значение 
$x$, такое, что $f(x)=x$ (i.e., $f$ оставляет $x$ неизменным). Поэтому <<неподвижные точки>> из 
теорем 1 и 2 не совсем соответствуют такому общепринятому определению.

Тем не менее, термин *неподвижная точка* хорошо отражает суть этих теорем (некоторое 
преобразование не меняет значение аргумента, т.е. оставляет его неподвижным); я лишь 
намереваюсь, в рамках этой серии сообщений, для удобства ввести обозначения для этих 
<<нестандартных>> неподвижных точек, а именно, пусть операторы $\operatorname{kfix} f$ и 
$\operatorname{rfix} f$ обозначают неподвижные точки [функции $f$] из теорем Клини и Роджерса, 
соответственно.

# Главный эксперимент

В [42] приведен следующий эксперимент по квайногенерации на lisp (автор кода мне не известен):
```lisp
(define g (quote (lambda (x y) x))) ; g(x, y) = x

(define s11 (quote (lambda (f x) (list (quote lambda)
    (quote (y)) (list f x (quote y)))))) ; from s-m-n theorem

(define m (list (quote lambda) (quote (x y))
    (list g (list s11 (quote x) (quote x)) (quote y))))

(define quine (eval (list s11 m m)))

; tests
(eval (list quine nil))
(eval (list g quine nil))
```

(В [47] можно найти невероятную коллекцию аналогичных экспериментов со второй рекурсивный 
теоремой Клини, выполненных на языке scheme, диалекте lisp'а.)

Этот фрагмент кода просто воспроизводит доказательство второй рекурсивной теоремы Клини. 
Аналогичным образом я действовал и при повторении этого эксперимента на sed. Соответствующий код 
может быть найден в GitHub-репозитории [46]. Конкретно, в репозитории содержится ряд скриптов, 
`*.sed` и `*.sh`, назначение каждого из которых рассмотренно ниже.

Редактор sed направляет данные со стандартного ввода в основной буфер редактирования (т.н. *the 
pattern space*). И т.к. мне не известен способ передачи традиционных аргументов коммандной 
строки скрипту для этого редактора, то именно чтение со стандартного ввода было применено в 
качестве единственного механизма передачи аргументов. При этом, из-за необходимости передачи 
нескольких аргументов, понадобилось либо ввести разделитель/терминатор (e.g. нулевой байт), либо 
приписывать значение длины перед каждым аргументом. Как ни странно, изначально был выбран второй 
метод, в основном из-за отсутствия необходимости в экранировании разделителя.

Итак, далее приведен перечень скриптов с их кратким описанием:

- `construct-input.sh` принимает на вход список файлов со значениями аргументов и формирует 
   пакет аргументов из них, т.е. читает эти значения и посылает на стандартный вывод, снабдив 
   заголовками (длинами). Формат пакета данных с аргументами выглядит так:

   ```
   <длина аргумента 1>...<длина аргумента n><аргумент 1>...<аргумент n>
   ```

   Длина каждого аргумента представлена двоичным шестнадцатиразрядным числом (т.е. этот формат 
   не отличается универсальностью, но этого хватает для практического применения).

- Скрипт `s11.sed` [тривиально] реализует $s^1_1$-функцию. Этот сценарий принимает исходную 
   программу $p$ в первом аргументе и фиксируемый аргумент $x$ для неё -- во втором своем 
   аргументе. Результатом работы скрипта будет другая программа, полученная путем приписывания к 
   $p$ небольшого <<инъектора>> -- фрагмента кода, встраивающего ранее принятый аргумент $x$ (и 
   теперь являющийся частью инъектора) перед новым аргументом $y$ (который будет передан 
   формируемой программе при её запуске). После модификации пакета аргументов, инъектор передаёт 
   управление программе $p$ так, что она <<видит>> пару аргументов $x$ и $y$, несмотря на то, 
   что при запуске ей был передан единственный аргумент $y$.

   Небольшая техническая сложность заключается в необходимости экранирования специальных 
   символов в аргументе $x$ при формировании инъектора (с $x$, встроенным в него). Экранирование 
   производится в соответствии с синтаксисом регулярных выражений sed, путем добавления 
   символа`\` перед некоторыми символами, вроде того же `\` или перевода строки `\n`.

- `minifier.sed` используется для удаления ненужных символов (пустые строки, комментарии). При 
   генерации квайна этот скрипт применяется для *опционального* <<сжатия>> скриптов `s11.sed` и 
   `duplicate-first.sed`, что впоследствии уменьшает размер и увеличивает скорость работы 
   результирующего квайна.

- `is-quine.sh` -- простой shell-скрипт, проверяющий переданный ему в аргументах sed-скрипт и 
   определяющий, является ли он квайном.

- `generate.sh` производит <<минификацию>> скриптов `s11.sed` и `duplicate-first.sed`, после 
   чего запускает `generate-q.sh`, а после его завершения проверяет готовый продукт --- квайн в 
   файле `q.sed` --- с помощью скрипта `is-quine.sh`

- `duplicate-first.sed` принимает два аргумента $x$ и $y$ и заменяет второй первым, т.е., 
   игнорирует $y$ и формирует пакет из двух одинаковых аргументов $x$ и $x$.

- `generate-e.sh` конструирует программу $e$ из доказательства теоремы Клини. Для этого 
   [минифицированный, сжатый] код программы `duplicate-first.sed` добавляется в начало [тоже 
   сжатого] `s11.sed` и объединённый код сохраняется в `e.sed`. При запуске $e$, как и 
   требуется, будет выполняться $\llbracket e\rrbracket(m, x) = s^1_1(m, m)$, т.е. сначала 
   второй аргумент будет заменен первым (с помощью кода из `duplicate-first.sed`), затем 
   управление будет передано коду $s^1_1$-функции из `s11.sed`.

- `generate-q.sh` сначала запускает `generate-e.sh` для создания `e.sed`, потом запускает 
   `s11.sed` (или его сжатую версию, хотя здесь это не имеет значения) передав ему в качестве 
   обоих его аргументов содержимое только что сгенерированного `e.sed`. (N.B., `generate-e.sh` 
   использовал содержимое `s11.sed` для генерации `e.sed` на его основе; в данном же случае, 
   скрипту `generate-q.sh` не требуется доступ к тексту `s11.sed`, но лишь возможность его 
   выполнения; по той же причине здесь не используется `duplicate-first.sed`)

- `first-only.sed` из двух переданных ему аргументов возвращает только первый. (Напоминает 
   определение одного из логических значений в кодировке Черча). В дистрибутив/репозиторий 
   включен просто для демонстрации, хотя, в соответствии с доказательством теоремы Клини, 
   является реализацией функции $f(x, y)=x$, позже использовавшейся для доказательства 
   существования квайна.

- `concat.sed` возвращет объединённые значения обоих аргументов; никакие заголовки в результат 
   не включаются. На деле, `concat.sed` включен в репозиторий только для демонстрации -- скрипт 
   `generate-e.sh` не использует `concat.sed`, а производит объединение текстов просто 
   последовательным копированием оных в целевой файл.

(Заметьте, последние два скрипта, `first-only.sed` и `concat.sed` концептуально не являются 
лишними и они могли бы быть использованы, но по-факту, в ходе оптимизации, были заменены 
аналогичными средствами коммандной оболочки, -- для эффективности.)

Для генерации квайна достаточно запустить `./generate.sh`, в результате чего в том же каталоге 
[через некоторое время] должен появиться файл `q.sed`, являющийся искомым квайном на sed.

# Промежуточные итоги

Описание основного эксперимента завершено (и я рекомендую немного поизучать код скриптов из 
репозитория). Но о квайнах рассказать можно ещё многое. А некоторые вопросы остаются 
вовсе малоизученными, фактически, открытыми.

Несмотря на приведенные доказательста теорем о неподвижных точках (Клини и Роджерса), кому-то, 
может быть, хотелось бы глубже понять структуру этих и подобных им доказательств. Поэтому ниже я 
приведу некоторые дополнительные сведения с примерами. К концу сообщения я попробуя немного 
задеть некоторые из филосовских аспектов квайнов и теории вычислимости. И, пожалуй, завершу 
изложение попыткой сформулировать интересующие меня, но пока не имеющие официального ответа 
открытые вопросы.

Надеюсь, это не последнее сообщение этой серии. Поэтому, темы, не затронутые здесь, будут, по 
возможности, обсуждаться позже в других частях.

# Дополнительная теория

## Проблема остановки

Проблемой останова(-ки) называют задачу определения завершаемости произвольной программы по её 
коду. Известна теорема об алгоритмической неразрешимости такой задачи, т.е. о невозможности 
построения алгоритма, устанавливающего для произвольной программы конечность времени её 
выполнения.

В пользу этого утверждения можно привести такие доводы. Определим функцию $h(n, x)$ которая в 
качестве своих аргументов принимает код некоторой программы $n$ и входные данные $x$ этой 
программы, после чего возвращает 1 если эта программа завершается за конечное время, и 0 -- если 
программа <<зависает>>.

Пусть $f(x, y)$ -- любая вычислимая (реализуемая в виде компьютерной программы) функция двух 
аргументов, способная обрабатывать тексты программ. Определим ещё одну функцию g(x) следующим 
образом: $$g(x)=\begin{cases}0, & f(x, x)=0\\\bot.\end{cases}$$.

Т.е. $g$ передаёт свой аргумент функции $f$ и если та возвращает ноль, то ноль возвращает и $g$, 
но в противном случае $g$ возвращает неопределенное значение, а именно зависает, входя в 
бесконечный цикл. Важно, что для вычисления $g$ можно написать программу, e.g. такую (C-образный 
псевдокод):
```C
int g(x) {if(f(x, x)==0) return 0; else while(1);}
```

Так как $f$ тоже реализуема в виде программы, то в приведенном коде для $g$, получение значения 
$f(x, x)$ можно считать обычным вызовом подпрограммы. Все остальные действия (проверка на 
равенство нулю, возврат результата, условный переход, бесконечный цикл) тоже выполнимы на любом 
комппьютере.

Теперь мы можем передать функции $g$ её собственный текст; тогда, если $f(g, g)=0$, то и 
$g(g)=0$. Другими словами, в этом случае $g$ возвращает результат и завершается, т.е. $h(g, 
g)=1$. Если же $f(g, g)=1$, то $g(g)$ зависает и таким образом $h(g, g)=0$.

В любом случае, из этого получается, что $f(g, g)\neq h(g, g)$. Таким образом, функция $h$ не 
совпадает с вычислимой $f$. А из произвольности выбора функции $f$ немедленно вытекает, что 
функция $g$ не совпадает вообще ни с одной вычислимой функцией, т.е. $h$ невычислима (в смысле 
несуществования программы, вычисляющей значение этой функции для любых входных данных).

## Диагонализация

Эта схема доказательства фактически основана на процедуре диагонализации. Если у нас есть 
некоторая бесконечная матрица $a_{xy}$, то мы можем построить вектор $b$ не совпадающий ни с 
одной из строк матрицы. Для этого достаточно лишь каким-то образом преобразовать элементы 
диагонали (отсюда название метода) матрицы $a$ так, чтобы для любого $z$ выполнялось $b_z\neq 
a_{zz}$ (например, $b_z=1+a_{zz}$).

Действительно, предположим, что $b$ равен одной из строк матрицы $a$. Это означает, что 
существует такой индекс $z$, что $b_i=a_{zi}$ для любого $i$. Однако, по-построению $b$, при 
$i=z$ имеет место неравенство $b_z\neq a_{zz}$; противоречие.

## Теорема Кантора

Изначально, диагональный метод был разработан и применен Кантором для доказательства 
существования множеств, больших любого счетного бесконечного множества, или, точнее говоря, для 
доказательства несуществования сюръекции $\mathbb{N}\to\wp(\mathbb{N})$, где $\wp(\mathbb{N})$ 
-- булеан множества $\mathbb{N}$. В более общем виде, теорема кантора говорит о несуществовании 
сюръекции $X\to Y^X$, где $X$, $Y$ -- некоторые множества (причем $Y$ должно быть невырожденным, 
например, в смысле существования беспорядка $Y\to Y$, т.е., перестановки без неподвижных точек), 
а $Y^X$ -- множество всех функций $X\to Y$ (структурно, обозначение $Y^X$ соответствует формуле 
$|Y|^|X|$ для подсчета количества таких функций).

Применительно же к проблеме останова, в качестве бесконечной матрицы используются значения $f(x, 
y)$, т.е. строки соответствуют функциям. Причем диагональные значения оборачиваются в функцию 
$g$ так, чтобы функция останова $h$ возвращала результаты, всегда неравные этим значениям. Это и 
позволяет достичь противоречия (c.f. <<парадокс лжеца>>).

## Теорема Ловера

Уильям Ловер предложил [43] обобщенную теорему из которой следуют многие другие результаты 
диагонализации, включая и проблему останова и теорему Гёделя о неполноте и некоторые другие. См. 
[44] для изложения тех же результатов на языке теории множеств (работа [43] сформулирована с 
существенным привлечением теории категорий).

# Немного о пределах познаваемости

Проблема останова разрешима для многих систем, например, для конечных автоматов, 
коими, кстати говоря, и являются реальные компьютеры. Правда, в силу огромного количества 
состояний таких автоматов, они, с практической точки зрения, хорошо моделируются машиной 
Тьюринга (или эквивалентными моделями, типа лямбда-исчисления). Поэтому, многие теоретические 
результаты, вытекающие из проблемы останова или доказываемые редукцией к ней, по прежнему 
применимы в обычном программировании.

Также проблема останова может быть вполне разрешимой для определенных частных случаев. Например, 
в теории, антивирусы невозможны (это доказывается редукцией к проблеме остановки), но они 
всё-таки <s>вертятся</s> существуют как программные продукты! В теории, невозможно написать 
программу-детектор, безошибочно определяющую, что другая программа печатает на экране, например, 
слово <<привет>> [28, 29]. Но ведь многие бы без труда написали такой детектор! Даже сами 
доказательства теорем, в силу соответствия Карри-Ховарда, вообще говоря, требуют решения 
проблемы остановки. Но ведь математики как-то доказывают теоремы! Иногда при помощи компьютера 
(и автоматизированно и даже автоматически).

Эти исключения не являются ошибками или фактами, опровергающими упомянутые контринтуитивные 
утверждения (содержащие квантор всеобщности). А положительные результаты имеют вполне конкретное 
применение. Компиляторы, интерпретаторы, квайны и многие другие интересные артефакты теории 
вычислимости существуют не только теоретически, но и имеют осязаемые реализации в виде реальных 
кусков кода и даже устройств (e.g. те же компьютеры). А теорема Гёделя о неполноте говорит, что 
некоторые теоремы просто не могут быть доказаны, -- не стоит даже и пытаться.

Наконец, диагонализация внесла некоторый вклад и в более абстрактные области философии. 
Например, применением диагонального процесса к демону Лапласа --- <<древнему>> суперкомпьютеру, 
имеющему неограниченный доступ к любой информации обо всех частицах вселенной --- была 
установлена <<монотеистическая>> теорема о невозможности существования более чем одного демона 
Лапласа [27].

В следующих сообщениях этой серии я напишу о некотрых из этих [как классических, так и 
относительно новых] результатов подробнее.

# Другие подходы и <<слегка открытые>> вопросы

В этом разделе обсуждаются достаточно простые, но до сих пор представляющие некоторый 
исследовательский интерес альтернативные подходы к конструированию квайнов. Некоторые из 
рассмотренных здесь вопросов могут быть тривиальными и, возможно, представляющими сложность лишь 
для меня; другие -- могут оказаться объективно стоящими дальнейшей проработки.

Более подробно все эти воросы будет или не будут освещены в следующем(-их) сообщении(-ях) этой 
серии.

## <<Креационизм>> vs. <<абиогенез>>

Я условно назвал совокупность методов (как ручных, так и автоматических), применяемых для 
конструирования квайнов и основанных на существенном привнесении специально подготовленной 
внешней информации/знаний в этот процесс [квайнологическим] <<креационизмом>>. Традиционное 
написание квайна вручную, а также его конструирования на основе второй рекурсивной теоремы Клини 
-- суть примеры креационисткого подхода в квайнологии. В них требуется существенный контроль со 
стороны программиста.

В подразделах же, приведенных ниже, акцент сделан на автоматическом итеративном конструировании 
квайнов (если оно возможно). <<Абиогенетическое>>, самостоятельное <<зарождение>> квайнов 
потенциально могло бы представлять некоторую ценность в ряде областей. Так, например, 
квайнологический абиогенез был бы интересен в таком разделе информационной безопасности как 
компьютерная вирусология; он был бы применим в автономных системах (e.g., самомодифицирующееся 
ПО каких-нибудь марсоходов) и, возможно, интересен экзобиологам (в том смысле, что квайны, 
будучи <<дистиллированной>> моделью жизни, подошли бы для изучения тварей с *terra incognita*, 
-- будь-то океанские впадины, астероиды, космическая пыль/мусор, или любые другие субстраты).

## Кимианские квайны и итеративное вычисление неподвижной точки

Хофштадтер в [26] не только ввел термин квайн, но и описал там же ещё одну разновидность 
самореплицирующегося кода -- кимианские квайны, названные в честь Скотта Кима (Scott Kim), 
подсказавшего эту идею Хофштадтеру.

Кимианский квайн представляет собой текст, который будучи поданым на вход 
компилятора/интерпретатора, не распознается как корректный исходный текст, а приводит к выводу 
сообщения об ошибке. Причём такое сообщение побуквенно совпадает с самим кимианским квайном. 
Т.е. при попытке запуска или компиляции, подобный код всё-таки воспроизводит себя, как и 
положено квайну.

Если обозначить среду исполнения для кимианского квайна (e.g., компилятор, интерпретатор или 
коммандную оболойчку) как функцию $F(x)$, принимающую и возвращающую текстовую строку, то 
некоторый кимианский квайн $q$ будет неподвижной точкой этой функции: $F(q)=q$.

Интересно, что в данном случае $q$ может быть вычислен итерированием функции $F$ начиная с 
подходящего (иногда пустого) начального приближения. Т.е. алгоритм конструирования 
кимианского квайна должен будет вычислить $q=\lim_{k\to\infty}F^k(\varepsilon)$, где 
$F^k(x)=F\big(F^{k-1}(x)\big)$, $F^0(x)=x$ для некоторого начального значения $\varepsilon$.

Следует заметить, что такая функция $F(x)$ определена для всех $x$ (и к тому же всегда 
завершается, если речь идет о компиляторе без поддержки вычислительно-универсальных 
металингвистических средств, --- например, подобных C++ шаблонам, --- могущих приводить к 
<<зависанию>> компилятора).

В минирепозитории (gist) [33] можно найти простую реализацию подобного метода итеративного 
конструирования кимианского квайна, выполненную на языке коммандной оболочки bash. Скрипт 
принимает в качестве аргумента путь до исполняемого файла интерпретатора или компилятора, 
запускает его и передает ему имя файла, хранящего начальное приближение. Результат из потоков 
вывода сохраняется в этот же файл если этот результат отличается от содержимого файла, после 
чего процесс повторяется. И так до стабилизации процесса, т.е. пока данный интерпретатор не 
будет выдавать тот же текст, который он получил на вход. (Эксперименты показывают, что 
таким способом неподвижная точки находится не всегда.)

## Другие конструктивные теоремы о неподвижной точке

Пожалуй, это самый спекулятивный и неформальный подраздел этого сообщения. Здесь перечисляются 
некоторые известные теоремы о неподвижных точках, которые, возможно, могли бы быть применены для 
конструирования квайнов. Сама эта возможность находится под вопросом, но эти теоремы всё-же 
заслуживают упоминания в таком контексте.

### Первая рекурсивная теорема Клини

### Теорема Клини о неподвижной точке [из теории решёток]

Произвольное отображение $F\colon M\to M$, непрерывное по Скотту и определенное на полном 
частично упорядоченном множестве $M$ с отношением порядка $\sqsubseteq$ имеет наименьшую 
неподвижную точку.

Непрерывность по Скотту означает существование $\sup F(S)$ и выполнение  $F(\sup S)=\sup F(S)$ 
для всякого направленного подмножества $S\subseteq M$.

### Теорема Кнастера-Тарского

В [37] приведена теорема о существовании неподвижных точек монотонных функций на полной решетке. 
Пусть $F\colon L\to L$ -- монотонный оператор на полной решетке $L$ с отношением частичного 
порядка $\sqsubseteq$. Т.е. $\forall X, Y\in L, X\sqsubseteq Y\Rightarrow F(X)\sqsubseteq F(Y)$. 
Теорема Тарского утверждает, множество неподвижных точек оператора $F$, i.e., таких $X$, что 
$F(X)=X$, само является непустой полной решеткой.

В [38] доказана конструктивная версия этой теоремы. До этой работы, неподвижные точки монотонных 
отображений уже конструировали как $\sup F^i(\bot)$, где $i\in\mathbb{N}$, а $\bot=\inf L$. Но 
это требовало от $F$ непрерывности по Скотту

(Эти результаты обобщаются на случай полных частично упорядоченных множеств, только 
направленные подмножества которых должны иметь супремум.)

## Комбинатор неподвижной точки в лямбда-исчислении

В $\lambda$-исчислении [34] для реализации рекурсии используются комбинаторы неподвижной точки, 
в основном $\mathrm{Y}$­комбинатор. Этот комбинатор определяется уравнением $\mathrm{Y} f\equiv 
f(\mathrm{Y} f)$ и в соответствии с этим определением вычисляет неподвижную точку функции $f$, 
т.е. такое выражение $x$, что $f x=x$.

Если конкретная реализация $\lambda$-исчисления поддерживает рекурсивные определения именованных 
символов, то вышеприведенного определения достаточно для работы с $\mathrm{Y}$-комбинатором 
(могут возразить, что в таком случае он не особо-то и нужен; однако, здесь $Y$-комбинатор может 
служить полезной обёрткой для некоторых функций, позволяющей, к примеру, добавить временное 
хранение промежуточных результатов с целью исключения их повторного вычисления, --- т.е., 
кэширование, --- и, соответственно, ускорение в духе динамического программирования). В чистом 
же $\lambda$-исчислении требуется определить $\mathrm{Y}$-комбинатор в явном виде, например как 
$\mathrm{Y}\equiv \lambda f.\big(\lambda x. f (x x)\big) \big(\lambda x. f (x x)\big)$ 
(известный как комбинатор Карри или парадоксальный комбинатор) или, в случае использования 
императивного языка, задействовать [энергичный] комбинатор Тьюринга $\Theta_v=a a$, где 
$a\equiv\lambda x.\lambda y.y(\lambda z. x x y z)$.

Теорема о неподвижной точке.

Несмотря на неочевидность этого утверждения, в нетипизированном $\lambda$-исчислении любое 
выражение имеет неподвижную точку (хотя бы одну).

Доказательство.

Пусть $A\equiv\lambda x.\lambda y. y (x x y)$. Комбинатор Тьюринга есть $\mathrm{\Theta}\equiv A 
A$. Утверждается, что для любого $\lambda$-выражения $F$, выражение $N=\mathrm{\Theta} F$ есть 
его неподвижная точка. Чтобы увидеть это, запишем следующую цепочку уравнений:

{% tex block %}
\begin{align*}
N=\mathrm{\Theta} F&= A A F =\\
&=\big(\lambda x. \lambda y.y (x x y)\big) A F \rightsquigarrow
F (A A F)=F(\mathrm{\Theta} F)=F N,
\end{align*}
{% endtex %}

где $\rightsquigarrow$ обозначает последовательность из нуля или нескольких шагов 
$\beta$-редукции. $\blacksquare$

Теперь $\mathrm{Y}$-комбинатор может быть применен для вычисления значений функций, вызывающих 
сами себя, в среде, не имеющей возможности выполнять именованный рекурсивный вызов или вообще не 
поддерживающей именование объектов.

Например, если требуется вычислить функцию $f= \lambda x.(\ldots f\ldots)$, вызывающую саму себя 
по имени $f$, то можно определить новую функцию $F$, принимающую $f$ как аргумент: 
$F\equiv\lambda f.\lambda x.(\ldots f\ldots)$ (а при использовании индексов де Брёйна или 
бинарного лямбда-исчисления мы можем избавиться и от именованных переменных вовсе). После 
определения $F$ мы можем вычислить $f$ как $f=\mathrm{Y} F$, потому что $f$ есть неподвижная 
точка $F$, т.е., $F f=\lambda x.(\ldots f\ldots=f)$, а $\mathrm{Y} F$, как было сказано выше, 
как раз и находит такую неподвижную точку. Желающие могут непосредственной подстановкой 
убедиться, что в этом случае действительно выполняется $F (\mathrm{Y} F)=\mathrm{Y} F$.

Учитывая универсальность $\lambda$-исчисления и вышеприведенную теорему о неподвижной точке [в 
$\lambda$-исчислении], естественно возникает идея об использовании комбинатора неподвижной точки 
для конструирования квайнов.

## Логическое программирование в ограничениях

В [12] приводится интересный метод генерации квайнов с использованием логического 
программирования. Авторы использовали язык логического программирования miniKanren, 
позволяющий написать на нём аналог <<основного уравнения квайнов>> $\llbracket q\rrbracket(x)=q$ 
и дать системе решить его относительно $q$. Квайны вычисляются быстро (за секунду) и имеют 
малые размеры.

## Эволюционные алгоритмы

Крайне интересной представляется потенциальная возможность генерации квайнов с помощью 
генетических алгоритмов. Среди многих проблем, возникающих при генерации программ эволюционными 
методами, выделяется проблема сохранения допустимости или синтаксической <<корректности>> 
программ при действии генетических операторов (кроссовер, мутация).

В этом смысле, одним из наиболее пригодных представлений для инкрементной эволюционной 
генерации, являются искусственные нейронные сети (далее ИНС или нейросети). Будучи сетями 
однотипных нелинейных сумматоров, работа которых зависит от весов связей (синапсов) между ними, 
нейросети продолжают сохранять работоспособность даже при почти случайных 
изменениях/<<повреждениях>> в матрице их весовых коэффициентов. Это довольно сильно 
контрастирует с традиционными языками программирования, программы на которых с гораздо большей 
вероятностью подвержены выходу из строя при малейших необдуманных модификациях их исходного 
текста.

Квайны в виде нейросетей уже известны. В [41] описана ИНС, обучающаяся выводить значения своих 
же синаптических коэффициентов. Я же хотел бы здесь сосредоточится на другом способе генерации 
квайнов, а именно на конструировании программ посредством применения генетических алгоритмов к 
промежуточному представлению на основе нейросетей.

Есть интересный экспериментальный язык Anne, [40], придуманный специально для работы с 
нейросетями и транслятор neuralbf [16] того же автора, преобразующий программу на bf в описание 
рекуррентной ИНС. Последняя работа (кому-то могущая показаться несерьёзной) фокусируется на 
применении генетических алгоритмов для совершенствования и исправления уже написанных вручную 
программ (вместо их генерации без начального приближения).

## Цепные квайны

Назовём *цепным квайном* (или итеративным квайном) с периодом $n$, последовательность $n$ 
программ $q_0,\ \ldots,\ q_{n-1}$, такую, что $\forall i\in [0;n[\ \forall x\ \llbracket q_i 
\rrbracket(x) = q_{i+1}$ и $q_n=q_0$.

Всякий, кто пытался писать квайны и цепные квайны, не мог не отметить разительное отличие в 
сложности их написания -- цепные квайны обычно проще истинных квайнов (i.e., тоже цепных 
квайнов, но с периодом $n=1$).

Соответственно, не может не возникнуть вопрос о реализуемости полностью автоматического 
преобразования данной последовательности $\{q_i\}_i$ в настоящий квайн $q=\llbracket 
q\rrbracket(x),\ \forall x$.

## Генератор квайнов, не зависимый от языка

В разделе о конструировании квайнов на основе второй рекурсивной теоремы Клини, приводился 
готовый рецепт, алгоритм генерации квайна для конкретного заранее выбранного языка 
программирования. (Похожий алгоритм возможен и в контексте доказательства теоремы Роджерса.) 
Возможно, что слово <<алгоритм>> здесь можно понимать более формально и буквально.

Представляется интересным вопрос о существовании программы $G$, --- <<квайнтификатора>>, --- 
генерирующей квайн на указанном языке $L$ с использованием некоторого количества образцов кода 
на этом языке. Причем и разумной спецификацией языка $L$ и одновременно образцом кода на нём 
может служить интерпретатор языка $L$ (существующий по теореме об универсальной функции).

Чуть более формально задача может быть поставлена так. Пусть дан интерпретатор $I_L$ языка $L$, 
написанный на своем же входном языка, т.е. для любой программы $p$ на языка $L$ выполняется 
$\llbracket I_L\rrbracket_L(p, x)=\llbracket p\rrbracket_L(x)$. Пусть также $I_L$ оттранслирован 
на референсный язык (семантические скобки без индекса) и существует на нём в виде программы 
$I'_L$. В этом случае справедливо $\llbracket I'_L\rrbracket(p, x)=\llbracket p\rrbracket_L(x)$.

Спрашивается, как может выглядеть программа $G$, такая, что $q=\llbracket G\rrbracket (I_L, 
I'_L)$ и $\llbracket I'L\rrbracket (q, x)=q$? Выше мы видели, что $q$ есть неподвижная точка (по 
Роджерсу) оператора $\mathrm{quote}$. При попытке реализовать $\mathrm{quote}$ выясняется, что 
структура соответствующей программы сильно схожа со структурой интерпретатора. Возможно, это 
сходство можно использовать для написания $G$... Но это требует дальнейшего обдумывания.

# Заключение

Целью этого сообщения была демонстрация возможности автоматического конструирования квайнов на 
языке редактора sed с использованием доказательства второй рекурсивной теоремы Клини в качестве 
основы. Результат проведенного эксперимента можно считать положительным, хотя *автоматическим* 
такой способ написания квайнов можно назвать только в смысле достаточности запуска единственного 
скрипта `generate.sh` и ликвидации наиболее сложной, если можно так выразиться, творческой 
составляющей в конструировании самореплицирующейся системы.

В целом, сообщение уже немного вышло за рамки очерченных целей. Но о квайнах можно сказать 
больше... В следующих сообщениях этой серии.

# Ссылки

- [1] <http://www.madore.org/~david/computers/quine.html> -- хорошее объяснение концепции 
   квайнов, написанное профессором David Madore.
- [2] <http://math.berkeley.edu/~kmill/blog/blog_2018_5_31_universality_quines.html> -- теория 
   квайнов, квайны для лямбда-исчисления.
- [3] <http://en.wikipedia.org/wiki/Smn_theorem>
- [4] <http://en.wikipedia.org/wiki/partial_evaluation>
- [5] <http://fi.ftmr.info>
- [6] <http://ru.wikipedia.org/wiki/диагональный_аргумент>
- [7] <http://ru.wikipedia.org/wiki/теорема_Кантора>
- [8] <http://ru.wikipedia.org/wiki/проблема_остановки>
- [9] <http://ru.wikipedia.org/wiki/автомат_фон_Неймана>
- [10] <http://ru.wikipedia.org/wiki/зонд_фон_Неймана>
- [11] Jiazhen Cai, Robert Paige, Program derivation by fixed point computation, 1989
- [12] William E.Byrd, Eric Holk, Daniel P.Friedman, miniKanren, live and untagged: Quine generation via relational interpreters, 2012
- [13] P.Cousot, R.Cousot, Constructive verstions of Tarski's fixed point theorems, 1979
- [14] S.C.Kleene, Introduction to Meta-Mathematics, 1952
- [15] A.Tarski, A lattice-theoretical fixpoint theorem and its application, 1955
- [16] Daniel Kraft (mailto:d@domob.eu), neuralbf, <http://www.domob.eu/projects/neuralbf.php>, 
   <https://gitlab.com/domob/neuralbf>
- [17] <https://github.com/MakeNowJust/quine/blob/master/quine.sed
- [18] <https://github.com/MakeNowJust/quine>
- [19] H.Rogers, Theory of Recursive Functions and Effective Computability
- [20] T.A.Hansen, T.Nikolajsen, J.L.Traff, N.D.Jones, Experiments with Implementation of two Theoretical Constructions
- [21] G.Bonfante, M.Kaczmarek, J-Y.Marion, Toward an Abstract Computer Virology
- [22] _____, A Classification of Viruses through Recursion Theorems
- [23] Julia L. Lawall, Olivier Danvy, Continuation-Based Partial Evaluation
- [24] Anders Bondorf, Improving Binding Times Without Explicit CPS-Conversion
- [25] D.A.Wheeler, Fully Countering Trusting Trust through Diverse Double-Compiling, 2009
- [26] Douglas R.Hofstadter, Goedel, Escher, Bach: an Eternal Golden Braid, 1979
- [27] P.-M. Binder, Theories of almost everything, 2008
- [28] H.G.Rice, Classes of recursively enumerable sets and their decision problems, 1953
- [29] <https://en.wikipedia.org/wiki/Rice_theorem>
- [30] Gary P.Thompson II, The quine page 
   (self-reproducing code), <http://www.nyx.net/~gthompso/quine.htm>
- [31] <http://www.nyx.net/~gthompso/self_kim.txt> -- Kimian Self Reproduction
- [32] <http://www.latrobe.edu.au/phimvt/joy>
- [33] <https://gist.github.com/Circiter/7152686>
- [34] <http://en.wikipedia.org/wiki/lambda_calculus>
- [35] Lawrence S.Moss, Recursion Theorems and Self-Replication Via Text Register Machine 
   Programs
- [36] Neil Jones, Computer implementation and application of Kleene's s-m-n and recursion 
   theorem.
- [37] A.Tarski, A lattice theoretical fixpoint theorem and its applications, 1955
- [38] P.Cousot, R.Cousot, Constructive versions of Tarski's fixed point theorems, 1979
- [39] J.Case, S.E.Moelius III, Program Self-Reference in Constructive Scott Subdomains, 2009
- [40] compann.sourceforge.net -- язык программирования Anne (автор: Daniel Kraft)
- [41] O.Chang, H.Lipson, Neural Network Quine, 2018
- [42] <http://en.wikipedia.org/wiki/quine>
- [43] F.William Lawvere, Diagonal arguments and cartesian closed categories, 1969
- [44] Noson S.Yanofsky, A Universal Approach to Self-Referential Paradoxes, Incompleteness and 
   Fixed Points, 2003
- [45] Jean-Yves Marion, From Turing machines to computer viruses, 2012
- [46] <https://github.com/Circiter/quine-kleene-generator>
- [47] Kleene Second Recursion Theorem: A Functional Pearl // Proc. ACM 
   Program. Lang., Vol 1, 2018
