<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Дневник Circiter'а</title>
 <link href="http://circiter.tk/atom.xml" rel="self"/>
 <link href="http://circiter.tk/"/>
 <updated>2022-05-07T02:05:34+00:00</updated>
 <id>http://circiter.tk</id>
 <author>
   <name>Michael I. Nikitin</name>
   <email></email>
 </author>

 
 
 <entry>
   <title>Пасхалия в sed.</title>
   <link href="http://circiter.tk/computus-in-sed"/>
   <updated>2022-05-07T02:05:34+00:00</updated>
   <id>http://circiter.tk/computus-in-sed</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;Введение&lt;/h2&gt;
&lt;p&gt;Во время поста перед Пасхой решил написать сценарий (скрипт) &lt;code&gt;computus.sed&lt;/code&gt; &lt;a class=&quot;citation&quot; href=&quot;#computus-in-sed&quot;&gt;[1]&lt;/a&gt; для хорошо известного поточного текстового редатора sed, расчитывающий дату
празднования (в данном случае православной) Пасхи.&lt;/p&gt;
&lt;p&gt;Пример использования скрипта &lt;code&gt;computus.sed&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;2020 | ./computus.sed
&lt;span class=&quot;c&quot;&gt;# April, 19&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Исходное определение даты праздования Пасхи выглядит не очень сложно &lt;a class=&quot;citation&quot; href=&quot;#meeus1991&quot;&gt;[2,3]&lt;/a&gt;. Согласно ему, день празднования Пасхи приходится на первое воскресение после
первого полнолуния, наступившего не ранее весеннего равноденствия. Программный расчёт этой даты
подразумевает моделирование движения земли и луны, либо, что проще для реализации, аппроксимацию
полу-эмпирическими формулами.&lt;/p&gt;
&lt;p&gt;Проблема только усложняется тем, что эта дата — т.н. астрономическая Пасха — из-за
принятого в церкви алгоритма расчета указанных астрономических событий (полнолуние, равноденствие),
витиеватой истории календарных реформ и ряда дополнительных специальных соглашений/оговорок,
сильно отличается от фактических дат (тоже сильно различающихся между собой) празднования
Пасхи в различных церквях/религиях.&lt;/p&gt;
&lt;p&gt;Это обстоятельство вместе с [почти] полным отсутствием поддержки арифметики в sed сделало написание
этого скрипта несколько нетривиальной задачей (хотя периодичность результатов пасхалии, а именно
повторение дат с периодом в 532 года, в принципе позволяет обойтись и радужными таблицами, что
не так интересно).&lt;/p&gt;
&lt;p&gt;Поэтому сначала был написан простой интерпретатор для постфиксного (обратная польская нотация, далее
кратко rpn) языка, использующего стек/«магазин» (но поддерживающего именованные переменные).&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;Описание вспомогательного языка&lt;/h2&gt;
&lt;p&gt;Весь rpn-скрипт состоит из последовательности «слов», разделенных пробелами. Слова могут быть
числами или командами. Слова перечисляются и обрабатываются (выполняются) «слева-направо»
(т.е. с первого до последнего).&lt;/p&gt;
&lt;p&gt;Целое положительное число в десятичной записи преобразуется в унарную запись и кладётся на вершину
стека.&lt;/p&gt;
&lt;p&gt;Команды:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Сравнение: &lt;code&gt;eq&lt;/code&gt;. Удаляет из стека два верхних элемента, сравнивает их и кладет на
вершину стека единицу если аргументы равны, и ноль – в противном случае.&lt;/li&gt;
&lt;li&gt;Работа с переменными: &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;. Синтаксис: &lt;code&gt;set_&amp;lt;variable&amp;gt;&lt;/code&gt; и &lt;code&gt;get_&amp;lt;variable&amp;gt;&lt;/code&gt;, где
&lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; – имя изменяемой или, соответственно, читаемой переменной (без угловых скобок).
При записи, с вершины стека удаляется значение и записывается в указанную именованную переменную.
При чтении значение из переменной добавляется на стек.&lt;/li&gt;
&lt;li&gt;Аддитивные арифметические операции: &lt;code&gt;plus&lt;/code&gt;, &lt;code&gt;minus&lt;/code&gt;. Эти операции удаляют два значения-аргументы
со стека, складывают или находят их разность (причем вычитать можно только из большего меньшее),
а результат кладут на стек.&lt;/li&gt;
&lt;li&gt;Мультипликативные операции: &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;mod&lt;/code&gt;. Эти операции тоже берут со стека два значения и кладут
результат обратно на вершину. Операция &lt;code&gt;div&lt;/code&gt; производит целочисленное деление,
&lt;code&gt;mod&lt;/code&gt; – находит остаток от деления.&lt;/li&gt;
&lt;li&gt;Условный оператор: &lt;code&gt;if ... then&lt;/code&gt;. При выполнении команды &lt;code&gt;if&lt;/code&gt; проверяется вершина стека и
если на вершине лежит ноль, то блок между &lt;code&gt;if&lt;/code&gt; и &lt;em&gt;ближайшим&lt;/em&gt;, расположенным правее, словом
&lt;code&gt;then&lt;/code&gt; пропускается, иначе блок выполняется (N.B., вложенность не поддерживается).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;На данный момент все арифметические операции производятся в унарной системе счисления.
К примеру, для проверки високосности 2020 года требуется среди прочего найти остаток от деления на 4,
а для этого требуется записать 2020 единиц в буфер редактирования и начать последовательно удалять
по 4 единицы за раз, пока не останется менее четырех единиц, что и будет требуемым остатком. Да, это
очень медленно, но обеспечивает особую простоту кода.&lt;/p&gt;
&lt;p&gt;Аналогично, деление описывается следующим псевдокодом:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;swap_stack();
a=pop_stack();
b=pop_stack();
c=0;
while(a&amp;gt;b)
{
    a-=b;
    c++
}
push_stack(c);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Эта логика в &lt;code&gt;computus.sed&lt;/code&gt; реализуется следующим фрагментом (обратите внимание, что некоторые
строки прокомментированы соответствующими строками из вышеприведенного псевдокода):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^div/ {
    s/\n(1*)\n(1*)@/\n\2\n\1@/ # swap_stack();
    s/@/\n@/ # c=0;
    :div_iterations
        /\n(1*)\n1*\1\n/! bnot_matched
        s/\n(1*)(\n1*)\1(\n1*@)/\n\1\2\3/ # a-=b.
        s/\n(1*)@/\n1\1@/ # c++.
        bdiv_iterations
    :not_matched
    s/\n1*\n1*(\n1*@)/\1/
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В основе этого фрагмента лежит соответствующая строке &lt;code&gt;a-=b&lt;/code&gt; sed-инструкция
&lt;code&gt;s/\n(1*)(\n1*)\1(\n1*@)/\n\1\2\3/&lt;/code&gt;. Здесь работа ведется
с двумя унарными числами, разделенными переводом строки (&lt;code&gt;\n&lt;/code&gt;). Мы ищем (с
помощью обратной ссылки или «back-reference») первое число «внутри» [записи] второго:
&lt;code&gt;(1*)(\n1*)\1&lt;/code&gt;, и при удачном сопоставлении заменяем совпавший шаблон на строку &lt;code&gt;\1\2&lt;/code&gt;, включающую
ссылки на первые две группы в круглых скобках из шаблона, — т.е. &lt;code&gt;(1*)&lt;/code&gt; и &lt;code&gt;(\n1*)&lt;/code&gt;, — и
игнорирующую «хвостовую» часть второго числа, находящуюся, как вы можете видеть, за пределами
скобок: &lt;code&gt;(\n1*)\1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Эта процедура, по-сути, удаляет первое число из второго, т.е., говоря другими словами, вычитает первое
число из второго, чем, собственно, и достигается требуемый эффект от операции &lt;code&gt;a-=b&lt;/code&gt; (да, порядок
следования «перепутан» из-за стека; за это отвечает строка &lt;code&gt;swap_stack()&lt;/code&gt; из пседвокода, меняющая
два числа на вершине стека местами).&lt;/p&gt;
&lt;p&gt;В подробном разборе всего кода, естественно, нет особого смысла — ничто не заменит чтения самого
&lt;code&gt;computus.sed&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;section-2&quot;&gt;Расчёт даты&lt;/h2&gt;
&lt;p&gt;В &lt;a class=&quot;citation&quot; href=&quot;#meeus1991&quot;&gt;[2]&lt;/a&gt; приведен следующий алгоритм для расчета даты православной Пасхи (здесь
добавлена частичная коррекция даты для поддержки григорианского календаря или т.н. нового
стиля):
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/1-0.png&quot; style=&quot;{% style_stub baaaaa 0 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;
где переменные &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/1-1.png&quot; style=&quot;{% style_stub caaaaa 1 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/1-2.png&quot; style=&quot;{% style_stub daaaaa 2 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/1-3.png&quot; style=&quot;{% style_stub eaaaaa 3 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; означают текущие год, месяц и
день, соответственно.&lt;/p&gt;
&lt;p&gt;Для получения дат по григорианскому календарю я просто добавил слагаемое 13 в присваивание
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/1-4.png&quot; style=&quot;{% style_stub faaaaa 4 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.е. в таком виде этот код не будет правильно работать для дат до 1 февраля
1918 года. Теоретически, это не сложно исправить (однако, см. замечание ниже, в разделе
«Тестирование»).&lt;/p&gt;
&lt;p&gt;Дословная трансляция вышеприведенных формул на уже описанный в предыдущем разделе
проблемно-ориентированный миниязык может быть такой:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set_year get_year 4 mod set_a
get_year 7 mod set_b
get_year 19 mod set_c
19 get_c mul 15 plus 30 mod set_b
2 get_a mul 4 get_b mul plus 34 plus get_d minus 7 mod set_e
get_d get_e plus 114 plus 13 plus set_t
get_t 31 div set_mont
get_t 31 mod 1 plus set_day
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Несмотря на учёт перехода на «новый стиль», здесь всё ещё остается проблема с датой Пасхи,
приходящейся на май (исходные формулы вообще не могут давать майских дней). &lt;em&gt;Ad-hoc&lt;/em&gt; коррекция
для таких дат может выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get_month 5 eq if get_day 1 plus set_day then
get_mont 4 eq if get_day 31 eq if
5 set_month 1 set_day then then
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Это соответствует такому C-образному псевдокоду:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(month==5)
    day++
else if(month==4)
    if(day==31)
    {
        month=5
        day=1
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В конце rpn-скрипта мы просто кладем готовые месяц и день на стек для дальнейшей печати (с
преобразованием номера месяца в строку):
&lt;code&gt;get_month get_day&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-3&quot;&gt;Тестирование&lt;/h2&gt;
&lt;p&gt;В репозитории можно найти файл-список &lt;code&gt;test-easter-dates.txt&lt;/code&gt; с некоторыми проверочными датами и
скрипт &lt;code&gt;dictionary-test.sh&lt;/code&gt; для автоматического тестирования с их использованием. Спешу лишь
предупредить о достаточно большом времени, требуемом для завершения работы скрипта даже для
относительно небольшого диапазона дат, включенных в указанный файл (1994–2034 гг.)&lt;/p&gt;
&lt;p&gt;Кроме этого был написан на perl простой скрипт-обёртка &lt;code&gt;computus.pl&lt;/code&gt;, принимающий год в качестве
аргумента командной строки, расчитывающий дату празднования Пасхи с помощью модуля Dates::Easter
&lt;a class=&quot;citation&quot; href=&quot;#perl-easter&quot;&gt;[4]&lt;/a&gt; и возвращающий её в том же формате, что и &lt;code&gt;computus.sed&lt;/code&gt;. Он может
использоваться для сравнительного тестирования моего скрипта, а с целью упрощения этой процедуры
для диапазонов дат, можно воспользоваться сценарием оболочки &lt;code&gt;range-test.sh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Пример:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./computus.pl 2020
&lt;span class=&quot;c&quot;&gt;# April, 19&lt;/span&gt;
./range-test.sh 2018 2021
&lt;span class=&quot;c&quot;&gt;# 4 tests performed, 4 tests passed, 0 tests failed.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Для меня пока остаётся открытым вопрос о работоспособности скрипта &lt;code&gt;computus.sed&lt;/code&gt; для
всего XXI века, а также для дат, предшествовавших реформе 1918 года, вплоть до времен разработки
и начала применения пасхалии (хотя конкретно этот алгоритм, по-видимому, не будет работать для
времени более раннего чем 1583 год, что связано с введением григорианского календаря именно в 1582
году; это требует уточнения). К слову, &lt;code&gt;computus.pl&lt;/code&gt; согласуется с моим для текущего века, но
расходится с моим на один день для века XIX, что, возможно, связано с вопросом о новом
стиле, хотя в начала XX века, скрипты дают одинаковые даты, а это уже свидетельствует о
наличии в perl-модуле &lt;code&gt;Dates::Easter&lt;/code&gt; той же или похожей недоработки, что и в моём случае.&lt;/p&gt;
&lt;p&gt;Вообще, в календарных расчетах должно учитываться (и, по всей видимости, в &lt;code&gt;Dates::Easter&lt;/code&gt; это
учитывается), что разница между юлианским и григорианским
календарями зависит от конкретного века (и увеличивается на 3 за 4 века).
Эту зависимость можно проиллюстрировать следующей таблицей-примером:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Века&lt;/th&gt;
&lt;th&gt;Коррекция (сутки)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;XIV&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XV&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XVI–XVII&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XVIII&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XIX&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XX–XXI&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XXII&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Также должна учитываться и конкретная дата внутри века, причем не самым систематичным
образом. E.g., коррекция в 10 дней действует с 5 октября 1582 года по 28 февраля 1700 года, а
коррекция в 11 дней — с 1 марта 1700 года по 28 февраля 1800 года. (При этом, я слышал, что
православная церковь просто использует фиксированную разницу в 13 дней всегда; это утверждение
требует дополнительной проверки)&lt;/p&gt;
&lt;p&gt;В любом случае, несмотря на то, что &lt;code&gt;Dates::Easter&lt;/code&gt; соблюдает вековое варьирование разницы между
календарями, мой скрипт, или по крайней мере его текущая версия, использует именно фиксированную
поправку +13, впрочем, исключительно ради простоты реализации. Посмотрим, что будет в XXII веке с его
четырнадцатидневной коррекцией. :)&lt;/p&gt;
&lt;h2 id=&quot;section-4&quot;&gt;Возможные улучшения&lt;/h2&gt;
&lt;p&gt;За счёт использования стекового dsl-языка представляется относительно несложной задача адаптации
настоящего скрипта к другим вариантам Пасхи, включая католическую и еврейскую. Поддержку
астрономической Пасхи прямым моделированием планетарного движения на sed реализовать сложнее, но
можно подобрать, как уже было отмечено, приближенные формулы. Например, что несколько неожиданно,
ядро расчета еврейской Пасхи, кажется, достаточно точно соответствует астрономической дате
(это, однако, нивелируется по меньшей мере соглашениями о невозможности её празднования в
определенные дни недели).&lt;/p&gt;
&lt;p&gt;Другим очевидным (но не приоритетным) направлением для улучшения обсуждаемого sed-сценария
является ускорение его работы, например переходом к десятичной или хотя-бы двоичной системе
счисления. В постфиксном калькуляторе &lt;code&gt;dc.sed&lt;/code&gt; &lt;a class=&quot;citation&quot; href=&quot;#sed-dc&quot;&gt;[5]&lt;/a&gt;, написанном Greg Ubben, почти
вся необходимая арифметика уже реализована (и работает с огромной скоростью, в отличии от моей
унарной реализации «счётных палочек»).&lt;/p&gt;
&lt;p&gt;Наконец, было бы неплохо исправить описанные в предыдущих разделах ошибки с расчётом дат Пасхи в
веке XIX и далее в глубь веков. В противоположном направлении по оси времени тоже есть
определенные тонкости, вроде необходимости учёта разницы между юлианским и новоюлианским
календарями после 2800 года. Дополнительный разбор пасхалии и календарных несоответствий может
быть найден в &lt;a class=&quot;citation&quot; href=&quot;#calendar&quot;&gt;[6]&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;section-5&quot;&gt;Ссылки&lt;/h2&gt;
&lt;ul class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;computus-in-sed&quot;&gt;1. &lt;/span&gt; &lt;a href=&quot;https://github.com/Circiter/computus-in-sed&quot;&gt;https://github.com/Circiter/computus-in-sed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;meeus1991&quot;&gt;2. Meeus J. Astronomical Algorithms. 1991&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-computus&quot;&gt;3. &lt;/span&gt; &lt;a href=&quot;http://ru.wikipedia.org/wiki/пасхалия&quot;&gt;http://ru.wikipedia.org/wiki/пасхалия&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;perl-easter&quot;&gt;4. &lt;/span&gt; &lt;a href=&quot;http://search.cpan.org/dist/Date-Easter&quot;&gt;http://search.cpan.org/dist/Date-Easter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;sed-dc&quot;&gt;5. &lt;/span&gt; &lt;a href=&quot;http://sed.sourceforge.net/grabbag/scripts/dc.sed&quot;&gt;http://sed.sourceforge.net/grabbag/scripts/dc.sed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;calendar&quot;&gt;6. Календарный вопрос: Сборник статей / под ред. Чхартишвили А. 2000&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Индексы в определении свертки последовательностей [или функций].</title>
   <link href="http://circiter.tk/convolution-indices"/>
   <updated>2022-05-07T02:05:34+00:00</updated>
   <id>http://circiter.tk/convolution-indices</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;Введение&lt;/h1&gt;
&lt;p&gt;Что общего между поиском котов на фотографии, сжатием музыки, прогнозированнием курсов валют,
угадыванием мелодии по нотам, умножением чисел на бумаге (или на счётах), и добавлением,
скажем, эффекта звучания в большом железобетонном зале к речи, записанной на улице?&lt;/p&gt;
&lt;p&gt;А общность их заключена хотя-бы в том, что с точки зрения программиста, все эти задачи (причем,
список подобных — на первый взгляд разрозненных — примеров на самом деле длиннее) могут быть
более или менее успешно решены практически одним и тем же небольшим куском кода, реализующим
свёртку &lt;a class=&quot;citation&quot; href=&quot;#wiki-convolution&quot;&gt;[1]&lt;/a&gt; функций или последовательностей. (С точки зрения же
заказчиков и управляющих/начальства этого программиста, такие задачи должны, конечно, считаться
абсолютно не связанными друг с другом и, соответственно, требующими отдельного независимого
финансирования. :) )&lt;/p&gt;
&lt;p&gt;Взглянув на первое попавшееся определение свертки, некоторым нелегко сразу понять, почему в формуле
записаны минусы в индексах, и почему при наглядной интерпретации в виде наложения графиков требуется
сначала отразить один из них.&lt;/p&gt;
&lt;p&gt;В настоящем сообщении я хотел бы показать естественность свертки используя ряд простых примеров,
среди которых будут перемножение чисел, теорема о свертке и рассуждения о сдвиговой инвариантности
линейных преобразований.&lt;/p&gt;
&lt;h1 id=&quot;section-1&quot;&gt;Немного определений&lt;/h1&gt;
&lt;p&gt;Циклической (или круговой) свёрткой двух последовательностей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-0.png&quot; style=&quot;{% style_stub gaaaaa 0 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-1.png&quot; style=&quot;{% style_stub haaaaa 1 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; длины &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-2.png&quot; style=&quot;{% style_stub iaaaaa 2 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; называют
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-3.png&quot; style=&quot;{% style_stub jaaaaa 3 inline %}&quot; class=&quot;latex&quot;&gt;-элементную&lt;/span&gt; последовательность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-4.png&quot; style=&quot;{% style_stub kaaaaa 4 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с элементами
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-5.png&quot; style=&quot;{% style_stub laaaaa 5 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Выражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-6.png&quot; style=&quot;{% style_stub maaaaa 6 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; может быть записано и более симметричным образом (обратите внимание, что такая
запись уже позволяет избавиться от минусов, правда ценой переноса слагаемого в индекс/предел
суммы): &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-7.png&quot; style=&quot;{% style_stub naaaaa 7 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема о свертке:&lt;/strong&gt;
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-8.png&quot; style=&quot;{% style_stub oaaaaa 8 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; где
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-9.png&quot; style=&quot;{% style_stub paaaaa 9 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – преобразование Фурье; причем перемножение Фурье-образов производится поэлементно.&lt;/p&gt;
&lt;p&gt;В словесной формулировке можно сказать, что спектр свертки равен произведению
спектров исходных сигналов.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Набросок доказательства (из &lt;a class=&quot;citation&quot; href=&quot;#matters-computational&quot;&gt;[2]&lt;/a&gt;):&lt;/strong&gt;
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-10.png&quot; style=&quot;{% style_stub qaaaaa 10 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;
где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-11.png&quot; style=&quot;{% style_stub raaaaa 11 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и используется определение преобразования Фурье для
последовательности: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-12.png&quot; style=&quot;{% style_stub saaaaa 12 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (здесь игнорируется небольшое отличие
между прямым и обратным преобразованиями Фурье, заключающееся в знаке аргумента экспоненты и
в множителе &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-13.png&quot; style=&quot;{% style_stub taaaaa 13 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; [перед обратным преобразованием]). &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-14.png&quot; style=&quot;{% style_stub uaaaaa 14 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Аналогичный результат известен и для преобразования Лапласа:
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-15.png&quot; style=&quot;{% style_stub vaaaaa 15 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Уместно заметить, что теорема о свертке имеет важное прикладное значение, т.к. дает метод
эффективного вычисления свертки с помощью быстрого преобразования Фурье &lt;a class=&quot;citation&quot; href=&quot;#wiki-fft&quot;&gt;[3]&lt;/a&gt;. В
нашем же случае важно видеть как в приведенном простом доказательстве появляются минусы в
индексах и, что гораздо более интересно, как они используются далее для преобразования границ
суммирования.&lt;/p&gt;
&lt;p&gt;Линейной (или ацикличной) свёрткой &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-16.png&quot; style=&quot;{% style_stub waaaaa 16 inline %}&quot; class=&quot;latex&quot;&gt;-элементных&lt;/span&gt; последовательностей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-17.png&quot; style=&quot;{% style_stub xaaaaa 17 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-18.png&quot; style=&quot;{% style_stub yaaaaa 18 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; называется
последовательность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-19.png&quot; style=&quot;{% style_stub zaaaaa 19 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; длины &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-20.png&quot; style=&quot;{% style_stub abaaaa 20 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; с элементами:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-21.png&quot; style=&quot;{% style_stub bbaaaa 21 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Линейная свертка может быть найдена с помощью циклической свертки если исходные последовательности
длины &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-22.png&quot; style=&quot;{% style_stub cbaaaa 22 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; дополнить нулями до длины &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-23.png&quot; style=&quot;{% style_stub dbaaaa 23 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а затем свернуть.&lt;/p&gt;
&lt;p&gt;Линейная свертка фактически может рассматриваться как произведение чисел — суть строк
цифр [в некоторой позиционной системе счисления], — или как произведение полиномов.&lt;/p&gt;
&lt;p&gt;Определение свертки обобщается и на непрерывный случай. А именно, если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-24.png&quot; style=&quot;{% style_stub ebaaaa 24 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-25.png&quot; style=&quot;{% style_stub fbaaaa 25 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – непрерывные
функции, то их свертка равна
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-26.png&quot; style=&quot;{% style_stub gbaaaa 26 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;N.B., этот интеграл тоже является функцией от &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-27.png&quot; style=&quot;{% style_stub hbaaaa 27 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (Вопросы, связанные с квадратичной интегрируемостью
функций &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-28.png&quot; style=&quot;{% style_stub ibaaaa 28 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-29.png&quot; style=&quot;{% style_stub jbaaaa 29 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; здесь не рассматриваются.)&lt;/p&gt;
&lt;h1 id=&quot;section-2&quot;&gt;Умножение чисел&lt;/h1&gt;
&lt;p&gt;Перемножим два целых положительных числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-30.png&quot; style=&quot;{% style_stub kbaaaa 30 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-31.png&quot; style=&quot;{% style_stub lbaaaa 31 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; имеющих десятичные разложения
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-32.png&quot; style=&quot;{% style_stub mbaaaa 32 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-33.png&quot; style=&quot;{% style_stub nbaaaa 33 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
соответственно, где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-34.png&quot; style=&quot;{% style_stub obaaaa 34 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Результат будет равен
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-35.png&quot; style=&quot;{% style_stub pbaaaa 35 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Но если мы построим подобное разложение и для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-36.png&quot; style=&quot;{% style_stub qbaaaa 36 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. запишем его как &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-37.png&quot; style=&quot;{% style_stub rbaaaa 37 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-38.png&quot; style=&quot;{% style_stub sbaaaa 38 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (N.B., здесь, в отличии от разложений для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-39.png&quot; style=&quot;{% style_stub tbaaaa 39 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-40.png&quot; style=&quot;{% style_stub ubaaaa 40 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; мы не используем неравенство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-41.png&quot; style=&quot;{% style_stub vbaaaa 41 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; позволяя такой записи числа оставаться
«ненормализованной», т.е. возможно требующей серии дальнейших переносов в старший разряд), то
приравнивая &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-42.png&quot; style=&quot;{% style_stub wbaaaa 42 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-43.png&quot; style=&quot;{% style_stub xbaaaa 43 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; мы получим выражения для «цифр» числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-44.png&quot; style=&quot;{% style_stub ybaaaa 44 inline %}&quot; class=&quot;latex&quot;&gt;:&lt;/span&gt; &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-45.png&quot; style=&quot;{% style_stub zbaaaa 45 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; где применено равенство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-46.png&quot; style=&quot;{% style_stub acaaaa 46 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из-за того, что в слагаемом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-47.png&quot; style=&quot;{% style_stub bcaaaa 47 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
разложения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-48.png&quot; style=&quot;{% style_stub ccaaaa 48 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; множитель &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-49.png&quot; style=&quot;{% style_stub dcaaaa 49 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; находится при степени десяти &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-50.png&quot; style=&quot;{% style_stub ecaaaa 50 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-51.png&quot; style=&quot;{% style_stub fcaaaa 51 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в
разложении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-52.png&quot; style=&quot;{% style_stub gcaaaa 52 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; находится при &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-53.png&quot; style=&quot;{% style_stub hcaaaa 53 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-54.png&quot; style=&quot;{% style_stub icaaaa 54 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно выразить &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-55.png&quot; style=&quot;{% style_stub jcaaaa 55 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-56.png&quot; style=&quot;{% style_stub kcaaaa 56 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Подстановка в выражения для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-57.png&quot; style=&quot;{% style_stub lcaaaa 57 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; дает:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-58.png&quot; style=&quot;{% style_stub mcaaaa 58 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Сравнение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-59.png&quot; style=&quot;{% style_stub ncaaaa 59 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-60.png&quot; style=&quot;{% style_stub ocaaaa 60 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; показывает, что мы здесь имеем дело именно с линейной сверткой
последовательностей цифр исходных чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-61.png&quot; style=&quot;{% style_stub pcaaaa 61 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-62.png&quot; style=&quot;{% style_stub qcaaaa 62 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (Достаточное количество переносов в старший
разряд, выполненных в произвольном порядке, позволит преобразовать каждое &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-63.png&quot; style=&quot;{% style_stub rcaaaa 63 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-64.png&quot; style=&quot;{% style_stub scaaaa 64 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. в настоящую цифру числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-65.png&quot; style=&quot;{% style_stub tcaaaa 65 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;section-3&quot;&gt;Корреляция&lt;/h1&gt;
&lt;p&gt;Для непрерывных функций &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-66.png&quot; style=&quot;{% style_stub ucaaaa 66 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-67.png&quot; style=&quot;{% style_stub vcaaaa 67 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; их корреляция (или кросс-корреляция) &lt;a class=&quot;citation&quot; href=&quot;#wiki-cross-correlation&quot;&gt;[4]&lt;/a&gt; определяется как &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-68.png&quot; style=&quot;{% style_stub wcaaaa 68 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;(&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-69.png&quot; style=&quot;{% style_stub xcaaaa 69 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; обозначает комплексное сопряжение некоторого числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-70.png&quot; style=&quot;{% style_stub ycaaaa 70 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Это определение можно записать в эквивалентной форме, без минуса:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-71.png&quot; style=&quot;{% style_stub zcaaaa 71 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-72.png&quot; style=&quot;{% style_stub adaaaa 72 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-73.png&quot; style=&quot;{% style_stub bdaaaa 73 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; периодичны с периодом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-74.png&quot; style=&quot;{% style_stub cdaaaa 74 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то можно интегрирование производить по
интервалу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-75.png&quot; style=&quot;{% style_stub ddaaaa 75 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Связь корреляции со сверткой:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-76.png&quot; style=&quot;{% style_stub edaaaa 76 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Интересное свойство:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-77.png&quot; style=&quot;{% style_stub fdaaaa 77 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Аналог теоремы о свертке; привожу без доказательства (которое, однако, легко построить
по аналогии с вышеприведенным случаем для обычной теоремы о свертке):
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-78.png&quot; style=&quot;{% style_stub gdaaaa 78 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Также как и в случае со сверткой, мы можем ограничиться рассмотрением значений функций в
отдельных точках, что после замены интегралов знаками суммы приводит к аналогичным формулам
для числовых последовательностей.&lt;/p&gt;
&lt;h1 id=&quot;section-4&quot;&gt;Линейные системы&lt;/h1&gt;
&lt;p&gt;Широкое практическое применение свертки (в частности физиками и инженерами) обусловленно возможностью
её использования для описания отклика линейных систем, в том числе многих реальных физических систем,
обладающих свойствами линейности и сдвиговой инвариантности (симметричности) по времени (или
заменяющей(-им) его переменной(-ым)).&lt;/p&gt;
&lt;p&gt;(Ниже, в основном, приведена свободная адаптация материала из &lt;a class=&quot;citation&quot; href=&quot;#wiki-linear-time-invariant-system&quot;&gt;[5]&lt;/a&gt; с некоторым упрощением нотации, и не факт, что без ущерба
строгости изложения. Кроме того, я ограничусь рассмотрением только непрерывного случая,
подразумевая, что дискретная версия вытекает из него как частный случай.)&lt;/p&gt;
&lt;p&gt;Допустим, некоторая система моделируется функцией &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-79.png&quot; style=&quot;{% style_stub hdaaaa 79 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; преобразующей входной сигнал &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-80.png&quot; style=&quot;{% style_stub idaaaa 80 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в отклик
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-81.png&quot; style=&quot;{% style_stub jdaaaa 81 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Отображение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-82.png&quot; style=&quot;{% style_stub kdaaaa 82 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (фактически, оператор) линейно:
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-83.png&quot; style=&quot;{% style_stub ldaaaa 83 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Последнее выражение, очевидно, легко обобщается и на произвольное количество слагаемых-сигналов
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-84.png&quot; style=&quot;{% style_stub mdaaaa 84 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и на непрерывный случай с заменой суммирования
интегрированием: &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-85.png&quot; style=&quot;{% style_stub ndaaaa 85 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-86.png&quot; style=&quot;{% style_stub odaaaa 86 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; преобразует
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-87.png&quot; style=&quot;{% style_stub pdaaaa 87 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-88.png&quot; style=&quot;{% style_stub qdaaaa 88 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Кроме этого, отображение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-89.png&quot; style=&quot;{% style_stub rdaaaa 89 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; инвариантно относительно сдвигов [по «времени»]:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-90.png&quot; style=&quot;{% style_stub sdaaaa 90 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Т.е. в данном случае моделируется
важное свойство реальных систем, а именно независимость результатов эксперимента от времени его
начала: если мы опоздали с началом эксперимента на некоторое время &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-91.png&quot; style=&quot;{% style_stub tdaaaa 91 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то и результаты мы получим
с опозданием &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-92.png&quot; style=&quot;{% style_stub udaaaa 92 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Так как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-93.png&quot; style=&quot;{% style_stub vdaaaa 93 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то (просто за счет подстановки &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-94.png&quot; style=&quot;{% style_stub wdaaaa 94 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt;
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-95.png&quot; style=&quot;{% style_stub xdaaaa 95 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Если в качестве сигнала взять [одномерную] дельта-функцию Дирака &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-96.png&quot; style=&quot;{% style_stub ydaaaa 96 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; &lt;a class=&quot;citation&quot; href=&quot;#wiki-delta-function-en&quot;&gt;[6,7]&lt;/a&gt;, равную нулю всюду за исключением единственной
точки &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-97.png&quot; style=&quot;{% style_stub zdaaaa 97 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (в которой она равна бесконечности) и моделирующую идеальный импульс [бесконечно
малой продолжительности], то с помощью &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-98.png&quot; style=&quot;{% style_stub aeaaaa 98 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; мы получим импульсный отклик &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-99.png&quot; style=&quot;{% style_stub beaaaa 99 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Это выражение с использованием уравнений &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-100.png&quot; style=&quot;{% style_stub ceaaaa 100 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-101.png&quot; style=&quot;{% style_stub deaaaa 101 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; приводит к
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-102.png&quot; style=&quot;{% style_stub eeaaaa 102 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Интересно, что несмотря на &lt;em&gt;de-facto&lt;/em&gt; определение
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-103.png&quot; style=&quot;{% style_stub feaaaa 103 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; интеграл по всему пространству равен 1:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-104.png&quot; style=&quot;{% style_stub geaaaa 104 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Причем из этого уравнения следует
&lt;em&gt;фильтрующее свойство&lt;/em&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-105.png&quot; style=&quot;{% style_stub heaaaa 105 inline %}&quot; class=&quot;latex&quot;&gt;-функции&lt;/span&gt; (для некоторой функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-106.png&quot; style=&quot;{% style_stub ieaaaa 106 inline %}&quot; class=&quot;latex&quot;&gt;):&lt;/span&gt;
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-107.png&quot; style=&quot;{% style_stub jeaaaa 107 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство фильтрующего свойства.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-108.png&quot; style=&quot;{% style_stub keaaaa 108 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; при &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-109.png&quot; style=&quot;{% style_stub leaaaa 109 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то интеграл &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-110.png&quot; style=&quot;{% style_stub meaaaa 110 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не зависит от значений &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-111.png&quot; style=&quot;{% style_stub neaaaa 111 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
при &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-112.png&quot; style=&quot;{% style_stub oeaaaa 112 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а зависит только от значения в единственной точке &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-113.png&quot; style=&quot;{% style_stub peaaaa 113 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Поэтому функцию
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-114.png&quot; style=&quot;{% style_stub qeaaaa 114 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно просто заменить константой &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-115.png&quot; style=&quot;{% style_stub reaaaa 115 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; которую можно будет вынести
за знак интеграла: &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-116.png&quot; style=&quot;{% style_stub seaaaa 116 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Но
теперь оставшийся интеграл равен единице (несмотря на другие переменные, это всё-равно интеграл
от дельта-функции по всему пространству) и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-117.png&quot; style=&quot;{% style_stub teaaaa 117 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; превращается в тождество &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-118.png&quot; style=&quot;{% style_stub ueaaaa 118 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-119.png&quot; style=&quot;{% style_stub veaaaa 119 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Возможно расчитать отклик &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-120.png&quot; style=&quot;{% style_stub weaaaa 120 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; системы на некоторый входной сигнал &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-121.png&quot; style=&quot;{% style_stub xeaaaa 121 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не зная
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-122.png&quot; style=&quot;{% style_stub yeaaaa 122 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в явном виде, а только располагая импульсным откликом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-123.png&quot; style=&quot;{% style_stub zeaaaa 123 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Именно (используется коммутативность
свертки): &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-124.png&quot; style=&quot;{% style_stub afaaaa 124 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Демонстрация адекватности свертки для описания [сдвигово-инвариантных] линейный систем может быть
произведена с помощью доказательства справедливости уравнения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-125.png&quot; style=&quot;{% style_stub bfaaaa 125 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Набросок доказательства.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Подстановка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-126.png&quot; style=&quot;{% style_stub cfaaaa 126 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в выражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-127.png&quot; style=&quot;{% style_stub dfaaaa 127 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для свертки даёт:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-128.png&quot; style=&quot;{% style_stub efaaaa 128 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Используя выражаемую уравнением &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-129.png&quot; style=&quot;{% style_stub ffaaaa 129 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; линейность, т.е. вынося &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-130.png&quot; style=&quot;{% style_stub gfaaaa 130 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; за знак интеграла, получаем:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/2-131.png&quot; style=&quot;{% style_stub hfaaaa 131 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Применяя фильтрующее свойство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-132.png&quot; style=&quot;{% style_stub ifaaaa 132 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; дельта-функции, а также определение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-133.png&quot; style=&quot;{% style_stub jfaaaa 133 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; как отображения
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-134.png&quot; style=&quot;{% style_stub kfaaaa 134 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; приходим к уравнению &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-135.png&quot; style=&quot;{% style_stub lfaaaa 135 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Таким образом, справедливость &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-136.png&quot; style=&quot;{% style_stub mfaaaa 136 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; доказана. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/2-137.png&quot; style=&quot;{% style_stub nfaaaa 137 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;section-5&quot;&gt;Заключение, выводы&lt;/h1&gt;
&lt;p&gt;Как видно из вышеприведенных примеров, свертка является достаточно естественной концепцией,
всем хорошо знакомой по умножению многозначных чисел (подходит для демонстрации линейной свертки).
Теорема о свертке тоже выглядит достаточно просто (и подходит для демонстрации циклической свертки).
Причем из обоих примеров сразу становится понятным происхождение «необычных» индексов в
определении свертки последовательностей (и не менее «необычных» аргументов у функций в непрерывном
случае).&lt;/p&gt;
&lt;p&gt;Интересно, что корреляция, не требующая отражения графика одной из функций при наглядной интерпретации,
и могущая быть записанной без вычитания в выражениях для индексов/аргументов, оказывается даже более
отдаленной от прикладного, «бытового» применения математики; а аналог теоремы о свертке в случае
с корреляцией требует использования  лишней операции комплексного сопряжения.&lt;/p&gt;
&lt;p&gt;Наконец, продемонстрирована самосогласованность операции свертки при описании достаточно большого
класса реальных систем (со свойствами линейности и сдвиговой инвариантности).&lt;/p&gt;
&lt;h1 id=&quot;section-6&quot;&gt;Ссылки&lt;/h1&gt;
&lt;ul class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;wiki-convolution&quot;&gt;1. &lt;/span&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/convolution&quot;&gt;http://en.wikipedia.org/wiki/convolution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;matters-computational&quot;&gt;2. Arndt J. Matters Computational&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-fft&quot;&gt;3. &lt;/span&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/Fast_Fourier_Transform&quot;&gt;http://en.wikipedia.org/wiki/Fast_Fourier_Transform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-cross-correlation&quot;&gt;4. &lt;/span&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/cross-correlation&quot;&gt;http://en.wikipedia.org/wiki/cross-correlation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-linear-time-invariant-system&quot;&gt;5. &lt;/span&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/linear_time-invariant_system&quot;&gt;http://en.wikipedia.org/wiki/linear_time-invariant_system&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-delta-function-en&quot;&gt;6. &lt;/span&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/Dirac_delta_function&quot;&gt;http://en.wikipedia.org/wiki/Dirac_delta_function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-delta-function-ru&quot;&gt;7. &lt;/span&gt; &lt;a href=&quot;http://ru.wikipedia.org/wiki/дельта-функция&quot;&gt;http://ru.wikipedia.org/wiki/дельта-функция&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Занимательное квайноводство. Часть I.</title>
   <link href="http://circiter.tk/quinelogy-part-1"/>
   <updated>2022-05-07T02:05:34+00:00</updated>
   <id>http://circiter.tk/quinelogy-part-1</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;Введение в квайнологию&lt;/h1&gt;
&lt;p&gt;Всем известно «стандартное» упражнение в программировании, заключающееся в написании
программы, печатающей свой собственный текст. За такими самореплицирующимися программами
достаточно давно закрепилось название «квайн» (также встречаются варианты
написания/произношения «куайн», «квин», «куин») введенное в известной книге Хофштадтера
[26] в честь философа Куайна (Уиллард Ван Орман Куайн = Willard Van Orman Quine) и его
«парадокса Куайна» [15].&lt;/p&gt;
&lt;p&gt;Сами квайны при этом появились раньше. Может быть их историю следовало бы вести с работ фон
Неймана по самореплицирующимся [клеточным] автоматам [9, 48] или даже с работ Чёрча и Хаскеля…&lt;/p&gt;
&lt;p&gt;Квайны являются немного парадоксальными программами, в соответствии с бытовой интуицией не
могущими существовать, – ведь может показаться, что программа не может вывести текст, имеющий
длину, равную длине самой программы (должно остаться место для кода, выполняющего печать). И тем
не менее они существуют (и не требуют сжатия данных, которое, в соответствии с фундаментальной
теоремой компрессии, не всегда возможно).&lt;/p&gt;
&lt;p&gt;Более того, теория вычислимости говорит, что квайны можно написать на &lt;em&gt;любом&lt;/em&gt; [достаточно
выразительном] языке программирования. На деле, конечно, сложность написания и размер
результирующего кода сильно варьируются от языка к языку.&lt;/p&gt;
&lt;p&gt;В качестве примеров квайнов можно привести такие поделки (авторы мне не известны):&lt;/p&gt;
&lt;p&gt;Квайн на lisp:&lt;/p&gt;
&lt;div class=&quot;language-lisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Квайн на стековом rpn-языке форт (forth):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s&amp;quot; 2dup 115 emit 34 emit 32 emit type 34 emit type cr bye&amp;quot;
2dup 115 emit 34 emit 32 emit type 34 emit type cr bye
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Это одна длинная строка, могущая отображаться на нескольких экранных строках.)&lt;/p&gt;
&lt;p&gt;Квайн на экспериментальном функциональном стековом rpn-языке joy [32]:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;dup.putchars.10 putch.&amp;quot;
dup.putchars.10 putch.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Квайн для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-0.png&quot; style=&quot;{% style_stub ofaaaa 0 inline %}&quot; class=&quot;latex&quot;&gt;-исчисления(почти&lt;/span&gt; то же, что и выше на lisp): &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-1.png&quot; style=&quot;{% style_stub pfaaaa 1 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;В стандартной библиотеке языка C есть функция форматированного вывода &lt;code&gt;printf&lt;/code&gt;, которая может
быть использована [в качестве суррогата &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-2.png&quot; style=&quot;{% style_stub qfaaaa 2 inline %}&quot; class=&quot;latex&quot;&gt;-функции]&lt;/span&gt; для внедрения текста программы в него
самого; что-то вроде &lt;code&gt;printf(f, f)&lt;/code&gt;, только с учетом технических сложностей с вложенными
кавычками для обрамления строк. По этому принципу построен такой известный однострочный
миниквайн на C (здесь не указан заголовочный файл &lt;code&gt;stdio.h&lt;/code&gt;, в котором определена &lt;code&gt;printf&lt;/code&gt;, но в
таком виде этот код всё-равно компилируется и работает):&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;char*f=%c%s%c;main(){printf(f,34,f,34,10);}%c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Многие квайны (в т.ч. большинство из приведенных выше) злоупотребляют экранированием строк,
специальными кодами символов (зависящими от используемой в системе кодировки, e.g. ASCII) и
библиотечными функциями подстановки (замены подстрок), «скрывающими» существенную часть
происходящих процессов. «Идеологически» более чистым подходом представляется ограничение
строковых манипуляций конкатенацией строк при одновременной минимизации экранирований. Неплохим
образчиком подобной стратегии написания квайнов является квайн (на pascal’е) от Dan Hoey (взятый
мною из [50]):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;program s;const bbb='program s;const bbb';a='a';b='b';bb=');writeln(';
aa='''';ab='=''';ba=''';';
aaa='begin writeln(bbb,ab,bbb,ba,a,ab,a,ba,b,ab,b,ba,b,b,ab,bb,ba';
aba='a,a,ab,aa,aa,ba,a,b,ab,ab,aa,ba,b,a,ab,aa,ba,ba';
abb='a,a,a,ab,aaa,ba);writeln(a,b,a,ab,aba,ba);writeln(a,b,b,ab,abb,ba';
baa='b,a,a,ab,baa,ba);writeln(b,a,b,ab,bab,ba);writeln(aaa,bb';
bab='aba,bb);writeln(abb);writeln(bb,baa);writeln(bb,bab)end.';
begin writeln(bbb,ab,bbb,ba,a,ab,a,ba,b,ab,b,ba,b,b,ab,bb,ba);writeln(
a,a,ab,aa,aa,ba,a,b,ab,ab,aa,ba,b,a,ab,aa,ba,ba);writeln(
a,a,a,ab,aaa,ba);writeln(a,b,a,ab,aba,ba);writeln(a,b,b,ab,abb,ba
);writeln(b,a,a,ab,baa,ba);writeln(b,a,b,ab,bab,ba);writeln(aaa,bb
);writeln(aba,bb);writeln(abb);writeln(bb,baa);writeln(bb,bab)end.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(N.B., на самом деле этот квайн записывается в одну строку.)&lt;/p&gt;
&lt;p&gt;Неплохое введение в написание квайнов можно найти, например, в [1, 30]; а неплохую коллекцию
– в [30, 18].&lt;/p&gt;
&lt;h2 id=&quot;emversusem-&quot;&gt;Искусство &lt;em&gt;versus&lt;/em&gt; ремесло&lt;/h2&gt;
&lt;p&gt;Основной причиной проведения небольшого эксперимента, ставшего основой настоящего сообщения,
явилось желание написать, или, точнее говоря, попробовать написать квайн на входном языке
поточного редактора sed. Применение поисковых систем для поиска уже имеющихся решений привело к
обнаружению квайна &lt;code&gt;quine.sed&lt;/code&gt; [17] из «музея квайнов» [18] (автор: Tsuyusato Kitsune):&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;s/^/s11^113311;h;s221[1]221122g;s112[2]11222211g;G;s11^22([^3]*22)3322([^22n]*22).22(.*22)$1122122322211/;h;s\1[1]\/\g;s/2[2]/\\/g;G;s/^\([^3]*\)33\([^\n]*\).\(.*\)$/\1\3\2/&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;(N.B., это одна строка текста.)&lt;/p&gt;
&lt;p&gt;Вряд ли у меня вышло бы улучшить (например, сократить) этот квайн. Более того, самостоятельная
попытка написать нечто подобное тоже не увенчалась успехом. Поэтому было принято решение
действовать более систематичным образом и воспользоваться уже имеющимся в распоряжении
математики арсеналом готовых теоретических средств.&lt;/p&gt;
&lt;p&gt;Вторая рекурсивная теорема Клини имеет своим следствием утверждение о существовании квайна для
любого языка программирования, а конструктивный характер её доказательства дает готовый рецепт
для написания такого «саморепликатора» (ниже об этом будет написано подробнее).&lt;/p&gt;
&lt;p&gt;Стандартные пособия по теории вычислимости нередко не ограничиваются лишь утверждениями о
существовании квайнов, и даже приводят конкретные примеры их конструирования, правда, выбирая
при этом, как правило, «удобные» языки программирования, например, прагматические реализации
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-3.png&quot; style=&quot;{% style_stub rfaaaa 3 inline %}&quot; class=&quot;latex&quot;&gt;-исчисления,&lt;/span&gt; такие как lisp и его производные.&lt;/p&gt;
&lt;p&gt;Попадались интересные исключения, e.g. [35, 36], но для слишком абстрактных машин. Поэтому я
решил повторить классический эксперимент с конструированием квайна на основе доказательства
рекурсивной теоремы Клини, но выполнить этот эксперимент на языке sed (кстати, всё-равно
оказавшемся достаточно удобным для этой задачи, в основном из-за возможности объединения
скриптов их конкатенацией).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Обновление (август, 2020):&lt;/strong&gt; &lt;em&gt;Уже после написания черновика этого сообщения, примеры
применения второй рекурсивной теоремы Клини к практическим языкам программирования всё-таки
отыскались на просторах интернета. В [53] можно найти генератор квайнов на JavaScript
(ECMAScript), а в [54] – похожий генератор, но для C++. Причем в последнем примере, указанная
утилита позиционируется как достаточно общий инструмент для добавления рефлексивных возможностей
к языку, с ограниченной штатной рефлексией (i.e., сгенерированная программа может как просто
печатать свой собственный текст, так и вычислять произвольные функции от него, скажем, находить
свою длину).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Возможно читателю также будет интересна аналогичная утилита [55], преобразующая произвольную
программу на C в квайн.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Результаты эксперимента говорят о возможности автоматической, или «нетворческой» генерации
квайнов, в том числе и на sed.&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;Эффективность и выбор названия серии сообщений.&lt;/h2&gt;
&lt;p&gt;Быть может некоторым показалось бы несколько более благозвучным слово вроде «квайноделия», но
«квайноводство» подходит куда лучше… От части потому, что, как и обещают стандартные вводные
курсы по теории вычислимости, квайны, конструируемые прямым применением [второй рекурсивной]
теоремы Клини, обычно получаются, мягко говоря, «неэффективными», как по времени, так и по
пространству. Ещё одной метрикой эффективности может быть отношения объёмов данных и кода;
специально я не исследовал этот вопрос, так что не могу сказать как с этим обстоят дела у
автоматически сгенерированных квайнов, но неверняка неоптимально. :)&lt;/p&gt;
&lt;h2 id=&quot;section-2&quot;&gt;Постановка задачи&lt;/h2&gt;
&lt;p&gt;Пусть квайн хранится в исполняемом файле &lt;code&gt;quine&lt;/code&gt;, полученным компиляцией его исходного текста из
файла &lt;code&gt;quine.source&lt;/code&gt;. Для меня достаточно чисто формального выполнения следующего теста:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./quine any_argument &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; quine.output
diff quine.source quine.output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;или аналогичного теста для интерпретируемого языка (здесь &lt;code&gt;interpreter&lt;/code&gt; – исполняемый файл
интерпретатора или аналогичная внутренняя команда оболочки):&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interpreter quine.source any_argument &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; quine.output
diff quine.source quine.output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Для sed это соответствует следующему тесту:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;any_argument | &lt;span class=&quot;nb&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; quine.sed &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; quine.output
diff quine.sed quine.output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Проверку на тривиальность (в частности, на пустоту) можно выполнять и «вручную» (из-за
плохой формализуемости и некоторой субъективности).&lt;/p&gt;
&lt;p&gt;То есть, квайн конечного размера (скажем, помещающийся на жесткий диск) должен напечать свой
собственный текст за конечное (и разумное время). Абсолютно не важно, будут ли исходный текст и
скомпилированная программа весить несколько килобайт или несколько мегабайт. Гораздо важнее,
чтобы квайн был истинным, т.е. был непустым, «содержательным», и не использовал «нечестные»
рефлексивные возможности (вроде чтения своего исходного текста из файла).&lt;/p&gt;
&lt;h1 id=&quot;section-3&quot;&gt;Вводные замечания&lt;/h1&gt;
&lt;p&gt;В теории вычислимости особо важное место занимают несколько интересных теорем о вычислимых
функциях. В этом сообщении я хотел бы кратко рассказать об этих теоремах и о некоторых их
применениях.&lt;/p&gt;
&lt;p&gt;Для некоторой программы с текстом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-4.png&quot; style=&quot;{% style_stub sfaaaa 4 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; соответствующую ей (частичную) вычислимую функцию обычно
обозначают как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-5.png&quot; style=&quot;{% style_stub tfaaaa 5 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; однако, воизбежание нагромождения нижних индексов далее будет
использоваться несколько более удобное обозначение, широко применяющееся при изучении семантики
языков программирования, а именно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-6.png&quot; style=&quot;{% style_stub ufaaaa 6 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Обычно, в теории алгоритмов (теории вычислимости, теории рекурсии) говорят о [гёделевском]
номере программы, а не о её тексте, но далее будет использоваться более наглядное и привычное,
по крайней мере для программистов, слово &lt;em&gt;текст&lt;/em&gt;, иногда даже &lt;em&gt;исходный код&lt;/em&gt;, без прямого отсыла
к понятию &lt;em&gt;нумерации&lt;/em&gt; из теории вычислимости. Более того, вразрез с традиционным
словоупотреблением, в настоящем сообщении нередко программа и её текст будут отождествляться, –
здесь это просто одно и то же. (Краткости и простоты ради, это сообщение будет вообще несколько
неформальным и не строгим.)&lt;/p&gt;
&lt;p&gt;При одновременном рассмотрении нескольких языков программирования, как, например, при
работе с трансляторами, можно указывать язык программирования в нижнем индексе
семантических скобок, e.g., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-7.png&quot; style=&quot;{% style_stub vfaaaa 7 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (Кстати, в литературе
встречается и более необычная нотация, например, вообще не используюшая какие-либо индексы и
скобки, для экономии места.)&lt;/p&gt;
&lt;p&gt;Символом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-8.png&quot; style=&quot;{% style_stub wfaaaa 8 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет обозначено незавершающееся вычисление, т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-9.png&quot; style=&quot;{% style_stub xfaaaa 9 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – это значение
бесконечного цикла. Равенство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-10.png&quot; style=&quot;{% style_stub yfaaaa 10 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; есть сокращение
для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-11.png&quot; style=&quot;{% style_stub zfaaaa 11 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (Подразумевается, что
для некоторых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-12.png&quot; style=&quot;{% style_stub agaaaa 12 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; может выполнятся &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-13.png&quot; style=&quot;{% style_stub bgaaaa 13 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-14.png&quot; style=&quot;{% style_stub cgaaaa 14 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-4&quot;&gt;Теорема об универсальной функции&lt;/h2&gt;
&lt;p&gt;Сначала хотелось бы упомянуть теорему о существовании универсальной программы, а фактически о
возможности написания интерпретаторов для любых подходящих (Тьюринг-полных) языков
программирования, причем подразумевается, что интерпретатор пишется на его же входном языке.
Более формально, эта теорема утверждает, что существуют вычислимая функция — &lt;em&gt;универсальная
функция&lt;/em&gt; — &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-15.png&quot; style=&quot;{% style_stub dgaaaa 15 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а также соответствующая ей программа-интерпретатор &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-16.png&quot; style=&quot;{% style_stub egaaaa 16 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такие, что для любой
программы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-17.png&quot; style=&quot;{% style_stub fgaaaa 17 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; интерпретатор может быть запущен с несколькими аргументами, первый из которых
равен &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-18.png&quot; style=&quot;{% style_stub ggaaaa 18 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а оставшиеся суть просто аргументы для этой программы. Так запущенный интерпретатор
должен возвратить тот же результат, что и сама программа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-19.png&quot; style=&quot;{% style_stub hgaaaa 19 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; при тех же аргументах.&lt;/p&gt;
&lt;p&gt;То есть, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-20.png&quot; style=&quot;{% style_stub igaaaa 20 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Набросок доказательства.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Доказательство может проводится просто предъявлением готового интерпретатора в виде машины
Тьюринга, т.е. путем построение т.н. универсальной машины Тьюринга, симулирующей работу любой
другой машины Тьюринга. Понятно, что можно использовать и любую другую модель вычислений, e.g.,
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-21.png&quot; style=&quot;{% style_stub jgaaaa 21 inline %}&quot; class=&quot;latex&quot;&gt;-исчисление.&lt;/span&gt; Но здесь, для краткости, аргументация будет менее конструктивной и более
абстрактной.&lt;/p&gt;
&lt;p&gt;Естественно считать программами куски текста (i.e., строки) на некотором языке программирования.
Пусть на строках определён обычный порядок &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-22.png&quot; style=&quot;{% style_stub kgaaaa 22 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а именно, для строк &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-23.png&quot; style=&quot;{% style_stub lgaaaa 23 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-24.png&quot; style=&quot;{% style_stub mgaaaa 24 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-25.png&quot; style=&quot;{% style_stub ngaaaa 25 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-26.png&quot; style=&quot;{% style_stub ogaaaa 26 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (i.e., сравниваются длины) или, в случае &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-27.png&quot; style=&quot;{% style_stub pgaaaa 27 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-28.png&quot; style=&quot;{% style_stub qgaaaa 28 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; лексикографически
предшествует &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-29.png&quot; style=&quot;{% style_stub rgaaaa 29 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.о., все программы можно отсортировать относительно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-30.png&quot; style=&quot;{% style_stub sgaaaa 30 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; получив в результате
упорядоченную последовательность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-31.png&quot; style=&quot;{% style_stub tgaaaa 31 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Будем считать, что для любой программы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-32.png&quot; style=&quot;{% style_stub ugaaaa 32 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно
построить специализированное вычислительное устройство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-33.png&quot; style=&quot;{% style_stub vgaaaa 33 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; преобразующее входные данные &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-34.png&quot; style=&quot;{% style_stub wgaaaa 34 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в
выходные &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-35.png&quot; style=&quot;{% style_stub xgaaaa 35 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (эта нотация, по-факту, означает запуск устройства &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-36.png&quot; style=&quot;{% style_stub ygaaaa 36 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с аргументом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-37.png&quot; style=&quot;{% style_stub zgaaaa 37 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Теперь можно определить функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-38.png&quot; style=&quot;{% style_stub ahaaaa 38 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Полнота по Тьюрингу позволяет утверждать, что
для любой вычислимой функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-39.png&quot; style=&quot;{% style_stub bhaaaa 39 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; существует вычислительное устройство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-40.png&quot; style=&quot;{% style_stub chaaaa 40 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такое, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-41.png&quot; style=&quot;{% style_stub dhaaaa 41 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; а раз в последовательности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-42.png&quot; style=&quot;{% style_stub ehaaaa 42 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; есть вычислительные устройства для всех
программ, то найдётся число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-43.png&quot; style=&quot;{% style_stub fhaaaa 43 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такое, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-44.png&quot; style=&quot;{% style_stub ghaaaa 44 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Получается, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-45.png&quot; style=&quot;{% style_stub hhaaaa 45 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е.,
функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-46.png&quot; style=&quot;{% style_stub ihaaaa 46 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; может использоваться вместо любой вычислимой функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-47.png&quot; style=&quot;{% style_stub jhaaaa 47 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; если известен её номер &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-48.png&quot; style=&quot;{% style_stub khaaaa 48 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt;
другими словами, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-49.png&quot; style=&quot;{% style_stub lhaaaa 49 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – универсальная функция.&lt;/p&gt;
&lt;p&gt;Осталось показать, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-50.png&quot; style=&quot;{% style_stub mhaaaa 50 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; вычислима. Для этого надо написать интерпретатор &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-51.png&quot; style=&quot;{% style_stub nhaaaa 51 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и сконструирвать
соответствующее вычислительное устройство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-52.png&quot; style=&quot;{% style_stub ohaaaa 52 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; по первому аргументу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-53.png&quot; style=&quot;{% style_stub phaaaa 53 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; командной
строки извлекающее устройство с индексом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-54.png&quot; style=&quot;{% style_stub qhaaaa 54 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из последовательности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-55.png&quot; style=&quot;{% style_stub rhaaaa 55 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и запускающее его,
передавая ему при запуске остальные свои аргументы. Т.е., должно выполняться &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-56.png&quot; style=&quot;{% style_stub shaaaa 56 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Видно, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-57.png&quot; style=&quot;{% style_stub thaaaa 57 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – устройство, вычисляющее &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-58.png&quot; style=&quot;{% style_stub uhaaaa 58 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-59.png&quot; style=&quot;{% style_stub vhaaaa 59 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – программа, это
делающая. Таким образом, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-60.png&quot; style=&quot;{% style_stub whaaaa 60 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – вычислимая универсальная функция. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-61.png&quot; style=&quot;{% style_stub xhaaaa 61 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;N.B., сама теорема не зависит от языка программирования и требует лишь его полноты по Тьюрингу,
т.е. возможности написать для любой вычислимой функции программу, её вычисляющую; да, звучит
немного тавтологично, и, тем не менее, есть языки не являющиеся Тьюринг-полными: на них нельзя
реализовать некоторые программы, легко пишущиеся на каком-нибудь универсальном, Тьюринг-полном
языке. Существуют ли программы, не могущие быть перенесены на машину Тьюринга или любую
эквивалентную ей машину, но могущие выполняться на каком-нибудь другом компьютере – интересный
философский вопрос; тезис Чёрча-Тьюринга говорит, что нет, таких программ не существует (и
действительно, все известные теоретические конструкции более мощных компьютеров конфликтуют с
теми или иными физическими законами и в это вселенной работать не могут).&lt;/p&gt;
&lt;p&gt;А вот существование вычислимой универсальной функции, по-видимому, не влечёт за собой полноты по
Тьюрингу – если взять некоторый подходящий неуниверсальный язык, то можно действовать как в
вышеприведенном наброске доказательства, т.е. можно сгенерировать и отсортировать все программы
[для этого языка] и вычислительные устройства, а потом определить функцию, выбирающую и
использующую нужное устройство по его номеру. Если выбранный язык будет достаточно богат, чтобы
на нём можно было выразить такой выбор и запуск, то мы получим вычислимую универсальную функцию,
правда, универсальную не для всех вычислимых функций, а только для функций, реализуемых на таком
языке.&lt;/p&gt;
&lt;p&gt;Фактически, теорема об универсальной функции говорит, что частичная (т.е. не являющаяся всюду
определённой) функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-62.png&quot; style=&quot;{% style_stub yhaaaa 62 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; от аргументов &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-63.png&quot; style=&quot;{% style_stub zhaaaa 63 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; сама
является вычислимой (или т.н. частично рекурсивной) функцией &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-64.png&quot; style=&quot;{% style_stub aiaaaa 64 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; от аргументов
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-65.png&quot; style=&quot;{% style_stub biaaaa 65 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (добавился ещё один аргумент).&lt;/p&gt;
&lt;p&gt;Использование теоремы об универсальной функции в данном сообщении будет весьма ограниченным;
здесь без неё можно было бы и обойтись (если не считать теорему Роджерса, см. ниже). И всё-же
она в определённые моменты будет важна. Кроме этого, стоит обратить внимание на использованное в
доказательстве разделение на программы (тексты программ), вычислительные устройства и их номера,
– нам пришлось использовать устройства, чтобы подчеркнуть механистичность и физическую
реализуемость вычислений, текстовое представление программ, чтобы иметь возможность сортировать
и нумеровать программы/устройства, и, наконец, пришлось выбрать конкретный (но не единственный)
способ такой нумерации с помощью сортировки по возрастанию относительно порядка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-66.png&quot; style=&quot;{% style_stub ciaaaa 66 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;В дальнейшем такое разделение представлений будет лишним и поэтому, как я уже говорил ранее,
тексты программ, программы и их номера будут отождествляться. Сам конкретный способ нумерации
можно будет считать заданием языка программирования, хотя на практике же удобно отождествлять
язык программирования с семантической функцией &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-67.png&quot; style=&quot;{% style_stub diaaaa 67 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
сопоставляющей программе &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-68.png&quot; style=&quot;{% style_stub eiaaaa 68 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-69.png&quot; style=&quot;{% style_stub fiaaaa 69 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-70.png&quot; style=&quot;{% style_stub giaaaa 70 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – множество, над которым определены
вычислимые функции (в большинстве случаев можно считать &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-71.png&quot; style=&quot;{% style_stub hiaaaa 71 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; или с парой &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-72.png&quot; style=&quot;{% style_stub iiaaaa 72 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (В следующей части этой серии сообщений, я постараюсь уделить
должное внимание понятию нумерации, но здесь оно свою полезность, похоже, пока исчерпало.)&lt;/p&gt;
&lt;p&gt;N.B., Также подразумевается, что паре значений &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-73.png&quot; style=&quot;{% style_stub jiaaaa 73 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно сопоставить взаимно однозначным
образом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-74.png&quot; style=&quot;{% style_stub kiaaaa 74 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (причем отображение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-75.png&quot; style=&quot;{% style_stub liaaaa 75 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; вычислимо). Это позволяет определять
функции с большим количеством аргументов через функции с меньшим количеством, например
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-76.png&quot; style=&quot;{% style_stub miaaaa 76 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.о., теоретически можно вообще
обходиться только одноместными функциями, но из соображений удобства, к такому минимализму
прибегать, надеюсь, не придётся.&lt;/p&gt;
&lt;h2 id=&quot;s-m-n--&quot;&gt;S-m-n теорема Клини&lt;/h2&gt;
&lt;p&gt;Другой, не менее важной теоремой является т.н. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-77.png&quot; style=&quot;{% style_stub niaaaa 77 inline %}&quot; class=&quot;latex&quot;&gt;-теорема&lt;/span&gt; (известная также как теорема о
параметризации или итеративная теорема) [14, 3], утверждающая, что может быть написана
программа, уменьшающая количество аргументов путем фиксации значений некоторых из них: для
программы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-78.png&quot; style=&quot;{% style_stub oiaaaa 78 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; реализующей функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-79.png&quot; style=&quot;{% style_stub piaaaa 79 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-80.png&quot; style=&quot;{% style_stub qiaaaa 80 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; аргументами и для заданных значений
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-81.png&quot; style=&quot;{% style_stub riaaaa 81 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для первых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-82.png&quot; style=&quot;{% style_stub siaaaa 82 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; аргументов существует программа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-83.png&quot; style=&quot;{% style_stub tiaaaa 83 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для специализированной
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-84.png&quot; style=&quot;{% style_stub uiaaaa 84 inline %}&quot; class=&quot;latex&quot;&gt;-местной&lt;/span&gt; функции, удовлетворяющая &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-85.png&quot; style=&quot;{% style_stub viaaaa 85 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для любых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-86.png&quot; style=&quot;{% style_stub wiaaaa 86 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Также существует вычислимая (примитивно рекурсивная при определённом выборе языка
программирования) всюду определённая функция, — собственно, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-87.png&quot; style=&quot;{% style_stub xiaaaa 87 inline %}&quot; class=&quot;latex&quot;&gt;-функция,&lt;/span&gt; — преобразующая
программу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-88.png&quot; style=&quot;{% style_stub yiaaaa 88 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в программу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-89.png&quot; style=&quot;{% style_stub ziaaaa 89 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;То есть, для программы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-90.png&quot; style=&quot;{% style_stub ajaaaa 90 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-91.png&quot; style=&quot;{% style_stub bjaaaa 91 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Далее пригодится частный случай &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-92.png&quot; style=&quot;{% style_stub cjaaaa 92 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с фиксацией всего одного из двух аргументов.&lt;/p&gt;
&lt;p&gt;Нетрудно видеть, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-93.png&quot; style=&quot;{% style_stub djaaaa 93 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; теорема, по-существу, реализует частичные вычисления (специализацию
программ) [4, 5], т.е. дает возможность выполнить часть вычислений, зависящих от фиксируемого
аргумента(-ов), заранее, до выполнения программы (что может быть использовано, например, для
оптимизации кода). Есть некоторое сходство между частичной специализацией и &lt;em&gt;каррингом&lt;/em&gt; из
функционального программирования.&lt;/p&gt;
&lt;p&gt;Доказательство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-94.png&quot; style=&quot;{% style_stub ejaaaa 94 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; теоремы конструктивно и может быть основано на явном выписывании
программы (или на явном построении машины Тьюринга), присваивающей определенные значения
исключаемым аргументам и обеспечивающей запуск программы при поступлении недостающих данных
(такого тривиального алгоритма недостаточно для написания оптимизирующего специализатора; но он
может быть улучшен).&lt;/p&gt;
&lt;p&gt;(Само доказательство здесь приводится не будет, а интересующимся рекомендуется обратиться к
первоисточникам или более современным материалам по теории вычислимости.)&lt;/p&gt;
&lt;p&gt;Стоит отметить, что вышеприведенные теоремы во многом схожи, и даже в некотором смысле
«взаимо-обратны» – теорема об универсальной функции преобразует «статический» параметр —
программу — в «динамический» аргумент, который может затем принимать любое значение;
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-95.png&quot; style=&quot;{% style_stub fjaaaa 95 inline %}&quot; class=&quot;latex&quot;&gt;-теорема,&lt;/span&gt; напротив, преобразует динамический аргумент в статический, приписывая ему
априори заданное значение.&lt;/p&gt;
&lt;p&gt;Эта симметрия хорошо видна если выписать ключевые уравнения обоих теорем одно под другим
(здесь, для краткости, используется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-96.png&quot; style=&quot;{% style_stub gjaaaa 96 inline %}&quot; class=&quot;latex&quot;&gt;-функция):&lt;/span&gt;
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-97.png&quot; style=&quot;{% style_stub hjaaaa 97 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;В некотором смысле, они при этом всё-же различны – кроме структурных различий формул,
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-98.png&quot; style=&quot;{% style_stub ijaaaa 98 inline %}&quot; class=&quot;latex&quot;&gt;-функцию&lt;/span&gt; можно считать примитивно рекурсивной (для её реализации не обязательно нужен
универсальный язык программирования).&lt;/p&gt;
&lt;h1 id=&quot;section-5&quot;&gt;Неподвижные точки вычислимых функций&lt;/h1&gt;
&lt;p&gt;Далее описывается теорема о существовании неподвижных точек вычислимых функций, известная также
как вторая рекурсивная теорема Клини [14]; здесь приводится несколько упрощенная её версия,
впрочем, полностью достаточная для решения поставленных задач.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Вторая рекурсивная теорема Клини.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Для любой вычислимой функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-99.png&quot; style=&quot;{% style_stub jjaaaa 99 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; существует программа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-100.png&quot; style=&quot;{% style_stub kjaaaa 100 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; («неподвижная точка»),
такая, что &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-101.png&quot; style=&quot;{% style_stub ljaaaa 101 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Напишем программу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-102.png&quot; style=&quot;{% style_stub mjaaaa 102 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такую, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-103.png&quot; style=&quot;{% style_stub njaaaa 103 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Тогда
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-104.png&quot; style=&quot;{% style_stub ojaaaa 104 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Действительно, если запустим &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-105.png&quot; style=&quot;{% style_stub pjaaaa 105 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для какого-нибудь аргумента &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-106.png&quot; style=&quot;{% style_stub qjaaaa 106 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то получим &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-107.png&quot; style=&quot;{% style_stub rjaaaa 107 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; По определению &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-108.png&quot; style=&quot;{% style_stub sjaaaa 108 inline %}&quot; class=&quot;latex&quot;&gt;-функции,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-109.png&quot; style=&quot;{% style_stub tjaaaa 109 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Теперь применим определение для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-110.png&quot; style=&quot;{% style_stub ujaaaa 110 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
получим, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-111.png&quot; style=&quot;{% style_stub vjaaaa 111 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Понятно, что эта цепочка
равенств по транзитивности приводит к &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-112.png&quot; style=&quot;{% style_stub wjaaaa 112 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-113.png&quot; style=&quot;{% style_stub xjaaaa 113 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;В данном сообщении особый интерес представляет частный случай &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-114.png&quot; style=&quot;{% style_stub yjaaaa 114 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; порождающий квайны:
легко видеть, что при этом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-115.png&quot; style=&quot;{% style_stub zjaaaa 115 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то есть программа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-116.png&quot; style=&quot;{% style_stub akaaaa 116 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; при
запуске печатает сама себя, как и положено квайну.&lt;/p&gt;
&lt;p&gt;Иногда пригождается другая версия этой теоремы (при определенном выборе языка, строго
говоря, не эквивалентная теореме Клини; см. [39]), предложенная в [19]:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема Роджерса.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Для любой всюду определённой вычислимой функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-117.png&quot; style=&quot;{% style_stub bkaaaa 117 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; существует неподвижная точка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-118.png&quot; style=&quot;{% style_stub ckaaaa 118 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
т.е. такая программа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-119.png&quot; style=&quot;{% style_stub dkaaaa 119 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-120.png&quot; style=&quot;{% style_stub ekaaaa 120 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Определим функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-121.png&quot; style=&quot;{% style_stub fkaaaa 121 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; так, что &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-122.png&quot; style=&quot;{% style_stub gkaaaa 122 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Теперь напишем программу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-123.png&quot; style=&quot;{% style_stub hkaaaa 123 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такую, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-124.png&quot; style=&quot;{% style_stub ikaaaa 124 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
выполняется &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-125.png&quot; style=&quot;{% style_stub jkaaaa 125 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Утверждается, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-126.png&quot; style=&quot;{% style_stub kkaaaa 126 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
– есть искомая неподвижная точка.&lt;/p&gt;
&lt;p&gt;Подстановка (3) в правую часть (2) дает &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-127.png&quot; style=&quot;{% style_stub lkaaaa 127 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-128.png&quot; style=&quot;{% style_stub mkaaaa 128 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Последнее уравнение при обозначении
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-129.png&quot; style=&quot;{% style_stub nkaaaa 129 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; уже соответствует определению неподвижной точки из условия этой теоремы, т.е.,
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-130.png&quot; style=&quot;{% style_stub okaaaa 130 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-131.png&quot; style=&quot;{% style_stub pkaaaa 131 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;N.B., во второй теореме Клини о рекурсии мы можем выбрать любую вычислимую функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-132.png&quot; style=&quot;{% style_stub qkaaaa 132 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; даже
если она не определена для некоторых значений аргументов (т.е. если соответствующая этой функции
программа зависает при таких входных данных); в теореме Роджерса мы можем выбрать только всюду
определённую функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-133.png&quot; style=&quot;{% style_stub rkaaaa 133 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; иначе в выражении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-134.png&quot; style=&quot;{% style_stub skaaaa 134 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не было бы смысла при
некоторых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-135.png&quot; style=&quot;{% style_stub tkaaaa 135 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Из теоремы Клини и теоремы об универсальной функции следует теорема Роджерса, а из теоремы
Роджерса и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-136.png&quot; style=&quot;{% style_stub ukaaaa 136 inline %}&quot; class=&quot;latex&quot;&gt;-теоремы&lt;/span&gt; – теорема Клини. (Но есть нюансы [39].)&lt;/p&gt;
&lt;p&gt;Для применения теоремы Роджерса к случаю с квайнами, удобно, следуя [2], ввести оператор
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-137.png&quot; style=&quot;{% style_stub vkaaaa 137 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; для данного аргумента конструирующий программу, печатающую этот
аргумент. Т.е. определение оператора &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-138.png&quot; style=&quot;{% style_stub wkaaaa 138 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выглядит как
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-139.png&quot; style=&quot;{% style_stub xkaaaa 139 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; [и почти соответствует одноименному оператору из,
e.g., lisp’а].&lt;/p&gt;
&lt;p&gt;Квайны суть неподвижные точки этого оператора [в смысле формулировки теоремы Роджерса].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-140.png&quot; style=&quot;{% style_stub ykaaaa 140 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – неподвижная точка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-141.png&quot; style=&quot;{% style_stub zkaaaa 141 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-142.png&quot; style=&quot;{% style_stub alaaaa 142 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-143.png&quot; style=&quot;{% style_stub blaaaa 143 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; Подстановка
определения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-144.png&quot; style=&quot;{% style_stub claaaa 144 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в это уравнение дает &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-145.png&quot; style=&quot;{% style_stub dlaaaa 145 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Но &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-146.png&quot; style=&quot;{% style_stub elaaaa 146 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и есть определение
квайна. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-147.png&quot; style=&quot;{% style_stub flaaaa 147 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Примечание.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Вообще, в математике, неподвижной точкой функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-148.png&quot; style=&quot;{% style_stub glaaaa 148 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; обычно называют значение
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-149.png&quot; style=&quot;{% style_stub hlaaaa 149 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такое, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-150.png&quot; style=&quot;{% style_stub ilaaaa 150 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (i.e., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-151.png&quot; style=&quot;{% style_stub jlaaaa 151 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; оставляет &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-152.png&quot; style=&quot;{% style_stub klaaaa 152 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; неизменным). Поэтому «неподвижные точки» из
теорем 1 и 2 не совсем соответствуют такому общепринятому определению.&lt;/p&gt;
&lt;p&gt;Тем не менее, термин &lt;em&gt;неподвижная точка&lt;/em&gt; хорошо отражает суть этих теорем – некоторое
преобразование не меняет значение аргумента, т.е. оставляет его неподвижным (более того, из
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-153.png&quot; style=&quot;{% style_stub llaaaa 153 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; следует &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-154.png&quot; style=&quot;{% style_stub mlaaaa 154 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; i.e. неподвижные точки по
Роджерсу очень близки к обычному определению; обратное, впрочем, неверно: рассмотренные теоремы
о неподвижной точке вовсе не гарантируют наличия обычной неподвижной точки &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-155.png&quot; style=&quot;{% style_stub nlaaaa 155 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такой, что
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-156.png&quot; style=&quot;{% style_stub olaaaa 156 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Я лишь намереваюсь, в рамках этой серии сообщений, для удобства ввести обозначения для этих
«нестандартных» неподвижных точек, а именно, пусть операторы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-157.png&quot; style=&quot;{% style_stub plaaaa 157 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-158.png&quot; style=&quot;{% style_stub qlaaaa 158 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; обозначают неподвижные точки [функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-159.png&quot; style=&quot;{% style_stub rlaaaa 159 inline %}&quot; class=&quot;latex&quot;&gt;]&lt;/span&gt; из теорем Клини и Роджерса,
соответственно. В контексте, требующем работы с несколькими неподвижными точками, эти операторы
будут обозначать множества неподвижных точек. Обозначение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-160.png&quot; style=&quot;{% style_stub slaaaa 160 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет
использоваться для множества традиционных неподвижных точек, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-161.png&quot; style=&quot;{% style_stub tlaaaa 161 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; А так как, в общем случае, неподвижная точка не является единственной, запись типа
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-162.png&quot; style=&quot;{% style_stub ulaaaa 162 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; пусть означает &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-163.png&quot; style=&quot;{% style_stub vlaaaa 163 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (и аналогично для
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-164.png&quot; style=&quot;{% style_stub wlaaaa 164 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-165.png&quot; style=&quot;{% style_stub xlaaaa 165 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Финальное замечание, полностью оправдывающее название «неподвижная точка» для операторов
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-166.png&quot; style=&quot;{% style_stub ylaaaa 166 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-167.png&quot; style=&quot;{% style_stub zlaaaa 167 inline %}&quot; class=&quot;latex&quot;&gt;:&lt;/span&gt; введем оператор &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-168.png&quot; style=&quot;{% style_stub amaaaa 168 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-169.png&quot; style=&quot;{% style_stub bmaaaa 169 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – некоторое двуместное отношение. Тогда
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-170.png&quot; style=&quot;{% style_stub cmaaaa 170 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Другие типы неподвижных точек можно теперь тоже
определять через &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-171.png&quot; style=&quot;{% style_stub dmaaaa 171 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; при должном выборе отношения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-172.png&quot; style=&quot;{% style_stub emaaaa 172 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Например, пусть
отношение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-173.png&quot; style=&quot;{% style_stub fmaaaa 173 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; сравнивает программы по их эффекту, т.е.,
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-174.png&quot; style=&quot;{% style_stub gmaaaa 174 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Тогда
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-175.png&quot; style=&quot;{% style_stub hmaaaa 175 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (N.B., как обычно, запись
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-176.png&quot; style=&quot;{% style_stub imaaaa 176 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; есть сокращение для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-177.png&quot; style=&quot;{% style_stub jmaaaa 177 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;section-6&quot;&gt;Главный эксперимент&lt;/h1&gt;
&lt;p&gt;В [42] приведен следующий эксперимент по квайногенерации на lisp (автор кода мне не известен):&lt;/p&gt;
&lt;div class=&quot;language-lisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; g(x, y) = x&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s11&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; from s-m-n theorem&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s11&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;quote&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;quine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s11&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;; tests&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;quine&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;quine&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(В [47] можно найти невероятную коллекцию аналогичных экспериментов со второй рекурсивный
теоремой Клини, выполненных на языке scheme, диалекте lisp’а.)&lt;/p&gt;
&lt;p&gt;Этот фрагмент кода просто воспроизводит доказательство второй рекурсивной теоремы Клини.
Аналогичным образом я действовал и при повторении этого эксперимента на sed. Соответствующий код
может быть найден в GitHub-репозитории [46]. Конкретно, в репозитории содержится ряд скриптов,
&lt;code&gt;*.sed&lt;/code&gt; и &lt;code&gt;*.sh&lt;/code&gt;, назначение каждого из которых рассмотренно ниже.&lt;/p&gt;
&lt;p&gt;Редактор sed направляет данные со стандартного ввода в основной буфер редактирования (т.н. &lt;em&gt;the
pattern space&lt;/em&gt;). И т.к. мне не известен способ передачи традиционных аргументов командной
строки скрипту для этого редактора, то именно чтение со стандартного ввода было применено в
качестве единственного механизма передачи аргументов. При этом, из-за необходимости передачи
нескольких аргументов, понадобилось либо ввести разделитель/терминатор (e.g. нулевой байт), либо
приписывать значение длины перед каждым аргументом. Как ни странно, изначально был выбран второй
метод, в основном из-за отсутствия необходимости в экранировании разделителя.&lt;/p&gt;
&lt;p&gt;Итак, далее приведен перечень скриптов с их кратким описанием:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;construct-input.sh&lt;/code&gt; принимает на вход список файлов со значениями аргументов и формирует
пакет аргументов из них, т.е. читает эти значения и посылает на стандартный вывод, снабдив
заголовками (длинами). Формат пакета данных с аргументами выглядит так:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;длина аргумента 1&amp;gt;...&amp;lt;длина аргумента n&amp;gt;&amp;lt;аргумент 1&amp;gt;...&amp;lt;аргумент n&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Длина каждого аргумента представлена двоичным шестнадцатиразрядным числом (т.е. этот формат
не отличается универсальностью, но этого хватает для практического применения).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Скрипт &lt;code&gt;s11.sed&lt;/code&gt; [тривиально] реализует &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-178.png&quot; style=&quot;{% style_stub kmaaaa 178 inline %}&quot; class=&quot;latex&quot;&gt;-функцию.&lt;/span&gt; Этот сценарий принимает исходную
программу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-179.png&quot; style=&quot;{% style_stub lmaaaa 179 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в первом аргументе и фиксируемый аргумент &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-180.png&quot; style=&quot;{% style_stub mmaaaa 180 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для неё – во втором своем
аргументе. Результатом работы скрипта будет другая программа, полученная путем приписывания к
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-181.png&quot; style=&quot;{% style_stub nmaaaa 181 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; небольшого «инъектора» – фрагмента кода, встраивающего ранее принятый аргумент &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-182.png&quot; style=&quot;{% style_stub omaaaa 182 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (и
теперь являющийся частью инъектора) перед новым аргументом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-183.png&quot; style=&quot;{% style_stub pmaaaa 183 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (который будет передан
формируемой программе при её запуске). После модификации пакета аргументов, инъектор передаёт
управление программе &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-184.png&quot; style=&quot;{% style_stub qmaaaa 184 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; так, что она «видит» пару аргументов &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-185.png&quot; style=&quot;{% style_stub rmaaaa 185 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-186.png&quot; style=&quot;{% style_stub smaaaa 186 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; несмотря на то,
что при запуске ей был передан единственный аргумент &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-187.png&quot; style=&quot;{% style_stub tmaaaa 187 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Небольшая техническая сложность заключается в необходимости экранирования специальных
символов в аргументе &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-188.png&quot; style=&quot;{% style_stub umaaaa 188 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; при формировании инъектора (с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-189.png&quot; style=&quot;{% style_stub vmaaaa 189 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; встроенным в него). Экранирование
производится в соответствии с синтаксисом регулярных выражений sed, путем добавления
символа&lt;code&gt;\&lt;/code&gt; перед некоторыми символами, вроде того же &lt;code&gt;\&lt;/code&gt; или перевода строки &lt;code&gt;\n&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;minifier.sed&lt;/code&gt; используется для удаления ненужных символов (пустые строки, комментарии). При
генерации квайна этот скрипт применяется для &lt;em&gt;опционального&lt;/em&gt; «сжатия» скриптов &lt;code&gt;s11.sed&lt;/code&gt; и
&lt;code&gt;duplicate-first.sed&lt;/code&gt;, что впоследствии уменьшает размер и увеличивает скорость работы
результирующего квайна.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;is-quine.sh&lt;/code&gt; – простой shell-скрипт, проверяющий переданный ему в аргументах sed-скрипт и
определяющий, является ли он квайном.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;generate.sh&lt;/code&gt; производит «минификацию» скриптов &lt;code&gt;s11.sed&lt;/code&gt; и &lt;code&gt;duplicate-first.sed&lt;/code&gt;, после
чего запускает &lt;code&gt;generate-q.sh&lt;/code&gt;, а после его завершения проверяет готовый продукт — квайн в
файле &lt;code&gt;q.sed&lt;/code&gt; — с помощью скрипта &lt;code&gt;is-quine.sh&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;duplicate-first.sed&lt;/code&gt; принимает два аргумента &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-190.png&quot; style=&quot;{% style_stub wmaaaa 190 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-191.png&quot; style=&quot;{% style_stub xmaaaa 191 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и заменяет второй первым, т.е.,
игнорирует &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-192.png&quot; style=&quot;{% style_stub ymaaaa 192 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и формирует пакет из двух одинаковых аргументов &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-193.png&quot; style=&quot;{% style_stub zmaaaa 193 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-194.png&quot; style=&quot;{% style_stub anaaaa 194 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;generate-e.sh&lt;/code&gt; конструирует программу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-195.png&quot; style=&quot;{% style_stub bnaaaa 195 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из доказательства теоремы Клини. Для этого
[минифицированный, сжатый] код программы &lt;code&gt;duplicate-first.sed&lt;/code&gt; добавляется в начало [тоже
сжатого] &lt;code&gt;s11.sed&lt;/code&gt; и объединённый код сохраняется в &lt;code&gt;e.sed&lt;/code&gt;. При запуске &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-196.png&quot; style=&quot;{% style_stub cnaaaa 196 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; как и
требуется, будет выполняться &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-197.png&quot; style=&quot;{% style_stub dnaaaa 197 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. сначала
второй аргумент будет заменен первым (с помощью кода из &lt;code&gt;duplicate-first.sed&lt;/code&gt;), затем
управление будет передано коду &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-198.png&quot; style=&quot;{% style_stub enaaaa 198 inline %}&quot; class=&quot;latex&quot;&gt;-функции&lt;/span&gt; из &lt;code&gt;s11.sed&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;generate-q.sh&lt;/code&gt; сначала запускает &lt;code&gt;generate-e.sh&lt;/code&gt; для создания &lt;code&gt;e.sed&lt;/code&gt;, потом запускает
&lt;code&gt;s11.sed&lt;/code&gt; (или его сжатую версию, хотя здесь это не имеет значения) передав ему в качестве
обоих его аргументов содержимое только что сгенерированного &lt;code&gt;e.sed&lt;/code&gt;. (N.B., &lt;code&gt;generate-e.sh&lt;/code&gt;
использовал содержимое &lt;code&gt;s11.sed&lt;/code&gt; для генерации &lt;code&gt;e.sed&lt;/code&gt; на его основе; в данном же случае,
скрипту &lt;code&gt;generate-q.sh&lt;/code&gt; не требуется доступ к тексту &lt;code&gt;s11.sed&lt;/code&gt;, но лишь возможность его
выполнения; по той же причине здесь не используется &lt;code&gt;duplicate-first.sed&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;first-only.sed&lt;/code&gt; из двух переданных ему аргументов возвращает только первый. Реализует
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-199.png&quot; style=&quot;{% style_stub fnaaaa 199 inline %}&quot; class=&quot;latex&quot;&gt;-комбинатор&lt;/span&gt; из комбинаторной логики и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-200.png&quot; style=&quot;{% style_stub gnaaaa 200 inline %}&quot; class=&quot;latex&quot;&gt;-исчисления.&lt;/span&gt; В
дистрибутив/репозиторий включен просто для демонстрации, хотя, в соответствии с
доказательством теоремы Клини, является реализацией функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-201.png&quot; style=&quot;{% style_stub hnaaaa 201 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; позже
использовавшейся для доказательства существования квайна.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;concat.sed&lt;/code&gt; возвращет объединённые значения обоих аргументов; никакие заголовки в результат
не включаются. На деле, &lt;code&gt;concat.sed&lt;/code&gt; включен в репозиторий только для демонстрации – скрипт
&lt;code&gt;generate-e.sh&lt;/code&gt; не использует &lt;code&gt;concat.sed&lt;/code&gt;, а производит объединение текстов просто
последовательным копированием оных в целевой файл.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Заметьте, последние два скрипта, &lt;code&gt;first-only.sed&lt;/code&gt; и &lt;code&gt;concat.sed&lt;/code&gt; концептуально не являются
лишними и они могли бы быть использованы, но по-факту, в ходе оптимизации, были заменены
аналогичными средствами командной оболочки, – для эффективности.)&lt;/p&gt;
&lt;p&gt;Для генерации квайна достаточно запустить &lt;code&gt;./generate.sh&lt;/code&gt;, в результате чего в том же каталоге
[через некоторое время] должен появиться файл &lt;code&gt;q.sed&lt;/code&gt;, являющийся искомым квайном на sed.&lt;/p&gt;
&lt;h1 id=&quot;section-7&quot;&gt;Промежуточные итоги&lt;/h1&gt;
&lt;p&gt;Описание основного эксперимента завершено (и я рекомендую немного поизучать код скриптов из
репозитория). Но о квайнах рассказать можно ещё многое. А некоторые вопросы остаются
вовсе малоизученными, фактически, открытыми.&lt;/p&gt;
&lt;p&gt;Несмотря на приведенные доказательста теорем о неподвижных точках (Клини и Роджерса), кому-то,
может быть, хотелось бы глубже понять структуру этих и подобных им доказательств. Поэтому ниже я
приведу некоторые дополнительные сведения с примерами. К концу сообщения я попробуя немного
задеть некоторые из философских аспектов квайнов и теории вычислимости. И, пожалуй, завершу
изложение попыткой сформулировать интересующие меня, но пока не имеющие официального ответа
открытые вопросы.&lt;/p&gt;
&lt;p&gt;Надеюсь, это не последнее сообщение этой серии. Поэтому, темы, не затронутые здесь, будут, по
возможности, обсуждаться позже в других частях.&lt;/p&gt;
&lt;h1 id=&quot;section-8&quot;&gt;Дополнительная теория&lt;/h1&gt;
&lt;h2 id=&quot;section-9&quot;&gt;Проблема остановки&lt;/h2&gt;
&lt;p&gt;Проблемой останова(-ки) называют задачу определения завершаемости произвольной программы по её
коду. Известна теорема об алгоритмической неразрешимости такой задачи, т.е. о невозможности
построения алгоритма, устанавливающего для произвольной программы конечность времени её
выполнения [8].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство 1.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;В пользу этого утверждения можно привести такие доводы. Введем функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-202.png&quot; style=&quot;{% style_stub inaaaa 202 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; определённую
для всех &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-203.png&quot; style=&quot;{% style_stub jnaaaa 203 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; которая в качестве своих аргументов принимает текст некоторой программы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-204.png&quot; style=&quot;{% style_stub knaaaa 204 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
входные данные &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-205.png&quot; style=&quot;{% style_stub lnaaaa 205 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; этой программы, после чего возвращает 1 если эта программа завершается за
конечное время, и 0 – если программа «зависает»: &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-206.png&quot; style=&quot;{% style_stub mnaaaa 206 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-207.png&quot; style=&quot;{% style_stub nnaaaa 207 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – любая вычислимая (реализуемая в виде компьютерной программы) функция двух
аргументов, способная обрабатывать тексты программ. Напишем программу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-208.png&quot; style=&quot;{% style_stub onaaaa 208 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; так, чтобы
выполнялось: &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-209.png&quot; style=&quot;{% style_stub pnaaaa 209 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-210.png&quot; style=&quot;{% style_stub qnaaaa 210 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; передаёт свой аргумент функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-211.png&quot; style=&quot;{% style_stub rnaaaa 211 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и если та возвращает ноль, то ноль (или любое другое
конечное значение) возвращает и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-212.png&quot; style=&quot;{% style_stub snaaaa 212 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но в противном случае &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-213.png&quot; style=&quot;{% style_stub tnaaaa 213 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; возвращает неопределенное
значение, а именно зависает, входя в бесконечный цикл.&lt;/p&gt;
&lt;p&gt;Так как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-214.png&quot; style=&quot;{% style_stub unaaaa 214 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; тоже реализуема в виде программы (т.е. вычислима), то получение значения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-215.png&quot; style=&quot;{% style_stub vnaaaa 215 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
можно считать обычным вызовом подпрограммы. Все остальные действия (проверка на равенство нулю,
возврат результата, условный переход, бесконечный цикл) тоже выполнимы на любом комппьютере.&lt;/p&gt;
&lt;p&gt;Теперь мы можем передать программе &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-216.png&quot; style=&quot;{% style_stub wnaaaa 216 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; её собственный текст; тогда, если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-217.png&quot; style=&quot;{% style_stub xnaaaa 217 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то и
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-218.png&quot; style=&quot;{% style_stub ynaaaa 218 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Другими словами, в этом случае &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-219.png&quot; style=&quot;{% style_stub znaaaa 219 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; возвращает результат и
завершается, т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-220.png&quot; style=&quot;{% style_stub aoaaaa 220 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Если же &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-221.png&quot; style=&quot;{% style_stub boaaaa 221 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-222.png&quot; style=&quot;{% style_stub coaaaa 222 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; зависает и
таким образом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-223.png&quot; style=&quot;{% style_stub doaaaa 223 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;В любом случае, из этого получается, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-224.png&quot; style=&quot;{% style_stub eoaaaa 224 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Таким образом, функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-225.png&quot; style=&quot;{% style_stub foaaaa 225 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не
совпадает [хотя бы в одной точке] с вычислимой &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-226.png&quot; style=&quot;{% style_stub goaaaa 226 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; А из произвольности выбора функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-227.png&quot; style=&quot;{% style_stub hoaaaa 227 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
немедленно вытекает, что функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-228.png&quot; style=&quot;{% style_stub ioaaaa 228 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не совпадает вообще ни с одной вычислимой функцией, т.е.
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-229.png&quot; style=&quot;{% style_stub joaaaa 229 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; невычислима (в смысле несуществования программы, вычисляющей значение этой функции для всех
программ). &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-230.png&quot; style=&quot;{% style_stub koaaaa 230 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство 2.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Интересно, что можно воспользоваться теоремой Клини и попробовать доказать проблему останова
методом «от противного».&lt;/p&gt;
&lt;p&gt;Допустим, определённая выше функция останова &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-231.png&quot; style=&quot;{% style_stub loaaaa 231 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – вычислимая. Определим вычислимую
функцию &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-232.png&quot; style=&quot;{% style_stub moaaaa 232 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Вторая рекурсивная
теорема говорит, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-233.png&quot; style=&quot;{% style_stub noaaaa 233 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Определение
равенства вычислимых функций, определение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-234.png&quot; style=&quot;{% style_stub ooaaaa 234 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и определение функции останова дают следующие
цепочки логических эквавалентностей &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-235.png&quot; style=&quot;{% style_stub poaaaa 235 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Пришли к
противоречию; значит, функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-236.png&quot; style=&quot;{% style_stub qoaaaa 236 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не является вычислимой. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-237.png&quot; style=&quot;{% style_stub roaaaa 237 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-10&quot;&gt;Диагонализация&lt;/h2&gt;
&lt;p&gt;Схема первого доказательства для проблемы останова фактически основана на процедуре
диагонализации [6]. Второе доказательство, впрочем, тоже: ведь оно использует теорему Клини,
доказательство которой также основано на диагонализации. Далее я попытаюсь пояснить суть этого
процесса. Итак, если у нас есть некоторая бесконечная матрица &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-238.png&quot; style=&quot;{% style_stub soaaaa 238 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (верхний индекс нумерует
строки, нижний – столбцы), то мы можем построить вектор-строку &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-239.png&quot; style=&quot;{% style_stub toaaaa 239 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; не совпадающий ни с одной
из строк матрицы. Для этого достаточно лишь каким-то образом преобразовать элементы диагонали
(отсюда название метода) матрицы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-240.png&quot; style=&quot;{% style_stub uoaaaa 240 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; так, чтобы для любого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-241.png&quot; style=&quot;{% style_stub voaaaa 241 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполнялось &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-242.png&quot; style=&quot;{% style_stub woaaaa 242 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
(например, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-243.png&quot; style=&quot;{% style_stub xoaaaa 243 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Действительно, предположим, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-244.png&quot; style=&quot;{% style_stub yoaaaa 244 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равен одной из строк матрицы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-245.png&quot; style=&quot;{% style_stub zoaaaa 245 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Это означает, что
существует такой индекс &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-246.png&quot; style=&quot;{% style_stub apaaaa 246 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-247.png&quot; style=&quot;{% style_stub bpaaaa 247 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для всех &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-248.png&quot; style=&quot;{% style_stub cpaaaa 248 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Однако, по-построению &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-249.png&quot; style=&quot;{% style_stub dpaaaa 249 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; при
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-250.png&quot; style=&quot;{% style_stub epaaaa 250 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; имеет место неравенство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-251.png&quot; style=&quot;{% style_stub fpaaaa 251 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; противоречие. Следовательно, мы действительно
построили новый объект &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-252.png&quot; style=&quot;{% style_stub gpaaaa 252 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; не входящий в матрицу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-253.png&quot; style=&quot;{% style_stub hpaaaa 253 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Примечание.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Название метода (диагонализация) несколько условно, т.к., по-видимому, достаточно чтобы в каждой
строке был хотя-бы один преобразуемый элемент, совсем не обязательно лежащий на главной
диагонали. [44] (Правда, нужно учитывать, что перестановкой строк можно вернуть преобразуемые
элементы на диагональ матрицы; это замечание пока имеет интуитивный характер и детального
анализа здесь не будет.)&lt;/p&gt;
&lt;p&gt;Возможно, что пока применение этого трюка с конструированием патологической строки матрицы может
показаться далёким от приведенных доказательств разбираемых здесь теорем (Клини, Роджерса и
проблемы остановки); поэтому представляется нелишним небольшое продвижение ближе к историческим
основам метода, и, я надеюсь, это сразу прояснит связь по крайней мере с проблемой останова.
А вот теоремы о неподвижных точках потребуют большего внимания… Итак, сейчас копнём вглубь
истории.&lt;/p&gt;
&lt;h2 id=&quot;section-11&quot;&gt;Теорема Кантора&lt;/h2&gt;
&lt;p&gt;Изначально, диагональный метод был разработан и применен Кантором [7] для доказательства
существования множеств, больших любого счетного бесконечного множества, или, точнее говоря, для
доказательства несуществования сюръекции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-254.png&quot; style=&quot;{% style_stub ipaaaa 254 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-255.png&quot; style=&quot;{% style_stub jpaaaa 255 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
– булеан множества &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-256.png&quot; style=&quot;{% style_stub kpaaaa 256 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Можно выразить теорему Кантора так:
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-257.png&quot; style=&quot;{% style_stub lpaaaa 257 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; В более общем виде, теорема Кантора говорит о несуществовании
сюръекции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-258.png&quot; style=&quot;{% style_stub mpaaaa 258 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-259.png&quot; style=&quot;{% style_stub npaaaa 259 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-260.png&quot; style=&quot;{% style_stub opaaaa 260 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – некоторые множества (причем &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-261.png&quot; style=&quot;{% style_stub ppaaaa 261 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; должно быть невырожденным,
например в смысле существования беспорядка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-262.png&quot; style=&quot;{% style_stub qpaaaa 262 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е., перестановки без неподвижных точек),
а &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-263.png&quot; style=&quot;{% style_stub rpaaaa 263 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – множество всех функций &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-264.png&quot; style=&quot;{% style_stub spaaaa 264 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (структурно, обозначение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-265.png&quot; style=&quot;{% style_stub tpaaaa 265 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; соответствует формуле
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-266.png&quot; style=&quot;{% style_stub upaaaa 266 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для подсчета количества таких функций).&lt;/p&gt;
&lt;p&gt;Рассмотрим более детально пример с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-267.png&quot; style=&quot;{% style_stub vpaaaa 267 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Мы можем закодировать произвольное подмножество &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-268.png&quot; style=&quot;{% style_stub wpaaaa 268 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; двоичной маской, т.е.
последовательностью &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-269.png&quot; style=&quot;{% style_stub xpaaaa 269 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такой, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-270.png&quot; style=&quot;{% style_stub ypaaaa 270 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-271.png&quot; style=&quot;{% style_stub zpaaaa 271 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-272.png&quot; style=&quot;{% style_stub aqaaaa 272 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-273.png&quot; style=&quot;{% style_stub bqaaaa 273 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;После этого мы сможем определить матрицу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-274.png&quot; style=&quot;{% style_stub cqaaaa 274 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (бесконечных размеров), каждая строка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-275.png&quot; style=&quot;{% style_stub dqaaaa 275 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
которой будет содержать двоичную маску для каждого подмножества &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-276.png&quot; style=&quot;{% style_stub eqaaaa 276 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Теперь мы применим
к диагональным элементам &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-277.png&quot; style=&quot;{% style_stub fqaaaa 277 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; матрицы операцию инвертирования &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-278.png&quot; style=&quot;{% style_stub gqaaaa 278 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-279.png&quot; style=&quot;{% style_stub hqaaaa 279 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-280.png&quot; style=&quot;{% style_stub iqaaaa 280 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; в результате чего получим новый
бесконечный вектор-строку &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-281.png&quot; style=&quot;{% style_stub jqaaaa 281 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; который не будет совпадать ни с одной из строк
матрицы.&lt;/p&gt;
&lt;p&gt;Т.е. мы получили совершенно новый объект, имеющий конкретное описание в виде двоичной
последовательности, тоже могущей быть двоичной маской для некоторого подмножества &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-282.png&quot; style=&quot;{% style_stub kqaaaa 282 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
но не входящей в матрицу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-283.png&quot; style=&quot;{% style_stub lqaaaa 283 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Этот пример показывает, что раз строки матрицы пронумерованы
числами &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-284.png&quot; style=&quot;{% style_stub mqaaaa 284 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а мы получили «лишнюю» двоичную маску, определяющую некое «лишнее»
подмножество &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-285.png&quot; style=&quot;{% style_stub nqaaaa 285 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то множество всех подмножеств &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-286.png&quot; style=&quot;{% style_stub oqaaaa 286 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; содержащее это лишнее
подмножество и обозначаемое &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-287.png&quot; style=&quot;{% style_stub pqaaaa 287 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; строго больше самого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-288.png&quot; style=&quot;{% style_stub qqaaaa 288 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; выражение
«строго больше» означает, что в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-289.png&quot; style=&quot;{% style_stub rqaaaa 289 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; есть лишние, дополнительные элементы и
нельзя определить какую-нибудь функцию из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-290.png&quot; style=&quot;{% style_stub sqaaaa 290 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; &lt;em&gt;на&lt;/em&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-291.png&quot; style=&quot;{% style_stub tqaaaa 291 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. такую
функцию, чтобы у каждого элемента &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-292.png&quot; style=&quot;{% style_stub uqaaaa 292 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; был прообраз.&lt;/p&gt;
&lt;p&gt;Применительно же к проблеме останова, в качестве бесконечной матрицы используются значения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-293.png&quot; style=&quot;{% style_stub vqaaaa 293 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. строки соответствуют функциям. Причем диагональные значения оборачиваются в функцию
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-294.png&quot; style=&quot;{% style_stub wqaaaa 294 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; так, чтобы функция останова &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-295.png&quot; style=&quot;{% style_stub xqaaaa 295 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; [хотя бы на диагональных элементах
матрицы] возвращала результат, отличный от результата применения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-296.png&quot; style=&quot;{% style_stub yqaaaa 296 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; к тем же аргументам.&lt;/p&gt;
&lt;h2 id=&quot;section-12&quot;&gt;Теорема Ловера&lt;/h2&gt;
&lt;p&gt;Уильям Ловер предложил [43] обобщенную теорему из которой следуют многие другие результаты
диагонализации, включая и проблему останова и теорему Гёделя о неполноте и некоторые другие. См.
[44] для изложения тех же результатов на языке теории множеств (работа [43] сформулирована с
существенным привлечением теории категорий).&lt;/p&gt;
&lt;h2 id=&quot;section-13&quot;&gt;Связь диагонализации с теоремами о неподвижной точке&lt;/h2&gt;
&lt;p&gt;(Этот подраздел добавлен через месяцы после размещения в моем дневнике первой версии этого
сообщения. Добавить новый подраздел, демонстрирующий роль диагонализации при поиске неподвижных
точек, я решил после того как однажды прочитал своё же сообщение и не увидел чётких следов
диагонального процесса в приведенных доказательствах теорем Клини и Роджерса, кроме характерного
приема с самоприменением программ… Материал в основном написан по мотивам [56].)&lt;/p&gt;
&lt;p&gt;В рассмотренных выше примерах применения диагонального процесса мы определяли множество всех
объектов определённого типа, представляли их строками матрицы, а затем применяли некоторую
операцию к диагональным элементам и т.о. конструировали новый объект, не могущий быть описанным
ни одной строкой матрицы. Но при поиске неподвижной точки, как в теоремах Клини и Роджерса,
требуется, наоборот, построить или найти объект с требуемыми свойствами в исходном наборе, а не
доказать, что его там нет. Причем же тут диагонализация?&lt;/p&gt;
&lt;p&gt;Все дело в том, что если нам удается построить новую последовательность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-297.png&quot; style=&quot;{% style_stub zqaaaa 297 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (иногда называемую
антидиагональю [ которую не следует путать с побочной диагональю матрицы]), путем применения
некоего преобразования &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-298.png&quot; style=&quot;{% style_stub araaaa 298 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; к диагональным элементам матрицы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-299.png&quot; style=&quot;{% style_stub braaaa 299 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то мы, как уже было
сказано ранее, можем быть уверены, что среди строк матрицы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-300.png&quot; style=&quot;{% style_stub craaaa 300 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; объекта &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-301.png&quot; style=&quot;{% style_stub draaaa 301 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; нет. Но если по
какой-то причине «антидиагональный» объект &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-302.png&quot; style=&quot;{% style_stub eraaaa 302 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; построить не получается, то среди строк матрицы
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-303.png&quot; style=&quot;{% style_stub fraaaa 303 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; может оказаться её диагональ. Т.е. возможно существует индекс &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-304.png&quot; style=&quot;{% style_stub graaaa 304 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такой, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-305.png&quot; style=&quot;{% style_stub hraaaa 305 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Нас интересует случай замкнутости набора строк матрицы относительно действия &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-306.png&quot; style=&quot;{% style_stub iraaaa 306 inline %}&quot; class=&quot;latex&quot;&gt;:&lt;/span&gt; для любой
строки &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-307.png&quot; style=&quot;{% style_stub jraaaa 307 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; существует строка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-308.png&quot; style=&quot;{% style_stub kraaaa 308 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равная образу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-309.png&quot; style=&quot;{% style_stub lraaaa 309 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-310.png&quot; style=&quot;{% style_stub mraaaa 310 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Итак, если диагональ матрицы равна её строке &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-311.png&quot; style=&quot;{% style_stub nraaaa 311 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то в силу замкнутости
строк относительно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-312.png&quot; style=&quot;{% style_stub oraaaa 312 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; существует строка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-313.png&quot; style=&quot;{% style_stub praaaa 313 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а так как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-314.png&quot; style=&quot;{% style_stub qraaaa 314 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то и образ диагонали под действием &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-315.png&quot; style=&quot;{% style_stub rraaaa 315 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; тоже оказывается среди строк: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-316.png&quot; style=&quot;{% style_stub sraaaa 316 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Но если результат преобразования диагонали равен одной из строк, то это означает, что на
пересечении этой строки с главной диагональю матрицы есть элемент, переходящий в себя под
действием преобразования &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-317.png&quot; style=&quot;{% style_stub traaaa 317 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Другими словами, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-318.png&quot; style=&quot;{% style_stub uraaaa 318 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; i.e., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-319.png&quot; style=&quot;{% style_stub vraaaa 319 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; –
неподвижная точка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-320.png&quot; style=&quot;{% style_stub wraaaa 320 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Возможно, в визуализации этой идеи поможет следующий рисунок (матрица &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-321.png&quot; style=&quot;{% style_stub xraaaa 321 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; схематично изображена
в виде таблицы; вместо каких-либо конкретных значений её ячеек используется символ &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-322.png&quot; style=&quot;{% style_stub yraaaa 322 inline %}&quot; class=&quot;latex&quot;&gt;):&lt;/span&gt;
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-323.png&quot; style=&quot;{% style_stub zraaaa 323 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Ну вот, связь диагонализации и неподвижных точек в общих чертах продемонстрирована. Осталось
выяснить, что же может пойти не так при построении вектора &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-324.png&quot; style=&quot;{% style_stub asaaaa 324 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Напомню, что в случае с теоремой
Кантора и проблемой останова диагонализация проходила успешно… Разгадка здесь всего-лишь в
том, что в случае с неподвижными точками мы не строим функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-325.png&quot; style=&quot;{% style_stub bsaaaa 325 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; специально так, чтобы у
неё не было неподвижных точек. И лишь предполагая, допуская их наличие, мы применяем
диагональный процесс для конструирования такой неподвижной точки. Получив же конкретное решение,
можно легко убедиться, что это действительно неподвижная точка; с тем же успехом, мы могли бы
просто угадать вид решения, а потом убедиться в его правильности. Т.о., если отбросить вариант с
угадыванием, то конструктивный характер диагональной схемы существенен для её логической основы:
мы создаём объект с нужными свойствами и назад пути уже нет в силу непротиворечивости
используемых формальных систем (ведь если выведено некоторое утверждение, вывести его отрицание
в таких системах уже не получится). (Рекомендую также глянуть интересное обсуждение логической
основы диагонализации в [57].)&lt;/p&gt;
&lt;p&gt;Пример приведем для теоремы Роджерса, более удобной из-за одноместности фигурирующей в ней
функции. Требуется решить уравнение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-326.png&quot; style=&quot;{% style_stub csaaaa 326 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
относительно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-327.png&quot; style=&quot;{% style_stub dsaaaa 327 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для любой всюду определённой вычислимой &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-328.png&quot; style=&quot;{% style_stub esaaaa 328 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; В соответствии с вышеизложенной
схемой доказательства диагонализацией, далее предстоит определить матрицу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-329.png&quot; style=&quot;{% style_stub fsaaaa 329 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и преобразование
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-330.png&quot; style=&quot;{% style_stub gsaaaa 330 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; так, чтобы неподвижная точка функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-331.png&quot; style=&quot;{% style_stub hsaaaa 331 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; подходила бы в качестве решения к
уравнению из теоремы Роджерса.&lt;/p&gt;
&lt;p&gt;По техническим причинам, о которых ещё будет сказано позже, вместо функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-332.png&quot; style=&quot;{% style_stub isaaaa 332 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; мы введем
отношение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-333.png&quot; style=&quot;{% style_stub jsaaaa 333 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (его конкретный вид будет определён ниже). Вместо
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-334.png&quot; style=&quot;{% style_stub ksaaaa 334 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будем писать &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-335.png&quot; style=&quot;{% style_stub lsaaaa 335 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; в частности, если некоторая
функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-336.png&quot; style=&quot;{% style_stub msaaaa 336 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – искомая неподвижная точка, то будет выполняться &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-337.png&quot; style=&quot;{% style_stub nsaaaa 337 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; К
строкам матрицы и вообще к последовательностям это отношение применяется поэлементно.&lt;/p&gt;
&lt;p&gt;Пусть элементы матрицы равны &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-338.png&quot; style=&quot;{% style_stub osaaaa 338 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.е.
строка с индексом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-339.png&quot; style=&quot;{% style_stub psaaaa 339 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; соответствует вычислимой функции с номером &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-340.png&quot; style=&quot;{% style_stub qsaaaa 340 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; номера столбцов
соответствуют значениям аргументов. (Заметьте, что элементы матрицы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-341.png&quot; style=&quot;{% style_stub rsaaaa 341 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равны не самим значениям
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-342.png&quot; style=&quot;{% style_stub ssaaaa 342 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а вычислимым функциям с номерами &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-343.png&quot; style=&quot;{% style_stub tsaaaa 343 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt; Если
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-344.png&quot; style=&quot;{% style_stub usaaaa 344 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для некоторых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-345.png&quot; style=&quot;{% style_stub vsaaaa 345 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-346.png&quot; style=&quot;{% style_stub wsaaaa 346 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то считается, что элемент &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-347.png&quot; style=&quot;{% style_stub xsaaaa 347 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
содержит нигде не определённую функцию: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-348.png&quot; style=&quot;{% style_stub ysaaaa 348 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Диагональ &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-349.png&quot; style=&quot;{% style_stub zsaaaa 349 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
обозначим &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-350.png&quot; style=&quot;{% style_stub ataaaa 350 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и будем считать &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-351.png&quot; style=&quot;{% style_stub btaaaa 351 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Если некоторый гипотетический объект &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-352.png&quot; style=&quot;{% style_stub ctaaaa 352 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; для которого справедливо &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-353.png&quot; style=&quot;{% style_stub dtaaaa 353 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не
является «патологическим», т.е. гарантированно отсутствующим среди строк матрицы, то диагональ
может оказаться равной одной из строк.&lt;/p&gt;
&lt;p&gt;Мы можем определить функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-354.png&quot; style=&quot;{% style_stub etaaaa 354 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; конструирующую программу, которая принимая аргумент &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-355.png&quot; style=&quot;{% style_stub ftaaaa 355 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
применяет к нему диагональный элемент матрицы, находящийся на пересечении строки &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-356.png&quot; style=&quot;{% style_stub gtaaaa 356 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и столбца
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-357.png&quot; style=&quot;{% style_stub htaaaa 357 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; А именно, выполняется &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-358.png&quot; style=&quot;{% style_stub itaaaa 358 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Важно, что для
вычисления &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-359.png&quot; style=&quot;{% style_stub jtaaaa 359 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; тоже можно написать программу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-360.png&quot; style=&quot;{% style_stub ktaaaa 360 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-361.png&quot; style=&quot;{% style_stub ltaaaa 361 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – вычислимая функция. Это
означает, что в матрице &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-362.png&quot; style=&quot;{% style_stub mtaaaa 362 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; существует строка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-363.png&quot; style=&quot;{% style_stub ntaaaa 363 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равная &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-364.png&quot; style=&quot;{% style_stub otaaaa 364 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; действительно, из того,
что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-365.png&quot; style=&quot;{% style_stub ptaaaa 365 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; является программой для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-366.png&quot; style=&quot;{% style_stub qtaaaa 366 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а также из определения элементов &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-367.png&quot; style=&quot;{% style_stub rtaaaa 367 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-368.png&quot; style=&quot;{% style_stub staaaa 368 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; следует
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-369.png&quot; style=&quot;{% style_stub ttaaaa 369 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Если набор строк замкнут относительно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-370.png&quot; style=&quot;{% style_stub utaaaa 370 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то существует
строка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-371.png&quot; style=&quot;{% style_stub vtaaaa 371 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; и именно её пересечение с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-372.png&quot; style=&quot;{% style_stub wtaaaa 372 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; дает неподвижную точку:
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-373.png&quot; style=&quot;{% style_stub xtaaaa 373 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Чтобы последнее уравнение выглядело как уравнение из теоремы Роджерса, определим отношение
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-374.png&quot; style=&quot;{% style_stub ytaaaa 374 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; так, что для функций &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-375.png&quot; style=&quot;{% style_stub ztaaaa 375 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-376.png&quot; style=&quot;{% style_stub auaaaa 376 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-377.png&quot; style=&quot;{% style_stub buaaaa 377 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Попробуем показать, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-378.png&quot; style=&quot;{% style_stub cuaaaa 378 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-379.png&quot; style=&quot;{% style_stub duaaaa 379 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – такая последовательность, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-380.png&quot; style=&quot;{% style_stub euaaaa 380 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Из определений
элементов матрицы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-381.png&quot; style=&quot;{% style_stub fuaaaa 381 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и отношения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-382.png&quot; style=&quot;{% style_stub guaaaa 382 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; следует &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-383.png&quot; style=&quot;{% style_stub huaaaa 383 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-384.png&quot; style=&quot;{% style_stub iuaaaa 384 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; В силу вычислимости &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-385.png&quot; style=&quot;{% style_stub juaaaa 385 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; композиция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-386.png&quot; style=&quot;{% style_stub kuaaaa 386 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; тоже вычислима и имеет некоторый индекс &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-387.png&quot; style=&quot;{% style_stub luaaaa 387 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-388.png&quot; style=&quot;{% style_stub muaaaa 388 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; В соответствии с определением элементов матрицы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-389.png&quot; style=&quot;{% style_stub nuaaaa 389 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; это
выражение означает, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-390.png&quot; style=&quot;{% style_stub ouaaaa 390 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равна строке с индексом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-391.png&quot; style=&quot;{% style_stub puaaaa 391 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.о., мы только что показали, что набор
строк замкнут относительно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-392.png&quot; style=&quot;{% style_stub quaaaa 392 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Выше было установлено, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-393.png&quot; style=&quot;{% style_stub ruaaaa 393 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Левую часть перепишем
с помощью &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-394.png&quot; style=&quot;{% style_stub suaaaa 394 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; учитывая равенство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-395.png&quot; style=&quot;{% style_stub tuaaaa 395 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а правую – с помощью определения элементов
матрицы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-396.png&quot; style=&quot;{% style_stub uuaaaa 396 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Это даёт &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-397.png&quot; style=&quot;{% style_stub vuaaaa 397 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Из определения отношения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-398.png&quot; style=&quot;{% style_stub wuaaaa 398 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; следует, что
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-399.png&quot; style=&quot;{% style_stub xuaaaa 399 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Это уравнение говорит, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-400.png&quot; style=&quot;{% style_stub yuaaaa 400 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – один из возможных текстов программ, вычисляющих композицию
функций &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-401.png&quot; style=&quot;{% style_stub zuaaaa 401 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; кроме того, то же самое уравнение вместе с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-402.png&quot; style=&quot;{% style_stub avaaaa 402 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в случае с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-403.png&quot; style=&quot;{% style_stub bvaaaa 403 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; немедленно
даёт &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-404.png&quot; style=&quot;{% style_stub cvaaaa 404 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Таким образом, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-405.png&quot; style=&quot;{% style_stub dvaaaa 405 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-406.png&quot; style=&quot;{% style_stub evaaaa 406 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; является программой для вычисления композиции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-407.png&quot; style=&quot;{% style_stub fvaaaa 407 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; – искомая неподвижная точка
из теоремы Роджерса, т.е., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-408.png&quot; style=&quot;{% style_stub gvaaaa 408 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Да, это построение выглядит более громоздким и запутанным чем изначально приведенное почти
однострочное доказательство теоремы Роджерса, но оно, я надеюсь, позволяет более глубоко увидеть
связь диагонального процесса с теоремами о неподвижных точках.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Примечание.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ранее я говорил, что лучше использовать отношение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-409.png&quot; style=&quot;{% style_stub hvaaaa 409 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; вместо функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-410.png&quot; style=&quot;{% style_stub ivaaaa 410 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Чтобы
неподвижная точка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-411.png&quot; style=&quot;{% style_stub jvaaaa 411 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-412.png&quot; style=&quot;{% style_stub kvaaaa 412 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; удовлетворяла уравнению &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-413.png&quot; style=&quot;{% style_stub lvaaaa 413 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; можно было бы определить &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-414.png&quot; style=&quot;{% style_stub mvaaaa 414 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-415.png&quot; style=&quot;{% style_stub nvaaaa 415 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; В принципе, та же схема доказательства работала бы и в
этом случае: сначала мы бы выяснили, что строки замкнуты относительно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-416.png&quot; style=&quot;{% style_stub ovaaaa 416 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; затем
преобразовали бы строку &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-417.png&quot; style=&quot;{% style_stub pvaaaa 417 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; равную диагонали &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-418.png&quot; style=&quot;{% style_stub qvaaaa 418 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; и получили бы новую строку
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-419.png&quot; style=&quot;{% style_stub rvaaaa 419 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; завершилось бы такое доказательство проверкой, что элемент &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-420.png&quot; style=&quot;{% style_stub svaaaa 420 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
находящийся на пересечении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-421.png&quot; style=&quot;{% style_stub tvaaaa 421 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-422.png&quot; style=&quot;{% style_stub uvaaaa 422 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; удовлетворяет уравнению &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-423.png&quot; style=&quot;{% style_stub vvaaaa 423 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Пусть некоторый элемент в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-424.png&quot; style=&quot;{% style_stub wvaaaa 424 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равен &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-425.png&quot; style=&quot;{% style_stub xvaaaa 425 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для некоторого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-426.png&quot; style=&quot;{% style_stub yvaaaa 426 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Тогда
соответствующий элемент в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-427.png&quot; style=&quot;{% style_stub zvaaaa 427 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равен &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-428.png&quot; style=&quot;{% style_stub awaaaa 428 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и равенство последовательностей
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-429.png&quot; style=&quot;{% style_stub bwaaaa 429 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; означает, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-430.png&quot; style=&quot;{% style_stub cwaaaa 430 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; В строке &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-431.png&quot; style=&quot;{% style_stub dwaaaa 431 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
элементу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-432.png&quot; style=&quot;{% style_stub ewaaaa 432 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из строки &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-433.png&quot; style=&quot;{% style_stub fwaaaa 433 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; соответствует элемент &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-434.png&quot; style=&quot;{% style_stub gwaaaa 434 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Проблема в том, что исходный элемент &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-435.png&quot; style=&quot;{% style_stub hwaaaa 435 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-436.png&quot; style=&quot;{% style_stub iwaaaa 436 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; под действием преобразования &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-437.png&quot; style=&quot;{% style_stub jwaaaa 437 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; должен перейти в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-438.png&quot; style=&quot;{% style_stub kwaaaa 438 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и мы вынуждены потребовать, чтобы этот результат совпадал с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-439.png&quot; style=&quot;{% style_stub lwaaaa 439 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; ведь иначе нельзя будет говорить о &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-440.png&quot; style=&quot;{% style_stub mwaaaa 440 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-441.png&quot; style=&quot;{% style_stub nwaaaa 441 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет желаемым элементом на пересечении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-442.png&quot; style=&quot;{% style_stub owaaaa 442 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-443.png&quot; style=&quot;{% style_stub pwaaaa 443 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Другими словами, из равенства &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-444.png&quot; style=&quot;{% style_stub qwaaaa 444 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; должно следовать &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-445.png&quot; style=&quot;{% style_stub rwaaaa 445 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а для этого требуется экстенсиональность функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-446.png&quot; style=&quot;{% style_stub swaaaa 446 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – должно выполняться
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-447.png&quot; style=&quot;{% style_stub twaaaa 447 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; i.e., одинаково ведущие себя программы, должны преобразовываться функцией &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-448.png&quot; style=&quot;{% style_stub uwaaaa 448 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
снова в одинаково себя ведущие, однако не всякая вычислимая функция обладает такой формой
монотонности. Трюк с заменой преобразования &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-449.png&quot; style=&quot;{% style_stub vwaaaa 449 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (вместе с обычным сравнением функций)
отношением &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-450.png&quot; style=&quot;{% style_stub wwaaaa 450 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; позволяет обойти это ограничение и расширить класс пригодных функций
до всех вычислимых всюду определённых.&lt;/p&gt;
&lt;h3 id=&quot;section-14&quot;&gt;Версия «от противного».&lt;/h3&gt;
&lt;p&gt;Рассуждения по схеме «а вдруг», могут показаться не всегда удовлетворительными. Можно ли
вместо попытки сконструировать желаемый объект — неподвижную точку — вопреки диагонализации
(призванной доказать невозможность подобного мероприятия) попробовать облачить вышеизложенное в
привычную схему доказательства от противного? Такое доказательство выглядело бы более привычно и
ощущалось бы более весомым (ведь доказательство от противного основано на надёжном процессе
поиска ошибки в цепочке умозаключений, приведших к абсурду; такой поиск призван, в итоге,
локализовать ошибку, загнав её в единственный туманный уголок доказательства, а именно, в самое
его начальное предположение, после чего способ исправления ошибки — отрицанием предположения
— немедленно следует из закона исключённого третьего, и, таким образом любые претензии к
качеству такого доказательства сводятся к вере в этот закон). Оказывается, что, да,
доказательство, одновременно явно использующее диагонализацию и показывающее наличие неподвижной
точки методом от противного, существует, и, в общем-то, общеизвестно.&lt;/p&gt;
&lt;p&gt;Итак. Определим бинарное отношение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-451.png&quot; style=&quot;{% style_stub xwaaaa 451 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; так, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-452.png&quot; style=&quot;{% style_stub ywaaaa 452 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема (переформулировка теоремы Роджерса).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-453.png&quot; style=&quot;{% style_stub zwaaaa 453 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – всюду определённая вычислимая функция, то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-454.png&quot; style=&quot;{% style_stub axaaaa 454 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство теоремы Роджерса методом от противного.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(N.B., Акцент в этой версии доказательства сделан на диагонализации, пусть и в ущерб
конструктивности, — здесь я не буду выводить явный вид неподвижной точки, хотя при желании
его можно извлечь и из такой урезанной версии.)&lt;/p&gt;
&lt;p&gt;Основное предположение: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-455.png&quot; style=&quot;{% style_stub bxaaaa 455 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Лемма 1 (без доказательства).&lt;/strong&gt; Для любой вычислимой функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-456.png&quot; style=&quot;{% style_stub cxaaaa 456 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; существует вычислимая всюду
определённая &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-457.png&quot; style=&quot;{% style_stub dxaaaa 457 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (т.н., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-458.png&quot; style=&quot;{% style_stub exaaaa 458 inline %}&quot; class=&quot;latex&quot;&gt;-продолжение&lt;/span&gt; функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-459.png&quot; style=&quot;{% style_stub fxaaaa 459 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; такая, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-460.png&quot; style=&quot;{% style_stub gxaaaa 460 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Определим вычислимую всюду определённую функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-461.png&quot; style=&quot;{% style_stub hxaaaa 461 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такую, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-462.png&quot; style=&quot;{% style_stub ixaaaa 462 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Утверждение 1.&lt;/strong&gt; Не существует вычислимой функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-463.png&quot; style=&quot;{% style_stub jxaaaa 463 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такой, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-464.png&quot; style=&quot;{% style_stub kxaaaa 464 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
(иначе это бы противоречило определению универсальной функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-465.png&quot; style=&quot;{% style_stub lxaaaa 465 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(N.B., конкретный вид &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-466.png&quot; style=&quot;{% style_stub mxaaaa 466 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на самом деле не важен, — требуется лишь справедливость утверждения
1, — но здесь мы всё-таки зафиксируем такое «диагональное» выражение, и даже воспользуемся
им в конце этого подраздела для лучшей визуализации процесса.)&lt;/p&gt;
&lt;p&gt;По лемме 1, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-467.png&quot; style=&quot;{% style_stub nxaaaa 467 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-468.png&quot; style=&quot;{% style_stub oxaaaa 468 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Определим функцию
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-469.png&quot; style=&quot;{% style_stub pxaaaa 469 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-470.png&quot; style=&quot;{% style_stub qxaaaa 470 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-471.png&quot; style=&quot;{% style_stub rxaaaa 471 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и их композиция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-472.png&quot; style=&quot;{% style_stub sxaaaa 472 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – вычислима. Допустим,
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-473.png&quot; style=&quot;{% style_stub txaaaa 473 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Это вместе с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-474.png&quot; style=&quot;{% style_stub uxaaaa 474 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и с определением отношения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-475.png&quot; style=&quot;{% style_stub vxaaaa 475 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; ведет
к &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-476.png&quot; style=&quot;{% style_stub wxaaaa 476 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; из чего
следует &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-477.png&quot; style=&quot;{% style_stub xxaaaa 477 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Но &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-478.png&quot; style=&quot;{% style_stub yxaaaa 478 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; откуда &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-479.png&quot; style=&quot;{% style_stub zxaaaa 479 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; однако по основному
предположению, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-480.png&quot; style=&quot;{% style_stub ayaaaa 480 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-481.png&quot; style=&quot;{% style_stub byaaaa 481 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выглядит как неподвижная точка, но мы
предполагаем, что их не существует). Противоречие, значит, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-482.png&quot; style=&quot;{% style_stub cyaaaa 482 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; отличается всюду от &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-483.png&quot; style=&quot;{% style_stub dyaaaa 483 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Но это
противоречит уже утверждению 1. Следовательно, основное предположение неверно и мы
должны его исправить, заменив на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-484.png&quot; style=&quot;{% style_stub eyaaaa 484 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-485.png&quot; style=&quot;{% style_stub fyaaaa 485 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Обратите внимание, здесь мы имеем дело с матрицей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-486.png&quot; style=&quot;{% style_stub gyaaaa 486 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в которой строки, как и
прежде, соответствуют вычислимым функциям, а столбцы – их аргументам (изменились только сами
элементы матрицы). Функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-487.png&quot; style=&quot;{% style_stub hyaaaa 487 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; порождена диагональю &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-488.png&quot; style=&quot;{% style_stub iyaaaa 488 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Лемма 1 говорит, что в матрице &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-489.png&quot; style=&quot;{% style_stub jyaaaa 489 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; присутствует строка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-490.png&quot; style=&quot;{% style_stub kyaaaa 490 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (отношение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-491.png&quot; style=&quot;{% style_stub lyaaaa 491 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
применено поэлементно). Мы используем эту строку для конструирования кандидата в антидиагональ,
а именно мы действуем на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-492.png&quot; style=&quot;{% style_stub myaaaa 492 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; данной вычислимой функцией &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-493.png&quot; style=&quot;{% style_stub nyaaaa 493 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но т.к. строка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-494.png&quot; style=&quot;{% style_stub oyaaaa 494 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
соответствует функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-495.png&quot; style=&quot;{% style_stub pyaaaa 495 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а композиция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-496.png&quot; style=&quot;{% style_stub qyaaaa 496 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; вычислима, то среди строк должна найтись
строка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-497.png&quot; style=&quot;{% style_stub ryaaaa 497 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (пересекающая диагональ в некоторой точке).&lt;/p&gt;
&lt;p&gt;Откуда же тогда берутся подозрения в антидиагональности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-498.png&quot; style=&quot;{% style_stub syaaaa 498 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. в том, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-499.png&quot; style=&quot;{% style_stub tyaaaa 499 inline %}&quot; class=&quot;latex&quot;&gt;?&lt;/span&gt; Мы знаем, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-500.png&quot; style=&quot;{% style_stub uyaaaa 500 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (так мы строили строку &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-501.png&quot; style=&quot;{% style_stub vyaaaa 501 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt; Теперь если
для какого-то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-502.png&quot; style=&quot;{% style_stub wyaaaa 502 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; верно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-503.png&quot; style=&quot;{% style_stub xyaaaa 503 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то в строке &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-504.png&quot; style=&quot;{% style_stub yyaaaa 504 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; найдётся элемент &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-505.png&quot; style=&quot;{% style_stub zyaaaa 505 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но по определению элементов матрицы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-506.png&quot; style=&quot;{% style_stub azaaaa 506 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-507.png&quot; style=&quot;{% style_stub bzaaaa 507 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; откуда и вытекает выражение
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-508.png&quot; style=&quot;{% style_stub czaaaa 508 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; противоречащее основному предположению [о несуществовании
неподвижной точки &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-509.png&quot; style=&quot;{% style_stub dzaaaa 509 inline %}&quot; class=&quot;latex&quot;&gt;],&lt;/span&gt; а значит опровергающее, методом от противного, наше
предположение о том, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-510.png&quot; style=&quot;{% style_stub ezaaaa 510 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; совпадает с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-511.png&quot; style=&quot;{% style_stub fzaaaa 511 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в точке &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-512.png&quot; style=&quot;{% style_stub gzaaaa 512 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;На данный момент мы имеем уже два утверждения: одно говорит о том, что антидиагональ на самом
деле равна строке &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-513.png&quot; style=&quot;{% style_stub hzaaaa 513 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и пересекается с диагональю в некоторой точке, а второе утверждение
говорит, что антидиагональ действительно нигде не совпадает с диагональю. Эти утверждения
противоречат друг другу, что абсурдно, и, опять методом от противного, приводит к утверждению,
прямо противоположному основному предположению об отсутствии неподвижных точек у данной функции
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-514.png&quot; style=&quot;{% style_stub izaaaa 514 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Я специально воспроизвел последнее доказательство от противного в уже знакомых терминах матриц,
диагоналей, строк, антидиагоналей, и т.д., чтобы придать максимальную наглядность процессу и
окончательно удалить мистический налёт с диагонального доказательства теоремы о рекурсии.&lt;/p&gt;
&lt;h1 id=&quot;section-15&quot;&gt;Немного о пределах познаваемости&lt;/h1&gt;
&lt;p&gt;Проблема останова разрешима для многих систем, например, для конечных автоматов,
коими, кстати говоря, и являются реальные компьютеры. Правда, в силу огромного количества
состояний таких автоматов, они, с практической точки зрения, хорошо моделируются машиной
Тьюринга (или эквивалентными моделями, типа лямбда-исчисления). Поэтому, многие теоретические
результаты, вытекающие из проблемы останова или доказываемые редукцией к ней, по прежнему
применимы в обычном программировании.&lt;/p&gt;
&lt;p&gt;Также проблема останова может быть вполне разрешимой для определенных частных случаев. Например,
в теории, антивирусы невозможны (это доказывается редукцией к проблеме остановки), но они
всё-таки &lt;s&gt;вертятся&lt;/s&gt; существуют как программные продукты (в том числе, благодаря
«маркетингу», наверное). В теории, невозможно написать программу-детектор, безошибочно
определяющую, что другая программа печатает на экране, например, слово «привет» [28, 29]. Но
ведь многие бы без труда написали такой детектор. Даже сами доказательства теорем, в силу
соответствия Карри-Ховарда, вообще говоря, требуют решения проблемы остановки. Но ведь
математики как-то доказывают теоремы! Иногда при помощи компьютера (и автоматизированно и даже
автоматически).&lt;/p&gt;
&lt;p&gt;Эти исключения не являются ошибками или фактами, опровергающими упомянутые контринтуитивные
утверждения (содержащие квантор всеобщности). А положительные результаты имеют вполне конкретное
применение. Компиляторы, интерпретаторы, квайны и многие другие интересные артефакты теории
вычислимости существуют не только теоретически, но и имеют осязаемые реализации в виде реальных
кусков кода и даже устройств (e.g. те же компьютеры). А теорема Гёделя о неполноте говорит, что
некоторые теоремы просто не могут быть доказаны, – не стоит даже и пытаться.&lt;/p&gt;
&lt;p&gt;Наконец, диагонализация внесла некоторый вклад и в более абстрактные области философии.
Например, применением диагонального процесса к демону Лапласа — «древнему» суперкомпьютеру,
имеющему неограниченный доступ к любой информации обо всех частицах вселенной — была
установлена «монотеистическая» теорема о невозможности существования более чем одного демона
Лапласа [27].&lt;/p&gt;
&lt;p&gt;В следующих сообщениях этой серии я напишу о некоторых из этих [как классических, так и
относительно новых] результатов подробнее.&lt;/p&gt;
&lt;h1 id=&quot;section-16&quot;&gt;Другие подходы и «слегка открытые» вопросы&lt;/h1&gt;
&lt;p&gt;В этом разделе обсуждаются достаточно простые, но до сих пор представляющие некоторый
исследовательский интерес альтернативные подходы к конструированию квайнов. Некоторые из
рассмотренных здесь вопросов могут быть тривиальными и, возможно, представляющими сложность лишь
для меня; другие – могут оказаться объективно стоящими дальнейшей проработки.&lt;/p&gt;
&lt;p&gt;Более подробно все эти воросы будет или не будут освещены в следующем(-их) сообщении(-ях) этой
серии.&lt;/p&gt;
&lt;h2 id=&quot;vs-&quot;&gt;«Креацианизм» vs. «абиогенез»&lt;/h2&gt;
&lt;p&gt;Я условно назвал совокупность методов (как ручных, так и автоматических), применяемых для
конструирования квайнов и основанных на существенном привнесении специально подготовленной
внешней информации/знаний в этот процесс [квайнологическим] «креацианизмом». Традиционное
написание квайна вручную, а также его конструирования на основе второй рекурсивной теоремы Клини
– суть примеры креацианисткого подхода в квайнологии. В них требуется существенный контроль со
стороны программиста.&lt;/p&gt;
&lt;p&gt;В подразделах же, приведенных ниже, акцент сделан на автоматическом итеративном конструировании
квайнов (если оно возможно). «Абиогенетическое», самостоятельное «зарождение» квайнов
потенциально могло бы представлять некоторую ценность в ряде областей. Так, например,
квайнологический абиогенез был бы интересен в таком разделе информационной безопасности как
компьютерная вирусология; он был бы применим в автономных системах (e.g., самомодифицирующееся
ПО каких-нибудь марсоходов) и, возможно, интересен экзобиологам (в том смысле, что квайны,
будучи «дистиллированной» моделью жизни, подошли бы для изучения тварей с &lt;em&gt;terra incognita&lt;/em&gt;,
– будь-то океанские впадины, астероиды, космическая пыль/мусор, или любые другие субстраты).&lt;/p&gt;
&lt;h2 id=&quot;section-17&quot;&gt;Кимианские квайны и итеративное вычисление неподвижной точки&lt;/h2&gt;
&lt;p&gt;Хофштадтер в [26] не только ввел термин «квайн», но и описал там же ещё одну разновидность
самореплицирующегося кода – кимианские квайны, названные в честь Скотта Кима (Scott Kim),
подсказавшего эту идею Хофштадтеру.&lt;/p&gt;
&lt;p&gt;Кимианский квайн представляет собой текст, который будучи поданым на вход
компилятора/интерпретатора, не распознается как корректный исходный текст, а приводит к выводу
сообщения об ошибке [31]. Причём такое сообщение побуквенно совпадает с самим кимианским
квайном. Т.е. при попытке запуска или компиляции, подобный код всё-таки воспроизводит себя, как
и положено квайну.&lt;/p&gt;
&lt;p&gt;Если обозначить среду исполнения для кимианского квайна (e.g., компилятор, интерпретатор или
командную оболочку) как функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-515.png&quot; style=&quot;{% style_stub jzaaaa 515 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; принимающую и возвращающую текстовую строку, то
некоторый кимианский квайн &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-516.png&quot; style=&quot;{% style_stub kzaaaa 516 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет неподвижной точкой этой функции: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-517.png&quot; style=&quot;{% style_stub lzaaaa 517 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Интересно, что в данном случае &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-518.png&quot; style=&quot;{% style_stub mzaaaa 518 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; может быть вычислен итерированием функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-519.png&quot; style=&quot;{% style_stub nzaaaa 519 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; начиная с
подходящего (иногда пустого) начального приближения. Т.е. алгоритм конструирования
кимианского квайна должен будет вычислить &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-520.png&quot; style=&quot;{% style_stub ozaaaa 520 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-521.png&quot; style=&quot;{% style_stub pzaaaa 521 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-522.png&quot; style=&quot;{% style_stub qzaaaa 522 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для некоторого начального значения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-523.png&quot; style=&quot;{% style_stub rzaaaa 523 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Следует заметить, что такая функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-524.png&quot; style=&quot;{% style_stub szaaaa 524 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; определена для всех &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-525.png&quot; style=&quot;{% style_stub tzaaaa 525 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (и к тому же всегда
завершается, если речь идет о компиляторе без поддержки вычислительно-универсальных
металингвистических средств, — например, подобных C++ шаблонам, — могущих приводить к
«зависанию» компилятора).&lt;/p&gt;
&lt;p&gt;В минирепозитории (gist) [33] можно найти простую реализацию подобного метода итеративного
конструирования кимианского квайна, выполненную на языке командной оболочки bash. Скрипт
принимает в качестве аргумента путь до исполняемого файла интерпретатора или компилятора,
запускает его и передает ему имя файла, хранящего начальное приближение. Результат из потоков
вывода сохраняется в этот же файл если этот результат отличается от содержимого файла, после
чего процесс повторяется. И так до стабилизации процесса, т.е. пока данный интерпретатор не
будет выдавать тот же текст, который он получил на вход.&lt;/p&gt;
&lt;p&gt;Эксперименты показывают, что таким способом неподвижная точки находится не всегда. И это не
удивительно. Теорема о неподвижной точке может быть переформулирована в форме утверждения о том,
что алгоритм преобразования программного кода не может всегда возвращать программу, отличную от
данной. И если неподвижная точка существует, то итерирование применения этого алгоритма &lt;em&gt;может&lt;/em&gt;
породить последовательность программ, сходящуюся к неподвижной точке. Но последовательность
может сойтись и к какому-нибудь циклу. Т.е. даже если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-526.png&quot; style=&quot;{% style_stub uzaaaa 526 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то возможно
существует последовательность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-527.png&quot; style=&quot;{% style_stub vzaaaa 527 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; такая, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-528.png&quot; style=&quot;{% style_stub wzaaaa 528 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-529.png&quot; style=&quot;{% style_stub xzaaaa 529 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Причем, возможно, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-530.png&quot; style=&quot;{% style_stub yzaaaa 530 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Обсуждаемый скрипт [33] имеют рудиментарную поддержку определения таких циклов, но для меня
остается открытым вопрос о возможности автоматического «преобразования» такого цикла в
настоящую неподвижную точку (формально, в цикл из одного элемента).&lt;/p&gt;
&lt;p&gt;(Несмотря на наблюдаемую эмпирическую сходимость итераций к неподвижной точке или к циклу, мне
неизвестны какие-либо особые свойства функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-531.png&quot; style=&quot;{% style_stub zzaaaa 531 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; гарантирующие стабилизацию процесса после
конечного количества шагов.)&lt;/p&gt;
&lt;h2 id=&quot;section-18&quot;&gt;Другие конструктивные теоремы о неподвижной точке&lt;/h2&gt;
&lt;p&gt;Пожалуй, это самый спекулятивный и неформальный подраздел этого сообщения. Здесь перечисляются
некоторые известные теоремы о неподвижных точках, которые, возможно, могли бы быть применены для
конструирования квайнов. Сама эта возможность находится под вопросом, но эти теоремы всё-же
заслуживают упоминания в таком контексте.&lt;/p&gt;
&lt;h3 id=&quot;section-19&quot;&gt;Первая рекурсивная теорема Клини&lt;/h3&gt;
&lt;p&gt;(Этот раздел написан по мотивам соответствующего материала из [50].)&lt;/p&gt;
&lt;p&gt;Для функций &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-532.png&quot; style=&quot;{% style_stub aabaaa 532 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-533.png&quot; style=&quot;{% style_stub babaaa 533 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; таких, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-534.png&quot; style=&quot;{% style_stub cabaaa 534 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-535.png&quot; style=&quot;{% style_stub dabaaa 535 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-536.png&quot; style=&quot;{% style_stub eabaaa 536 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; введем обозначение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-537.png&quot; style=&quot;{% style_stub fabaaa 537 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
читающееся как «&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-538.png&quot; style=&quot;{% style_stub gabaaa 538 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; продолжает &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-539.png&quot; style=&quot;{% style_stub habaaa 539 inline %}&quot; class=&quot;latex&quot;&gt;».&lt;/span&gt; (Другими словами, выполняется импликация
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-540.png&quot; style=&quot;{% style_stub iabaaa 540 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Функция называется конечной если она имеет конечную область определения. &lt;em&gt;Конечной частью&lt;/em&gt;
функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-541.png&quot; style=&quot;{% style_stub jabaaa 541 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; назовём конечную функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-542.png&quot; style=&quot;{% style_stub kabaaa 542 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Сопоставим функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-543.png&quot; style=&quot;{% style_stub labaaa 543 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
натуральное число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-544.png&quot; style=&quot;{% style_stub mabaaa 544 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Подразумевается, что существует алгоритм, который по числам &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-545.png&quot; style=&quot;{% style_stub nabaaa 545 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-546.png&quot; style=&quot;{% style_stub oabaaa 546 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; вычисляет &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-547.png&quot; style=&quot;{% style_stub pabaaa 547 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; если
существует &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-548.png&quot; style=&quot;{% style_stub qabaaa 548 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такая, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-549.png&quot; style=&quot;{% style_stub rabaaa 549 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-550.png&quot; style=&quot;{% style_stub sabaaa 550 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; определена в точке &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-551.png&quot; style=&quot;{% style_stub tabaaa 551 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Оператор &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-552.png&quot; style=&quot;{% style_stub uabaaa 552 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; называется рекурсивным оператором если существует вычислимая функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-553.png&quot; style=&quot;{% style_stub vabaaa 553 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
такая, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-554.png&quot; style=&quot;{% style_stub wabaaa 554 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; тогда и только тогда, когда существует конечная
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-555.png&quot; style=&quot;{% style_stub xabaaa 555 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такая, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-556.png&quot; style=&quot;{% style_stub yabaaa 556 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Оператор &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-557.png&quot; style=&quot;{% style_stub zabaaa 557 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; непрерывен если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-558.png&quot; style=&quot;{% style_stub abbaaa 558 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; тогда и только тогда, когда существует
конечная &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-559.png&quot; style=&quot;{% style_stub bbbaaa 559 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такая, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-560.png&quot; style=&quot;{% style_stub cbbaaa 560 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Оператор &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-561.png&quot; style=&quot;{% style_stub dbbaaa 561 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; называют монотонным, если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-562.png&quot; style=&quot;{% style_stub ebbaaa 562 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Утверждение (без доказательства).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Рекурсивные операторы непрерывны и монотонны.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема (без доказательства).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Для любого рекурсивного оператора &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-563.png&quot; style=&quot;{% style_stub fbbaaa 563 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; существует неподвижная точка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-564.png&quot; style=&quot;{% style_stub gbbaaa 564 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-565.png&quot; style=&quot;{% style_stub hbbaaa 565 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Причём
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-566.png&quot; style=&quot;{% style_stub ibbaaa 566 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – наименьшая из неподвижных точек, в том смысле, что если для какой-нибудь другой функции
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-567.png&quot; style=&quot;{% style_stub jbbaaa 567 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-568.png&quot; style=&quot;{% style_stub kbbaaa 568 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-569.png&quot; style=&quot;{% style_stub lbbaaa 569 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (Всюду определенная функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-570.png&quot; style=&quot;{% style_stub mbbaaa 570 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; автоматически
будет единственной неподвижной точкой.)&lt;/p&gt;
&lt;p&gt;Для демонстрации связи с квайнами в [50] (и это практически единственная обнаруженная мной в
литературе зацепка, связывающая первую рекурсивную теорему с квайнами) по-сути предлагается
попробовать в качестве рекурсивного оператора взять оператор, аналогичный оператору
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-571.png&quot; style=&quot;{% style_stub nbbaaa 571 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; определенному в разделе о теореме Роджерса (см. выше). Оператор
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-572.png&quot; style=&quot;{% style_stub obbaaa 572 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; преобразует программу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-573.png&quot; style=&quot;{% style_stub pbbaaa 573 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в программу, печатающую текст &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-574.png&quot; style=&quot;{% style_stub qbbaaa 574 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а по только
что изложенной первой рекурсивной теореме Клини, рекурсивный оператор (с семантикой оператора
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-575.png&quot; style=&quot;{% style_stub rbbaaa 575 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; должен иметь неподвижную точку &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-576.png&quot; style=&quot;{% style_stub sbbaaa 576 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и если из этого следует, что и сам
оператор &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-577.png&quot; style=&quot;{% style_stub tbbaaa 577 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; имеет неподвижную точку &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-578.png&quot; style=&quot;{% style_stub ubbaaa 578 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такую, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-579.png&quot; style=&quot;{% style_stub vbbaaa 579 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то, коль скоро программа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-580.png&quot; style=&quot;{% style_stub wbbaaa 580 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равна программе, печатающей себя, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-581.png&quot; style=&quot;{% style_stub xbbaaa 581 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; есть квайн.&lt;/p&gt;
&lt;p&gt;Здесь уместно прокомментировать согласованность этого вывода с данным выше определением
рекурсивного оператора, ведь &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-582.png&quot; style=&quot;{% style_stub ybbaaa 582 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; действует не на множестве вычислимых
функций, а на множестве исходных текстов программ. Идея состоит в том, что оператор
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-583.png&quot; style=&quot;{% style_stub zbbaaa 583 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; преобразуя некоторую программу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-584.png&quot; style=&quot;{% style_stub acbaaa 584 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в программу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-585.png&quot; style=&quot;{% style_stub bcbaaa 585 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; порождает
рекурсивный оператор &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-586.png&quot; style=&quot;{% style_stub ccbaaa 586 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; преобразующий функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-587.png&quot; style=&quot;{% style_stub dcbaaa 587 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в функцию
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-588.png&quot; style=&quot;{% style_stub ecbaaa 588 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Обозначим &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-589.png&quot; style=&quot;{% style_stub fcbaaa 589 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; тогда
вышеописанную идею можно проиллюстрировать следующей диаграммой:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-590.png&quot; style=&quot;{% style_stub gcbaaa 590 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;К оператору &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-591.png&quot; style=&quot;{% style_stub hcbaaa 591 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; напрямую применима первая рекурсивная теорема, т.е. существует &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-592.png&quot; style=&quot;{% style_stub icbaaa 592 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такая,
что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-593.png&quot; style=&quot;{% style_stub jcbaaa 593 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Из этого следует, что существуют программы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-594.png&quot; style=&quot;{% style_stub kcbaaa 594 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-595.png&quot; style=&quot;{% style_stub lcbaaa 595 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; причем
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-596.png&quot; style=&quot;{% style_stub mcbaaa 596 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Т.к., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-597.png&quot; style=&quot;{% style_stub ncbaaa 597 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-598.png&quot; style=&quot;{% style_stub ocbaaa 598 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-599.png&quot; style=&quot;{% style_stub pcbaaa 599 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Подставляя (4) в (5) и применяя определение оператора &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-600.png&quot; style=&quot;{% style_stub qcbaaa 600 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; получаем
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-601.png&quot; style=&quot;{% style_stub rcbaaa 601 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-602.png&quot; style=&quot;{% style_stub scbaaa 602 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; удовлетворяет «уравнению квайна» &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-603.png&quot; style=&quot;{% style_stub tcbaaa 603 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и,
соответственно, является квайном.&lt;/p&gt;
&lt;p&gt;(Для меня остается открытым вопрос о возможности применения первой рекурсивной теоремы для
автоматического конструирования квайнов, как в случае со второй рекурсивной теоремой.)&lt;/p&gt;
&lt;h3 id=&quot;section-20&quot;&gt;Теорема Клини о неподвижной точке [из теории решёток]&lt;/h3&gt;
&lt;p&gt;Произвольное отображение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-604.png&quot; style=&quot;{% style_stub ucbaaa 604 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; непрерывное по Скотту и определенное на полном
частично упорядоченном множестве &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-605.png&quot; style=&quot;{% style_stub vcbaaa 605 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с отношением порядка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-606.png&quot; style=&quot;{% style_stub wcbaaa 606 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; имеет наименьшую
неподвижную точку.&lt;/p&gt;
&lt;p&gt;Непрерывность по Скотту означает существование &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-607.png&quot; style=&quot;{% style_stub xcbaaa 607 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и выполнение  &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-608.png&quot; style=&quot;{% style_stub ycbaaa 608 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
для всякого направленного подмножества &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-609.png&quot; style=&quot;{% style_stub zcbaaa 609 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;section-21&quot;&gt;Теорема Кнастера-Тарского&lt;/h3&gt;
&lt;p&gt;В [37] приведена теорема о существовании неподвижных точек монотонных отображений на полной
решетке. Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-610.png&quot; style=&quot;{% style_stub adbaaa 610 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – монотонное отображение на полной решетке &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-611.png&quot; style=&quot;{% style_stub bdbaaa 611 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с отношением
частичного порядка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-612.png&quot; style=&quot;{% style_stub cdbaaa 612 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-613.png&quot; style=&quot;{% style_stub ddbaaa 613 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Теорема Тарского утверждает, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-614.png&quot; style=&quot;{% style_stub edbaaa 614 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; i.e. множество
неподвижных точек отображения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-615.png&quot; style=&quot;{% style_stub fdbaaa 615 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; само является непустой полной решеткой.&lt;/p&gt;
&lt;p&gt;В [38] доказана конструктивная версия этой теоремы. До этой работы, неподвижные точки монотонных
отображений уже конструировали как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-616.png&quot; style=&quot;{% style_stub gdbaaa 616 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-617.png&quot; style=&quot;{% style_stub hdbaaa 617 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-618.png&quot; style=&quot;{% style_stub idbaaa 618 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Но
это требовало от &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-619.png&quot; style=&quot;{% style_stub jdbaaa 619 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; непрерывности по Скотту. В [38] же доказывается теорема, которая не требует
от &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-620.png&quot; style=&quot;{% style_stub kdbaaa 620 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; этого свойства и утверждая, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-621.png&quot; style=&quot;{% style_stub ldbaaa 621 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; является полной решеткой
относительно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-622.png&quot; style=&quot;{% style_stub mdbaaa 622 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; предлагает, среди прочего, рецепт вычисления неподвижной точки в
виде &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-623.png&quot; style=&quot;{% style_stub ndbaaa 623 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Здесь &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-624.png&quot; style=&quot;{% style_stub odbaaa 624 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; определяется как предел стационарной последовательности
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-625.png&quot; style=&quot;{% style_stub pdbaaa 625 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; при &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-626.png&quot; style=&quot;{% style_stub qdbaaa 626 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Считается, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-627.png&quot; style=&quot;{% style_stub rdbaaa 627 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для предельного ординала &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-628.png&quot; style=&quot;{% style_stub sdbaaa 628 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Под стационарностью понимается, что начиная с
некоторго индекса, элементы последовательности имеют одно и то же значение. Для корректного
погружения в использованные в [38] трансфинитные определения необходимо чтение оригинальной
статьи.&lt;/p&gt;
&lt;p&gt;(Эти результаты обобщаются на случай полных частично упорядоченных множеств, только
направленные, а не произвольные подмножества которых обязаны иметь супремум.)&lt;/p&gt;
&lt;h2 id=&quot;section-22&quot;&gt;Комбинатор неподвижной точки в лямбда-исчислении&lt;/h2&gt;
&lt;p&gt;В &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-629.png&quot; style=&quot;{% style_stub tdbaaa 629 inline %}&quot; class=&quot;latex&quot;&gt;-исчислении&lt;/span&gt; [34] для реализации рекурсии используются комбинаторы неподвижной точки,
в основном &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-630.png&quot; style=&quot;{% style_stub udbaaa 630 inline %}&quot; class=&quot;latex&quot;&gt;-комбинатор.&lt;/span&gt; Этот комбинатор определяется уравнением &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-631.png&quot; style=&quot;{% style_stub vdbaaa 631 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и в соответствии с этим определением вычисляет неподвижную точку функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-632.png&quot; style=&quot;{% style_stub wdbaaa 632 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
т.е. такое выражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-633.png&quot; style=&quot;{% style_stub xdbaaa 633 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-634.png&quot; style=&quot;{% style_stub ydbaaa 634 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Если конкретная реализация &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-635.png&quot; style=&quot;{% style_stub zdbaaa 635 inline %}&quot; class=&quot;latex&quot;&gt;-исчисления&lt;/span&gt; поддерживает рекурсивные определения именованных
символов, то вышеприведенного определения достаточно для работы с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-636.png&quot; style=&quot;{% style_stub aebaaa 636 inline %}&quot; class=&quot;latex&quot;&gt;-комбинатором&lt;/span&gt;
(могут возразить, что в таком случае он не особо-то и нужен; однако, здесь &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-637.png&quot; style=&quot;{% style_stub bebaaa 637 inline %}&quot; class=&quot;latex&quot;&gt;-комбинатор&lt;/span&gt; может
служить полезной обёрткой для некоторых функций, позволяющей, к примеру, добавить временное
хранение промежуточных результатов с целью исключения их повторного вычисления, — т.е.,
кэширование, — и, соответственно, получить ускорение в духе динамического программирования).&lt;/p&gt;
&lt;p&gt;В чистом же &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-638.png&quot; style=&quot;{% style_stub cebaaa 638 inline %}&quot; class=&quot;latex&quot;&gt;-исчислении&lt;/span&gt; требуется определить &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-639.png&quot; style=&quot;{% style_stub debaaa 639 inline %}&quot; class=&quot;latex&quot;&gt;-комбинатор&lt;/span&gt; в явном виде,
например как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-640.png&quot; style=&quot;{% style_stub eebaaa 640 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (известный как комбинатор Карри или парадоксальный комбинатор) или, в случае
использования императивного языка, задействовать [энергичный] комбинатор Тьюринга &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-641.png&quot; style=&quot;{% style_stub febaaa 641 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-642.png&quot; style=&quot;{% style_stub gebaaa 642 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема о неподвижной точке.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Несмотря на неочевидность этого утверждения, в нетипизированном &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-643.png&quot; style=&quot;{% style_stub hebaaa 643 inline %}&quot; class=&quot;latex&quot;&gt;-исчислении&lt;/span&gt; любое
выражение имеет неподвижную точку (хотя бы одну).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-644.png&quot; style=&quot;{% style_stub iebaaa 644 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Комбинатор Тьюринга есть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-645.png&quot; style=&quot;{% style_stub jebaaa 645 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Утверждается, что для любого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-646.png&quot; style=&quot;{% style_stub kebaaa 646 inline %}&quot; class=&quot;latex&quot;&gt;-выражения&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-647.png&quot; style=&quot;{% style_stub lebaaa 647 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; выражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-648.png&quot; style=&quot;{% style_stub mebaaa 648 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; есть
его неподвижная точка. Чтобы увидеть это, запишем следующую цепочку уравнений:&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/3-649.png&quot; style=&quot;{% style_stub nebaaa 649 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-650.png&quot; style=&quot;{% style_stub oebaaa 650 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; обозначает последовательность из нуля или нескольких шагов
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-651.png&quot; style=&quot;{% style_stub pebaaa 651 inline %}&quot; class=&quot;latex&quot;&gt;-редукции.&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-652.png&quot; style=&quot;{% style_stub qebaaa 652 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Теперь &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-653.png&quot; style=&quot;{% style_stub rebaaa 653 inline %}&quot; class=&quot;latex&quot;&gt;-комбинатор&lt;/span&gt; может быть применен для вычисления значений функций, вызывающих
сами себя, в среде, не имеющей возможности выполнять именованный рекурсивный вызов или вообще не
поддерживающей именование объектов.&lt;/p&gt;
&lt;p&gt;Например, если требуется вычислить функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-654.png&quot; style=&quot;{% style_stub sebaaa 654 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; вызывающую саму себя
по имени &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-655.png&quot; style=&quot;{% style_stub tebaaa 655 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то можно определить новую функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-656.png&quot; style=&quot;{% style_stub uebaaa 656 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; принимающую &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-657.png&quot; style=&quot;{% style_stub vebaaa 657 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; как аргумент:
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-658.png&quot; style=&quot;{% style_stub webaaa 658 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (а при использовании индексов де Брёйна или
бинарного лямбда-исчисления мы можем избавиться и от именованных переменных вовсе). После
определения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-659.png&quot; style=&quot;{% style_stub xebaaa 659 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; мы можем вычислить &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-660.png&quot; style=&quot;{% style_stub yebaaa 660 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-661.png&quot; style=&quot;{% style_stub zebaaa 661 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; потому что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-662.png&quot; style=&quot;{% style_stub afbaaa 662 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; есть неподвижная
точка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-663.png&quot; style=&quot;{% style_stub bfbaaa 663 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-664.png&quot; style=&quot;{% style_stub cfbaaa 664 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-665.png&quot; style=&quot;{% style_stub dfbaaa 665 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; как было сказано выше,
как раз и находит такую неподвижную точку. Желающие могут непосредственной подстановкой
убедиться, что в этом случае действительно выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-666.png&quot; style=&quot;{% style_stub efbaaa 666 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Учитывая универсальность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-667.png&quot; style=&quot;{% style_stub ffbaaa 667 inline %}&quot; class=&quot;latex&quot;&gt;-исчисления&lt;/span&gt; и вышеприведенную теорему о неподвижной точке [в
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-668.png&quot; style=&quot;{% style_stub gfbaaa 668 inline %}&quot; class=&quot;latex&quot;&gt;-исчислении],&lt;/span&gt; естественно возникает идея об использовании комбинатора неподвижной точки
для конструирования квайнов. (См. также [2, 47].)&lt;/p&gt;
&lt;p&gt;(Утверждение о существовании комбинатора неподвижной точки практически эквивалентно
вышеприведенный первой рекурсивной теореме Клини, но выглядит более конкретным.)&lt;/p&gt;
&lt;h2 id=&quot;section-23&quot;&gt;Логическое программирование в ограничениях&lt;/h2&gt;
&lt;p&gt;В [12, 49] приводится интересный метод генерации квайнов с использованием логического
программирования. Авторы использовали язык логического программирования miniKanren [52],
позволяющий написать на нём аналог «основного уравнения квайнов» &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-669.png&quot; style=&quot;{% style_stub hfbaaa 669 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
и дать системе решить его относительно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-670.png&quot; style=&quot;{% style_stub ifbaaa 670 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;С использованием реализации miniKanren, выполненной на языке scheme, квайны можно
генерировать примерно так (&lt;code&gt;q.scm&lt;/code&gt; взят из [49]):&lt;/p&gt;
&lt;div class=&quot;language-scheme highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;q.scm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;eval-expo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Квайны вычисляются быстро (за секунду) и имеют малые размеры.&lt;/p&gt;
&lt;p&gt;(Существует множество реализаций miniKanren и на других языках, e.g., на ECMAScript/JavaScript,
Python, Ruby, etc.)&lt;/p&gt;
&lt;h2 id=&quot;section-24&quot;&gt;Эволюционные алгоритмы&lt;/h2&gt;
&lt;p&gt;Крайне интересной представляется потенциальная возможность генерации квайнов с помощью
генетических алгоритмов. Среди многих проблем, возникающих при генерации программ эволюционными
методами, выделяется проблема сохранения допустимости или синтаксической «корректности»
программ при действии генетических операторов (кроссовер, мутация).&lt;/p&gt;
&lt;p&gt;В этом смысле, одним из наиболее пригодных представлений для инкрементной эволюционной
генерации, являются искусственные нейронные сети (далее ИНС или нейросети). Будучи сетями
однотипных нелинейных сумматоров, работа которых зависит от весов связей (синапсов) между ними,
нейросети продолжают сохранять работоспособность даже при почти случайных
изменениях/«повреждениях» в матрице их весовых коэффициентов. Это довольно сильно
контрастирует с традиционными языками программирования, программы на которых с гораздо большей
вероятностью подвержены выходу из строя при малейших необдуманных модификациях их исходного
текста.&lt;/p&gt;
&lt;p&gt;Квайны в виде нейросетей уже известны. В [41] описана ИНС, обучающаяся выводить значения своих
же синаптических коэффициентов. Я же хотел бы здесь сосредоточится на другом способе генерации
квайнов, а именно на конструировании программ посредством применения генетических алгоритмов к
промежуточному представлению на основе нейросетей.&lt;/p&gt;
&lt;p&gt;Есть интересный экспериментальный язык Anne, [40], придуманный специально для работы с
нейросетями и транслятор neuralbf [16, 51] того же автора, преобразующий программу на bf в
описание рекуррентной ИНС. Последняя работа (кому-то могущая показаться несерьёзной)
фокусируется на применении генетических алгоритмов для совершенствования и исправления уже
написанных вручную программ (вместо их генерации без начального приближения).&lt;/p&gt;
&lt;h2 id=&quot;section-25&quot;&gt;Цепные квайны&lt;/h2&gt;
&lt;p&gt;Назовём &lt;em&gt;цепным квайном&lt;/em&gt; (или итеративным квайном) с периодом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-671.png&quot; style=&quot;{% style_stub jfbaaa 671 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; последовательность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-672.png&quot; style=&quot;{% style_stub kfbaaa 672 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; программ
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-673.png&quot; style=&quot;{% style_stub lfbaaa 673 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такую, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-674.png&quot; style=&quot;{% style_stub mfbaaa 674 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-675.png&quot; style=&quot;{% style_stub nfbaaa 675 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Можно получить интересное обобщение — многоязыковой или «релейный» квайн — если заменить в
только-что данном определении скобки &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-676.png&quot; style=&quot;{% style_stub ofbaaa 676 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-677.png&quot; style=&quot;{% style_stub pfbaaa 677 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-678.png&quot; style=&quot;{% style_stub qfbaaa 678 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – возможно различные языки программирования
(подразумевается &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-679.png&quot; style=&quot;{% style_stub rfbaaa 679 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема (без доказательства).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Цепные квайны существуют для любого периода &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-680.png&quot; style=&quot;{% style_stub sfbaaa 680 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Всякий, кто пытался писать квайны и цепные квайны, не мог не отметить некоторое отличие в
сложности их написания – цепные квайны [при &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-681.png&quot; style=&quot;{% style_stub tfbaaa 681 inline %}&quot; class=&quot;latex&quot;&gt;]&lt;/span&gt; обычно проще истинных квайнов (i.e., тоже
цепных квайнов, но с периодом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-682.png&quot; style=&quot;{% style_stub ufbaaa 682 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Соответственно, не может не возникнуть вопрос о реализуемости полностью автоматического
преобразования данной последовательности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-683.png&quot; style=&quot;{% style_stub vfbaaa 683 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в настоящий квайн &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-684.png&quot; style=&quot;{% style_stub wfbaaa 684 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-26&quot;&gt;Генератор квайнов, не зависимый от языка&lt;/h2&gt;
&lt;p&gt;В разделе о конструировании квайнов на основе второй рекурсивной теоремы Клини, приводился
готовый рецепт, алгоритм генерации квайна для конкретного заранее выбранного языка
программирования. (Похожий алгоритм возможен и в контексте доказательства теоремы Роджерса.)
Возможно, что слово «алгоритм» здесь можно понимать более формально и буквально.&lt;/p&gt;
&lt;p&gt;Представляется интересным вопрос о существовании программы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-685.png&quot; style=&quot;{% style_stub xfbaaa 685 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; — «квайнтификатора», —
генерирующей квайн на указанном языке &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-686.png&quot; style=&quot;{% style_stub yfbaaa 686 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с использованием некоторого количества образцов кода
на этом языке. Причем и разумной спецификацией языка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-687.png&quot; style=&quot;{% style_stub zfbaaa 687 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и одновременно образцом кода на нём
может служить интерпретатор языка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-688.png&quot; style=&quot;{% style_stub agbaaa 688 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (существующий по теореме об универсальной функции).&lt;/p&gt;
&lt;p&gt;Чуть более формально задача может быть поставлена так. Пусть дан интерпретатор &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-689.png&quot; style=&quot;{% style_stub bgbaaa 689 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; языка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-690.png&quot; style=&quot;{% style_stub cgbaaa 690 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
написанный на своем же входном языке, т.е. для любой программы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-691.png&quot; style=&quot;{% style_stub dgbaaa 691 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на языка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-692.png&quot; style=&quot;{% style_stub egbaaa 692 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-693.png&quot; style=&quot;{% style_stub fgbaaa 693 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Пусть также &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-694.png&quot; style=&quot;{% style_stub ggbaaa 694 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; оттранслирован
на референсный язык (семантические скобки без индекса) и существует на нём в виде программы
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-695.png&quot; style=&quot;{% style_stub hgbaaa 695 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; В этом случае справедливо &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-696.png&quot; style=&quot;{% style_stub igbaaa 696 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Спрашивается, как может выглядеть программа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-697.png&quot; style=&quot;{% style_stub jgbaaa 697 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такая, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-698.png&quot; style=&quot;{% style_stub kgbaaa 698 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-699.png&quot; style=&quot;{% style_stub lgbaaa 699 inline %}&quot; class=&quot;latex&quot;&gt;?&lt;/span&gt; Выше мы видели, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-700.png&quot; style=&quot;{% style_stub mgbaaa 700 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; есть неподвижная точка
(по Роджерсу) оператора &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-701.png&quot; style=&quot;{% style_stub ngbaaa 701 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; При попытке реализовать &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-702.png&quot; style=&quot;{% style_stub ogbaaa 702 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выясняется,
что структура соответствующей программы сильно схожа со структурой интерпретатора. Возможно, это
сходство можно использовать для написания &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-703.png&quot; style=&quot;{% style_stub pgbaaa 703 inline %}&quot; class=&quot;latex&quot;&gt;…&lt;/span&gt; Но это требует дальнейшего обдумывания.&lt;/p&gt;
&lt;p&gt;Вместо самоинтерпретаторов можно использовать обычно более простые программы, —
&lt;em&gt;специализаторы,&lt;/em&gt; — реализующие &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/3-704.png&quot; style=&quot;{% style_stub qgbaaa 704 inline %}&quot; class=&quot;latex&quot;&gt;-функцию,&lt;/span&gt; ведь именно она является главным ингредиентом
(после диагонализации, конечно) в доказательстве теоремы Клини о рекурсии. (В следующих
сообщениях этот вопрос, возможно, будет исследован более подробно.)&lt;/p&gt;
&lt;h1 id=&quot;section-27&quot;&gt;Заключение&lt;/h1&gt;
&lt;p&gt;Целью этого сообщения была демонстрация возможности автоматического конструирования квайнов на
языке редактора sed с использованием доказательства второй рекурсивной теоремы Клини в качестве
основы. Результат проведенного эксперимента можно считать положительным, хотя &lt;em&gt;автоматическим&lt;/em&gt;
такой способ написания квайнов можно назвать только в смысле достаточности запуска единственного
скрипта &lt;code&gt;generate.sh&lt;/code&gt; и ликвидации наиболее сложной, и, если можно так выразиться, творческой
составляющей в конструировании самореплицирующейся системы.&lt;/p&gt;
&lt;p&gt;В целом, сообщение уже немного вышло за рамки очерченных целей. Но о квайнах можно сказать
больше… В следующих сообщениях этой серии.&lt;/p&gt;
&lt;h1 id=&quot;section-28&quot;&gt;Ссылки&lt;/h1&gt;
&lt;div class=&quot;bib&quot;&gt;
&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&quot;http://www.madore.org/~david/computers/quine.html&quot;&gt;http://www.madore.org/~david/computers/quine.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&quot;http://math.berkeley.edu/~kmill/blog/blog_2018_5_31_universality_quines.html&quot;&gt;http://math.berkeley.edu/~kmill/blog/blog_2018_5_31_universality_quines.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&quot;http://en.wikipedia.org/wiki/Smn_theorem&quot;&gt;http://en.wikipedia.org/wiki/Smn_theorem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[4] &lt;a href=&quot;http://en.wikipedia.org/wiki/partial_evaluation&quot;&gt;http://en.wikipedia.org/wiki/partial_evaluation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[5] &lt;a href=&quot;http://fi.ftmr.info&quot;&gt;http://fi.ftmr.info&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[6] &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%B4%D0%B8%D0%B0%D0%B3%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B0%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82&quot;&gt;http://ru.wikipedia.org/wiki/диагональный_аргумент&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[7] &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%9A%D0%B0%D0%BD%D1%82%D0%BE%D1%80%D0%B0&quot;&gt;http://ru.wikipedia.org/wiki/теорема_Кантора&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[8] &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8&quot;&gt;http://ru.wikipedia.org/wiki/проблема_остановки&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[9] &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0&quot;&gt;http://ru.wikipedia.org/wiki/автомат_фон_Неймана&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[10] &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%B7%D0%BE%D0%BD%D0%B4_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0&quot;&gt;http://ru.wikipedia.org/wiki/зонд_фон_Неймана&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[11] Jiazhen Cai, Robert Paige, Program derivation by fixed point computation, 1989&lt;/li&gt;
&lt;li&gt;[12] William E.Byrd, Eric Holk, Daniel P.Friedman, miniKanren, live and untagged: Quine generation via relational interpreters, 2012&lt;/li&gt;
&lt;li&gt;[14] S.C.Kleene, Introduction to Meta-Mathematics, 1952&lt;/li&gt;
&lt;li&gt;[15] &lt;a href=&quot;http://en.wikipedia.org/wiki/Quine%27s_paradox&quot;&gt;http://en.wikipedia.org/wiki/Quine%27s_paradox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[16] &lt;a href=&quot;http://www.domob.eu/projects/neuralbf.php&quot;&gt;http://www.domob.eu/projects/neuralbf.php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[17] &lt;a href=&quot;https://github.com/MakeNowJust/quine/blob/master/quine.sed&quot;&gt;https://github.com/MakeNowJust/quine/blob/master/quine.sed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[18] &lt;a href=&quot;https://github.com/MakeNowJust/quine&quot;&gt;https://github.com/MakeNowJust/quine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[19] H.Rogers, Theory of Recursive Functions and Effective Computability&lt;/li&gt;
&lt;li&gt;[20] T.A.Hansen, T.Nikolajsen, J.L.Traff, N.D.Jones, Experiments with Implementation of two Theoretical Constructions&lt;/li&gt;
&lt;li&gt;[21] G.Bonfante, M.Kaczmarek, J-Y.Marion, Toward an Abstract Computer Virology&lt;/li&gt;
&lt;li&gt;[22] G.Bonfante, M.Kaczmarek, J-Y.Marion, A Classification of Viruses through Recursion Theorems, 2007&lt;/li&gt;
&lt;li&gt;[23] Julia L. Lawall, Olivier Danvy, Continuation-Based Partial Evaluation&lt;/li&gt;
&lt;li&gt;[24] Anders Bondorf, Improving Binding Times Without Explicit CPS-Conversion&lt;/li&gt;
&lt;li&gt;[25] D.A.Wheeler, Fully Countering Trusting Trust through Diverse Double-Compiling, 2009&lt;/li&gt;
&lt;li&gt;[26] Douglas R.Hofstadter, Goedel, Escher, Bach: an Eternal Golden Braid, 1979&lt;/li&gt;
&lt;li&gt;[27] P.-M. Binder, Theories of almost everything, 2008&lt;/li&gt;
&lt;li&gt;[28] H.G.Rice, Classes of recursively enumerable sets and their decision problems, 1953&lt;/li&gt;
&lt;li&gt;[29] &lt;a href=&quot;https://en.wikipedia.org/wiki/Rice_theorem&quot;&gt;https://en.wikipedia.org/wiki/Rice_theorem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[30] Gary P.Thompson II, The quine page
(self-reproducing code), &lt;a href=&quot;http://www.nyx.net/~gthompso/quine.htm&quot;&gt;http://www.nyx.net/~gthompso/quine.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[31] &lt;a href=&quot;http://www.nyx.net/~gthompso/self_kim.txt&quot;&gt;http://www.nyx.net/~gthompso/self_kim.txt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[32] &lt;a href=&quot;http://www.latrobe.edu.au/phimvt/joy&quot;&gt;http://www.latrobe.edu.au/phimvt/joy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[33] &lt;a href=&quot;https://gist.github.com/Circiter/7152686&quot;&gt;https://gist.github.com/Circiter/7152686&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[34] &lt;a href=&quot;http://en.wikipedia.org/wiki/lambda_calculus&quot;&gt;http://en.wikipedia.org/wiki/lambda_calculus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[35] Lawrence S.Moss, Recursion Theorems and Self-Replication Via Text Register Machine
Programs&lt;/li&gt;
&lt;li&gt;[36] Neil Jones, Computer implementation and application of Kleene’s s-m-n and recursion
theorem.&lt;/li&gt;
&lt;li&gt;[37] A.Tarski, A lattice theoretical fixpoint theorem and its applications, 1955&lt;/li&gt;
&lt;li&gt;[38] P.Cousot, R.Cousot, Constructive versions of Tarski’s fixed point theorems, 1979&lt;/li&gt;
&lt;li&gt;[39] J.Case, S.E.Moelius III, Program Self-Reference in Constructive Scott Subdomains, 2009&lt;/li&gt;
&lt;li&gt;[40] &lt;a href=&quot;http://compann.sourceforge.net&quot;&gt;http://compann.sourceforge.net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[41] O.Chang, H.Lipson, Neural Network Quine, 2018&lt;/li&gt;
&lt;li&gt;[42] &lt;a href=&quot;http://en.wikipedia.org/wiki/quine&quot;&gt;http://en.wikipedia.org/wiki/quine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[43] F.William Lawvere, Diagonal arguments and cartesian closed categories, 1969&lt;/li&gt;
&lt;li&gt;[44] Noson S.Yanofsky, A Universal Approach to Self-Referential Paradoxes, Incompleteness and
Fixed Points, 2003&lt;/li&gt;
&lt;li&gt;[45] Jean-Yves Marion, From Turing machines to computer viruses, 2012&lt;/li&gt;
&lt;li&gt;[46] &lt;a href=&quot;https://github.com/Circiter/quine-kleene-generator&quot;&gt;https://github.com/Circiter/quine-kleene-generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[47] Kleene Second Recursion Theorem: A Functional Pearl // Proc. ACM
Program. Lang., Vol 1, 2018&lt;/li&gt;
&lt;li&gt;[48] Дж. фон Нейман, Теория самовоспроизводящихся автоматов, 1971&lt;/li&gt;
&lt;li&gt;[49] &lt;a href=&quot;https://github.com/webyrd/quines&quot;&gt;https://github.com/webyrd/quines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[50] В.М.Зюзьков, Теория алгоритмов: Учебное пособие, 2005&lt;/li&gt;
&lt;li&gt;[51] &lt;a href=&quot;https://gitlab.com/domob/neuralbf&quot;&gt;https://gitlab.com/domob/neuralbf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[52] &lt;a href=&quot;https://github.com/miniKanren&quot;&gt;https://github.com/miniKanren&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[53] &lt;a href=&quot;http://www.michaelwehar.com/quines&quot;&gt;http://www.michaelwehar.com/quines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[54] &lt;a href=&quot;http://www.keithschwarz.com/kleene&quot;&gt;http://www.keithschwarz.com/kleene&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[55] &lt;a href=&quot;http://www.nyx.net/~gthompso/quine-1.1.0.tar.gz&quot;&gt;http://www.nyx.net/~gthompso/quine-1.1.0.tar.gz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[56] J.C.Owings младший, Diagonalization and the Recursion Theorem, 1973&lt;/li&gt;
&lt;li&gt;[57] E.Alonso, M.Manzano, Diagonalization and Church’s Thesis: Kleene’s Homework, 2005&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Теория насыщения. Часть I.</title>
   <link href="http://circiter.tk/saturation-theory-part-1"/>
   <updated>2022-05-07T02:05:34+00:00</updated>
   <id>http://circiter.tk/saturation-theory-part-1</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;Вводные замечания&lt;/h1&gt;
&lt;p&gt;Изложение придётся начать с оговорок по поводу выбора использующихся далее терминов
«насыщенность», «насыщение» и т.д. Поиск в интернете показывает, что в теоретико-числовом
контексте понятие насыщенности, так или иначе, изредка употребляется. Где-то это может означать
ограниченность набора цифр, использующихся для записи числа (e.g., попадалось определение
насыщенного числа, как многоразрядного числа, десятичная запись которого содержит только две
цифры, возможно применённых многократно и в произвольной последовательности), а где-то о
насыщенности говорят при обсуждении некоторых вариантов машинной арифметики (вроде стандартной
реализации чисел с плавающей точкой во многих современных процессорах и языках
программирования), в которых при переполнении число «насыщается», приобретая значение
ближайшего экстремального значения (вместо «прыжка» в противоположный конец машинной числовой
оси как в модулярной арифметике) &lt;a class=&quot;citation&quot; href=&quot;#wiki-saturation&quot;&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но за исключением эти редких употреблений понятия насыщения числа, термин «насыщенное число»
трудно назвать стандартным (ещё раз подчеркну, что трудно именно с точки зрения поверхностного
обследования свободно доступных источников при помощи популярных поисковых систем). Поэтому,
заметив интересный феномен при проведении кое-каких численных экспериментов, я поспешил
использовать это почти свободное слово для введения условно нового термина, именно с целью
описания этого феномена в настоящем дневнике. (Если читателям известны более уместные термины,
то рад бы был услышать возможные варианты.)&lt;/p&gt;
&lt;p&gt;В моём случае, насыщенность будет использоваться для характеризации «состава», т.е.
разнообразия простых делителей, довольно специфичных теоретико-числовых объектов, а именно
частичных/частных сумм делителей целых чисел (далее я буду сосредоточен на натуральных числах).&lt;/p&gt;
&lt;p&gt;Очень похожие проблемы глубоко исследовались Эрдёшем; возможно, знатоки его работ узнают здесь
что-нибудь знакомое (e.g. «странные числа» &lt;a class=&quot;citation&quot; href=&quot;#benkoski1974&quot;&gt;[2]&lt;/a&gt;). Хотя, некоторая новизна,
я надеюсь, всё-таки остаётся. :)&lt;/p&gt;
&lt;h1 id=&quot;section-1&quot;&gt;Некоторые определения&lt;/h1&gt;
&lt;p&gt;Пусть дано число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-0.png&quot; style=&quot;{% style_stub rgbaaa 0 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Все его делители образуют множество &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-1.png&quot; style=&quot;{% style_stub sgbaaa 1 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (мощность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-2.png&quot; style=&quot;{% style_stub tgbaaa 2 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; традиционно обозначается &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-3.png&quot; style=&quot;{% style_stub ugbaaa 3 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt; На &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-4.png&quot; style=&quot;{% style_stub vgbaaa 4 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; возьмём
какое-нибудь отношение полного порядка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-5.png&quot; style=&quot;{% style_stub wgbaaa 5 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; относительно которого делители будут
упорядочены. В частности, для получения минимального элемента относительно этого отношения будет
использоваться символ &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-6.png&quot; style=&quot;{% style_stub xgbaaa 6 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Если в качестве &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-7.png&quot; style=&quot;{% style_stub ygbaaa 7 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; используется обычное отношение
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-8.png&quot; style=&quot;{% style_stub zgbaaa 8 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то будем говорить о каноническом порядке (упорядочивании) делителей.&lt;/p&gt;
&lt;p&gt;Введём последовательность делителей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-9.png&quot; style=&quot;{% style_stub ahbaaa 9 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (N.B. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-10.png&quot; style=&quot;{% style_stub bhbaaa 10 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Определение&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Последовательность частичных сумм делителей обозначим &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-11.png&quot; style=&quot;{% style_stub chbaaa 11 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и определим индуктивно:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-12.png&quot; style=&quot;{% style_stub dhbaaa 12 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;(&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-13.png&quot; style=&quot;{% style_stub ehbaaa 13 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; здесь как колёса у рыбы, но, формально, эта частичная сумма соответствует
суммированию по пустому подмножеству делителей; так что пусть пока будет так.)&lt;/p&gt;
&lt;p&gt;В отличии от частичных сумм делителей, сумма &lt;em&gt;всех&lt;/em&gt; делителей является очень известным и важным
объектом в теории чисел. Обычно сумму всех делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-14.png&quot; style=&quot;{% style_stub fhbaaa 14 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; обозначают как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-15.png&quot; style=&quot;{% style_stub ghbaaa 15 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
хотя в классической работе Эйлера &lt;a class=&quot;citation&quot; href=&quot;#euler1760&quot;&gt;[3]&lt;/a&gt; (см. также перевод с латыни &lt;a class=&quot;citation&quot; href=&quot;#euler1760-translation&quot;&gt;[4]&lt;/a&gt;) используется интегралоподобный символ &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-16.png&quot; style=&quot;{% style_stub hhbaaa 16 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; позволяющий немного
экономить на скобках.&lt;/p&gt;
&lt;p&gt;Функция Эйлера &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-17.png&quot; style=&quot;{% style_stub ihbaaa 17 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; подсчитывает количество чисел, не превышающих &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-18.png&quot; style=&quot;{% style_stub jhbaaa 18 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и взаимно простых
с ним. Т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-19.png&quot; style=&quot;{% style_stub khbaaa 19 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt; Кроме количества чисел, меньших &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-20.png&quot; style=&quot;{% style_stub lhbaaa 20 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и взаимно простых с ним, далее может
понадобиться их произведение: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-21.png&quot; style=&quot;{% style_stub mhbaaa 21 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а
также произведение простых чисел, на которые не делится &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-22.png&quot; style=&quot;{% style_stub nhbaaa 22 inline %}&quot; class=&quot;latex&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-23.png&quot; style=&quot;{% style_stub ohbaaa 23 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-24.png&quot; style=&quot;{% style_stub phbaaa 24 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; –
множество всех простых чисел.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Вместо &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-25.png&quot; style=&quot;{% style_stub qhbaaa 25 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-26.png&quot; style=&quot;{% style_stub rhbaaa 26 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет писаться просто &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-27.png&quot; style=&quot;{% style_stub shbaaa 27 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-28.png&quot; style=&quot;{% style_stub thbaaa 28 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; соответственно. (Связь
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-29.png&quot; style=&quot;{% style_stub uhbaaa 29 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с группами Эйлера могла бы быть важным преимуществом, но пока я буду, в основном,
пользоваться &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-30.png&quot; style=&quot;{% style_stub vhbaaa 30 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt; Введём функцию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-31.png&quot; style=&quot;{% style_stub whbaaa 31 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; подсчитывающую количество простых делителей (размер
факторизации) числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-32.png&quot; style=&quot;{% style_stub xhbaaa 32 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-33.png&quot; style=&quot;{% style_stub yhbaaa 33 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-34.png&quot; style=&quot;{% style_stub zhbaaa 34 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-35.png&quot; style=&quot;{% style_stub aibaaa 35 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-36.png&quot; style=&quot;{% style_stub bibaaa 36 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – максимальная степень &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-37.png&quot; style=&quot;{% style_stub cibaaa 37 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такая, что
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-38.png&quot; style=&quot;{% style_stub dibaaa 38 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Тогда &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-39.png&quot; style=&quot;{% style_stub eibaaa 39 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (может быть для неё и
есть какое-нибудь стандартное обозначения, но мне оно не известно).&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Теперь можно приступить к определению насыщенности как таковой.&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Определение&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-40.png&quot; style=&quot;{% style_stub fibaaa 40 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; назовём &lt;em&gt;слабо насыщенным&lt;/em&gt; если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-41.png&quot; style=&quot;{% style_stub gibaaa 41 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Другими словами, если обозначить через &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-42.png&quot; style=&quot;{% style_stub hibaaa 42 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; множество различных простых делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-43.png&quot; style=&quot;{% style_stub iibaaa 43 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
то для слабо насыщенного числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-44.png&quot; style=&quot;{% style_stub jibaaa 44 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-45.png&quot; style=&quot;{% style_stub kibaaa 45 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.е. слабо насыщенное число
использует в своей факторизации все факторы числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-46.png&quot; style=&quot;{% style_stub libaaa 46 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но, возможно, в других количиствах, и, в
общем случае, в слабо насыщенное число могут входит и другие простые делители, отсутствующие в
факторизации &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-47.png&quot; style=&quot;{% style_stub mibaaa 47 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Определение&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-48.png&quot; style=&quot;{% style_stub nibaaa 48 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; назовём &lt;em&gt;насыщенным&lt;/em&gt; если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-49.png&quot; style=&quot;{% style_stub oibaaa 49 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; или, что то же самое, если
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-50.png&quot; style=&quot;{% style_stub pibaaa 50 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;В факторизации насыщенного числа обязательно присутствуют все факторы числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-51.png&quot; style=&quot;{% style_stub qibaaa 51 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; причём в тех же
степенях (количествах), но могут, кроме этого, быть и другие произвольные факторы.&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Определение&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-52.png&quot; style=&quot;{% style_stub ribaaa 52 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – &lt;em&gt;сильно насыщенно&lt;/em&gt; если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-53.png&quot; style=&quot;{% style_stub sibaaa 53 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; или,
эквивалентно, если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-54.png&quot; style=&quot;{% style_stub tibaaa 54 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-55.png&quot; style=&quot;{% style_stub uibaaa 55 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (не следует путать с
количеством делителей, в этом сообщении обозначаемым через &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-56.png&quot; style=&quot;{% style_stub vibaaa 56 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; определяется через
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-57.png&quot; style=&quot;{% style_stub wibaaa 57 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; для последовательности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-58.png&quot; style=&quot;{% style_stub xibaaa 58 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такой, что
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-59.png&quot; style=&quot;{% style_stub yibaaa 59 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-60.png&quot; style=&quot;{% style_stub zibaaa 60 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (Условие &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-61.png&quot; style=&quot;{% style_stub ajbaaa 61 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; имеет тот же смысл, что
и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-62.png&quot; style=&quot;{% style_stub bjbaaa 62 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; также следует заметить, что вместо &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-63.png&quot; style=&quot;{% style_stub cjbaaa 63 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно было бы использовать
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-64.png&quot; style=&quot;{% style_stub djbaaa 64 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Иначе выражаясь, насыщенное число является сильно насыщенным если в его факторизации нет простых
множителей, не входящих в факторизацию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-65.png&quot; style=&quot;{% style_stub ejbaaa 65 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Сильную насыщенность можно считать обобщённой
гладкостью числа (напомню, что число называют &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-66.png&quot; style=&quot;{% style_stub fjbaaa 66 inline %}&quot; class=&quot;latex&quot;&gt;-гладким&lt;/span&gt; если оно состоит только из факторов,
не превышающих &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-67.png&quot; style=&quot;{% style_stub gjbaaa 67 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; &lt;a class=&quot;citation&quot; href=&quot;#wiki-smooth&quot;&gt;[5]&lt;/a&gt;).&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Примечание:&lt;/strong&gt; С некоторым риском запутывания терминологии, но ради краткости, далее под
&lt;em&gt;ненасыщенным&lt;/em&gt; числом будет пониматься число, не обладающее даже свойством слабого насыщения
(т.е. у ненасыщенного числа вообще нет никакой разновидности насыщения).&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;(N.B., введённые выше степени насыщенности определяются относительно зафиксированного &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-68.png&quot; style=&quot;{% style_stub hjbaaa 68 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и из
контекста должно быть ясно о каком числе идёт речь, в противном случае рекомендуется делать
уточнения в виде «насыщенность относительно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-69.png&quot; style=&quot;{% style_stub ijbaaa 69 inline %}&quot; class=&quot;latex&quot;&gt;»&lt;/span&gt; или, более кратко, «&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-70.png&quot; style=&quot;{% style_stub jjbaaa 70 inline %}&quot; class=&quot;latex&quot;&gt;-насыщенность».)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Предложение 1:&lt;/strong&gt; Эти степени насыщения образуют иерархию в том
смысле, что всякое сильно насыщенное число является ещё и насыщенным, а насыщенное число заодно
является слабо насыщенным.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;О свойствах насыщенных чисел мне известно не так много. Например:&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Утверждение 1&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Множество слабо насыщенных чисел замкнуто относительно операций &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-71.png&quot; style=&quot;{% style_stub kjbaaa 71 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-72.png&quot; style=&quot;{% style_stub ljbaaa 72 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Множество насыщенных чисел замкнуто относительно операций &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-73.png&quot; style=&quot;{% style_stub mjbaaa 73 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-74.png&quot; style=&quot;{% style_stub njbaaa 74 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Сильно насыщенные числа же замкнуты только относительно умножения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-75.png&quot; style=&quot;{% style_stub ojbaaa 75 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Набросок доказательства&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Если числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-76.png&quot; style=&quot;{% style_stub pjbaaa 76 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-77.png&quot; style=&quot;{% style_stub qjbaaa 77 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – слабо насыщенны, то факторизация каждого содержит все различные
простые делители числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-78.png&quot; style=&quot;{% style_stub rjbaaa 78 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; и, т.о., можно выделить эту общую часть чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-79.png&quot; style=&quot;{% style_stub sjbaaa 79 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-80.png&quot; style=&quot;{% style_stub tjbaaa 80 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
записав их в виде &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-81.png&quot; style=&quot;{% style_stub ujbaaa 81 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-82.png&quot; style=&quot;{% style_stub vjbaaa 82 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-83.png&quot; style=&quot;{% style_stub wjbaaa 83 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; при разложении на простые делители будет
содержать все различные делители &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-84.png&quot; style=&quot;{% style_stub xjbaaa 84 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и только их. Тогда, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-85.png&quot; style=&quot;{% style_stub yjbaaa 85 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но число
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-86.png&quot; style=&quot;{% style_stub zjbaaa 86 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – слабо насыщенно (т.е. делится на каждый из простых делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-87.png&quot; style=&quot;{% style_stub akbaaa 87 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Случай с умножением аналогичен: произведение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-88.png&quot; style=&quot;{% style_stub bkbaaa 88 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делится на простые делители &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-89.png&quot; style=&quot;{% style_stub ckbaaa 89 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Пусть теперь &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-90.png&quot; style=&quot;{% style_stub dkbaaa 90 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-91.png&quot; style=&quot;{% style_stub ekbaaa 91 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – насыщенные числа. Это значит, что каждое из них делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-92.png&quot; style=&quot;{% style_stub fkbaaa 92 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а
значит, они могут быть представленны в виде &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-93.png&quot; style=&quot;{% style_stub gkbaaa 93 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-94.png&quot; style=&quot;{% style_stub hkbaaa 94 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; соответственно. Легко видеть, что
и сумма &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-95.png&quot; style=&quot;{% style_stub ikbaaa 95 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и произведение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-96.png&quot; style=&quot;{% style_stub jkbaaa 96 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делятся на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-97.png&quot; style=&quot;{% style_stub kkbaaa 97 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. тоже
насыщенны.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Действуя по той же схеме, запишем произведение cильно насыщенных чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-98.png&quot; style=&quot;{% style_stub lkbaaa 98 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-99.png&quot; style=&quot;{% style_stub mkbaaa 99 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (которые,
автоматически будут и насыщенными) в виде &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-100.png&quot; style=&quot;{% style_stub nkbaaa 100 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Видно, что если исходные множители
состояли только из простых делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-101.png&quot; style=&quot;{% style_stub okbaaa 101 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то в произведении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-102.png&quot; style=&quot;{% style_stub pkbaaa 102 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; новым простым
делителям взяться неоткуда. а значит &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-103.png&quot; style=&quot;{% style_stub qkbaaa 103 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – тоже сильно насыщенное число.&lt;/p&gt;
&lt;p&gt;N.B., а вот относительно сложения, к сожалению, в общем случае, сильная насыщенность не
сохраняется. Действительно, сильно насыщенные числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-104.png&quot; style=&quot;{% style_stub rkbaaa 104 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-105.png&quot; style=&quot;{% style_stub skbaaa 105 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; являются насыщенными, что
позволяет записать их, с использованием того же трюка, что и выше, как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-106.png&quot; style=&quot;{% style_stub tkbaaa 106 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-107.png&quot; style=&quot;{% style_stub ukbaaa 107 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а их
сумму, соответственно как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-108.png&quot; style=&quot;{% style_stub vkbaaa 108 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Но ведь в подвыражении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-109.png&quot; style=&quot;{% style_stub wkbaaa 109 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; могут запросто
появиться «чужеродные» факторы, нарушающие сильную насыщенность… Ну. в общем,
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-110.png&quot; style=&quot;{% style_stub xkbaaa 110 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; :)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Хотя я и старался ограничиться при изложении лишь элементарными средствами, ближе к концу
сообщения понадобится хотя и достаточно элементарный, но глубокий классический (если не сказать
древний) результат, больше известный как китайская теорема об остатках (кратко К.Т.О.).
Конкретно, ниже приведена конструктивная версия К.Т.О.:&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Теорема (без доказательства)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Пусть даны &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-111.png&quot; style=&quot;{% style_stub ykbaaa 111 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-112.png&quot; style=&quot;{% style_stub zkbaaa 112 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (остатков) и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-113.png&quot; style=&quot;{% style_stub albaaa 113 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-114.png&quot; style=&quot;{% style_stub blbaaa 114 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (модулей),
таких, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-115.png&quot; style=&quot;{% style_stub clbaaa 115 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-116.png&quot; style=&quot;{% style_stub dlbaaa 116 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Тогда система сравнений &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-117.png&quot; style=&quot;{% style_stub elbaaa 117 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; имеет ровно одно решение
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-118.png&quot; style=&quot;{% style_stub flbaaa 118 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-119.png&quot; style=&quot;{% style_stub glbaaa 119 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-120.png&quot; style=&quot;{% style_stub hlbaaa 120 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-121.png&quot; style=&quot;{% style_stub ilbaaa 121 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равна количеству чисел, не превышающих &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-122.png&quot; style=&quot;{% style_stub jlbaaa 122 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и взаимно простых с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-123.png&quot; style=&quot;{% style_stub klbaaa 123 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то при
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-124.png&quot; style=&quot;{% style_stub llbaaa 124 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; функция Эйлера равна &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-125.png&quot; style=&quot;{% style_stub mlbaaa 125 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (из-за того, что вообще все натуральные
числа из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-126.png&quot; style=&quot;{% style_stub nlbaaa 126 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; взаимно просты с простым &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-127.png&quot; style=&quot;{% style_stub olbaaa 127 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt; Это позволяет переписать решение из китайской
теоремы об остатках в виде &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-128.png&quot; style=&quot;{% style_stub plbaaa 128 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; для
случая простых модулей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-129.png&quot; style=&quot;{% style_stub qlbaaa 129 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; В настоящем сообщении будет применяться именно это следствие
К.Т.О. для простых модулей.&lt;/p&gt;
&lt;h1 id=&quot;section-2&quot;&gt;Основная проблема&lt;/h1&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Гипотеза 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-130.png&quot; style=&quot;{% style_stub rlbaaa 130 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-131.png&quot; style=&quot;{% style_stub slbaaa 131 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Схематично: насыщенность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-132.png&quot; style=&quot;{% style_stub tlbaaa 132 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; сильная насыщенность.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Следствие:&lt;/strong&gt; В частности, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-133.png&quot; style=&quot;{% style_stub ulbaaa 133 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. из насыщенности некоторой частичной суммы вытекает её сильная насыщенность, причём,
независимо от &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-134.png&quot; style=&quot;{% style_stub vlbaaa 134 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. для любого порядка включения делителей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-135.png&quot; style=&quot;{% style_stub wlbaaa 135 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в частичные суммы.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;N.B., в гипотезе 1 допустимо не более чем однократное
использование каждого из делителей – если некоторый делитель участвует в суммировании
многократно, то, вообще говоря, гипотеза может нарушаться.&lt;/p&gt;
&lt;p&gt;Некоторые из представленных ниже результатов существенно используют такую последовательность
частичных сумм. Более того, некоторые утверждения вместе с их доказательствами подразумевают
канонический порядок суммирования делителей. Поэтому, можно сказать, что в этом сообщении не
будет почти ничего, касающегося доказательства именно общей гипотезы 1, а, фактически, будут предприниматься попытки обоснования/доказательства
лишь следующего частного утверждения:&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Гипотеза 2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;При каноническом порядке суммирования делителей, выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-136.png&quot; style=&quot;{% style_stub xlbaaa 136 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (т.е., по прежнему, сильная насыщенность логически
необходима для насыщенности, но выполнение условия этой гипотезы гарантируется только если
делители упорядочены по возрастанию).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Предложение:&lt;/strong&gt; Ранее, в предложении 1, было замечено, что степени
насыщения иерархически упорядочены, и, в частности, сильная насыщенность достаточна для
насыщенности. Вместе с утверждаемой в гипотезе 1
необходимостью, это даёт &lt;em&gt;эквивалентность&lt;/em&gt; насыщенности и сильной насыщенности: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-137.png&quot; style=&quot;{% style_stub ylbaaa 137 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-138.png&quot; style=&quot;{% style_stub zlbaaa 138 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; –
сумма по некоторому подмножеству делителей. Очевидно, обе гипотезы 1 и 2 могут быть, при желании,
переформулированы в терминах такой эквивалентности.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Рассмотрим небольшой пример. Допустим, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-139.png&quot; style=&quot;{% style_stub ambaaa 139 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Множество делителей есть
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-140.png&quot; style=&quot;{% style_stub bmbaaa 140 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Произведение простых чисел (меньших &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-141.png&quot; style=&quot;{% style_stub cmbaaa 141 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; на которые &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-142.png&quot; style=&quot;{% style_stub dmbaaa 142 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не
делится, равно числу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-143.png&quot; style=&quot;{% style_stub embaaa 143 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Частичные суммы
образуют последовательность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-144.png&quot; style=&quot;{% style_stub fmbaaa 144 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Непосредственная проверка
показывает, что суммы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-145.png&quot; style=&quot;{% style_stub gmbaaa 145 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-146.png&quot; style=&quot;{% style_stub hmbaaa 146 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-147.png&quot; style=&quot;{% style_stub imbaaa 147 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; –
слабо насыщенны (в первом случае в факторизации не хватает двух двоек для насыщенности, в
последних двух – не хватает по одной двойке), сумма 24 – насыщенна и к тому же сильно
насыщенна, остальные суммы ненасыщенны.&lt;/p&gt;
&lt;p&gt;Ещё несколько выборочных примеров приведу в виде диаграмм с цветовым кодированием. Жёлтым
покрашены «запрещённые» факторы, присутствующие в частичной сумме делителей, но отсутствующие
в исходном числе &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-148.png&quot; style=&quot;{% style_stub jmbaaa 148 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Синий цвет имеют факторы присутствующие в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-149.png&quot; style=&quot;{% style_stub kmbaaa 149 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а также факторы,
находящиеся и в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-150.png&quot; style=&quot;{% style_stub lmbaaa 150 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и в частичной сумме одновременно, но не являющиеся критически важными для
насыщенности. Красным цветом обозначены факторы частичной суммы, общие с факторизацией &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-151.png&quot; style=&quot;{% style_stub mmbaaa 151 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
важные для присвоения той или иной степени насыщенности данной частичной сумме. Сумма будет
насыщенной если в ней есть все красные факторы из числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-152.png&quot; style=&quot;{% style_stub nmbaaa 152 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. если факторизация &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-153.png&quot; style=&quot;{% style_stub ombaaa 153 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; входит в
факторизацию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-154.png&quot; style=&quot;{% style_stub pmbaaa 154 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в качестве подпоследовательности. Сумма &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-155.png&quot; style=&quot;{% style_stub qmbaaa 155 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет сильно
насыщенной если она насыщенна и не имеет жёлтых факторов. Вот некоторые примеры:&lt;/p&gt;
&lt;img src=&quot;/eq/4-156.png&quot; style=&quot;{% style_stub rmbaaa 156 inline %}&quot; class=&quot;latex&quot;&gt;
&lt;p&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-157.png&quot; style=&quot;{% style_stub smbaaa 157 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-158.png&quot; style=&quot;{% style_stub tmbaaa 158 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Обратите внимание, как только факторизация &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-159.png&quot; style=&quot;{% style_stub umbaaa 159 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; обнаруживается входящей полностью в факторизацию
некоторой &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-160.png&quot; style=&quot;{% style_stub vmbaaa 160 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; жёлтые факторы гарантированно вытесняются из факторизации такой частичной
суммы (это показано в двух последних примерах; в примере с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-161.png&quot; style=&quot;{% style_stub wmbaaa 161 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; несмотря на слабое насыщение
частичной суммы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-162.png&quot; style=&quot;{% style_stub xmbaaa 162 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; в ней тоже нет жёлтых факторов, но это лишь совпадение – см. пример
с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-163.png&quot; style=&quot;{% style_stub ymbaaa 163 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Интуитивный смысл гипотезы 2: если некоторая частичная сумма
делится на всё, на что делятся её слагаемые, то она не может делиться ни на что другое, потому,
что сама сумма только из этих слагаемых и состоит. Здесь существенно, что слагаемые – суть
делители числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-164.png&quot; style=&quot;{% style_stub zmbaaa 164 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; и без этого ограничения такой эвристический (если не метафизический)
аргумент не работает. Ведь, в общем случае, факторизация суммы может кардинально отличаться от
факторизаций входящих в неё слагаемых; даже просто инкремент числа обычно меняет его
факторизацию до неузнаваемости, в чём, по моему мнению, и лежит основная сложность большинства
задач и открытых проблем теории чисел. А изучение феномена вытеснения лишних факторов — теория
насыщения — может позволить хотя-бы немного разобраться в этом «хаосе» факторизации сумм.&lt;/p&gt;
&lt;p&gt;Численные эксперименты вместе с утверждением 1 показывают, что если
гипотеза 2 верна, то её утверждение для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-165.png&quot; style=&quot;{% style_stub anbaaa 165 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
зависит не только от слагаемых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-166.png&quot; style=&quot;{% style_stub bnbaaa 166 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а для своего доказательства требует учёта
структурных свойств &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-167.png&quot; style=&quot;{% style_stub cnbaaa 167 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Поэтому, хотя частичные суммы вводились именно с прицелом на
применение индукции в возможном доказательстве гипотезы, но пока не ясно, будет ли достаточно
этих средств.&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Утверждение 2:&lt;/strong&gt; Гипотеза 2
[тривиально] верна для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-168.png&quot; style=&quot;{% style_stub dnbaaa 168 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Доказательство&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;У простого числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-169.png&quot; style=&quot;{% style_stub enbaaa 169 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; только два делителя, – это 1 и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-170.png&quot; style=&quot;{% style_stub fnbaaa 170 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Соответственно, в этом случае будут
только две ненулевые частичные суммы. При каноническом порядке делителей, сумма &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-171.png&quot; style=&quot;{% style_stub gnbaaa 171 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
вообще ни на что не делится (кроме единицы, но &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-172.png&quot; style=&quot;{% style_stub hnbaaa 172 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; и не может быть насыщенной. Сумма
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-173.png&quot; style=&quot;{% style_stub inbaaa 173 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; при делении на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-174.png&quot; style=&quot;{% style_stub jnbaaa 174 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; даёт остаток 1 и поэтому тоже не может быть насыщенной. При
другом порядке делителей, сумма &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-175.png&quot; style=&quot;{% style_stub knbaaa 175 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; поэтому она насыщенна (делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-176.png&quot; style=&quot;{% style_stub lnbaaa 176 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; и заодно
сильно насыщенна (взаимно проста с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-177.png&quot; style=&quot;{% style_stub mnbaaa 177 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; по определению числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-178.png&quot; style=&quot;{% style_stub nnbaaa 178 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt; Следующая сумма
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-179.png&quot; style=&quot;{% style_stub onbaaa 179 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; аналогична такой же сумме из уже рассмотренного случая канонического
упорядочивания. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-180.png&quot; style=&quot;{% style_stub pnbaaa 180 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Похоже, существует какая-то связь между свойствами насыщения частичных сумм делителей, чётностью
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-181.png&quot; style=&quot;{% style_stub qnbaaa 181 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и взаимной простотой &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-182.png&quot; style=&quot;{% style_stub rnbaaa 182 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с попарными разностями делителей.&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Наблюдение 1:&lt;/strong&gt; Для нечётных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-183.png&quot; style=&quot;{% style_stub snbaaa 183 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
никакая из частичных сумм делителей не достигает насыщения. Эквивалентно: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-184.png&quot; style=&quot;{% style_stub tnbaaa 184 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (Всё это работает только для
канонического порядка делителей: простой контрпример получается если первым делителем выбрать
любой насыщенный делитель, да хоть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-185.png&quot; style=&quot;{% style_stub unbaaa 185 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Наблюдение 1 скорее-всего не проще основной гипотезы 2, ведь если для нечётного случая насыщенность вообще не
достигается, то гипотеза выполняется автоматически, больше доказывать нечего. И именно этот
случай &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-186.png&quot; style=&quot;{% style_stub vnbaaa 186 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – как назло, самый сложный и интересный. :)&lt;/p&gt;
&lt;p&gt;Наивная попытка применить индукцию для доказательства «инварианта» &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-187.png&quot; style=&quot;{% style_stub wnbaaa 187 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; мало к чему приводит: при каконическом порядке делителей базовый случай очевиден (единица ни
на что не делится кроме единицы), самый последний шаг индукции с прибавлением максимального
делителя, равного самому числу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-188.png&quot; style=&quot;{% style_stub xnbaaa 188 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; менее очевиден, но тоже вполне элементарен (я пока не буду
его пояснять, оставляя его в качестве необязательного упражнения читателю :) ). А вот общий шаг
индукции чрезвычайно сложен… По крайней мере у меня ничего не получилось (но попытка
доказательства для достаточно показательного частного случая всё же будет приведена ближе к
концу сообщения) .&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Наблюдение 2:&lt;/strong&gt; Для чётных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-189.png&quot; style=&quot;{% style_stub ynbaaa 189 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
выполняется: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-190.png&quot; style=&quot;{% style_stub znbaaa 190 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;(Легко видеть, почему наблюдение 2 не выполняется для
нечётных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-191.png&quot; style=&quot;{% style_stub aobaaa 191 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Раз в факторизации &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-192.png&quot; style=&quot;{% style_stub bobaaa 192 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; нет двойки, то двоек не будет и в факторизации любого
делителя. Значит, все делители числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-193.png&quot; style=&quot;{% style_stub cobaaa 193 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; суть нечётные числа, но т.к. разность любых двух
нечётных чисел есть число чётное, то все попарные разности делителей будут делиться на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-194.png&quot; style=&quot;{% style_stub dobaaa 194 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и будут контрпримерами (хотя и не единственными).)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Набросок доказательства&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-195.png&quot; style=&quot;{% style_stub eobaaa 195 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и произвольно выбрано &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-196.png&quot; style=&quot;{% style_stub fobaaa 196 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
причём &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-197.png&quot; style=&quot;{% style_stub gobaaa 197 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Доказывается утверждение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-198.png&quot; style=&quot;{% style_stub hobaaa 198 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Доказательство
существования такого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-199.png&quot; style=&quot;{% style_stub iobaaa 199 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет проводиться полной индукцией по величине уменьшаемого в
разностях &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-200.png&quot; style=&quot;{% style_stub jobaaa 200 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;База:&lt;/p&gt;
&lt;p&gt;Т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-201.png&quot; style=&quot;{% style_stub kobaaa 201 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-202.png&quot; style=&quot;{% style_stub lobaaa 202 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; больше единицы, а
т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-203.png&quot; style=&quot;{% style_stub mobaaa 203 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; чётно, то базовый случай есть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-204.png&quot; style=&quot;{% style_stub nobaaa 204 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Поэтому &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-205.png&quot; style=&quot;{% style_stub oobaaa 205 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; удовлетворяет доказываемому
утверждению. В самом деле, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-206.png&quot; style=&quot;{% style_stub pobaaa 206 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-207.png&quot; style=&quot;{% style_stub qobaaa 207 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-208.png&quot; style=&quot;{% style_stub robaaa 208 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Очевидно, что раз &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-209.png&quot; style=&quot;{% style_stub sobaaa 209 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-210.png&quot; style=&quot;{% style_stub tobaaa 210 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Предположение индукции: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-211.png&quot; style=&quot;{% style_stub uobaaa 211 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Шаг индукции:&lt;/p&gt;
&lt;p&gt;Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-212.png&quot; style=&quot;{% style_stub vobaaa 212 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Тогда &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-213.png&quot; style=&quot;{% style_stub wobaaa 213 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Очевидно, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-214.png&quot; style=&quot;{% style_stub xobaaa 214 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-215.png&quot; style=&quot;{% style_stub yobaaa 215 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; поэтому, по предположению индукции, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-216.png&quot; style=&quot;{% style_stub zobaaa 216 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Остаётся положить &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-217.png&quot; style=&quot;{% style_stub apbaaa 217 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; что даст
разность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-218.png&quot; style=&quot;{% style_stub bpbaaa 218 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в которой ни &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-219.png&quot; style=&quot;{% style_stub cpbaaa 219 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; ни &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-220.png&quot; style=&quot;{% style_stub dpbaaa 220 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; не делятся на
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-221.png&quot; style=&quot;{% style_stub epbaaa 221 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а значит и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-222.png&quot; style=&quot;{% style_stub fpbaaa 222 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Вот так вот всё просто для сложных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-223.png&quot; style=&quot;{% style_stub gpbaaa 223 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; :)&lt;/p&gt;
&lt;p&gt;А вот для простых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-224.png&quot; style=&quot;{% style_stub hpbaaa 224 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; всё, наоборот, сложнее. (Второй раз шутка не срабатывает.) На самом деле,
я не знаю как быть с этой веткой доказательства. А чтобы хоть как-то завершить этот набросок,
могу лишь привести такой полуэвристический аргумент. Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-225.png&quot; style=&quot;{% style_stub ipbaaa 225 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; И предположим, что
всё совсем плохо и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-226.png&quot; style=&quot;{% style_stub jpbaaa 226 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-227.png&quot; style=&quot;{% style_stub kpbaaa 227 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Попробуем методом от
противного опровергнуть эту пессимистическую возможность отсутствия подходящего &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-228.png&quot; style=&quot;{% style_stub lpbaaa 228 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-229.png&quot; style=&quot;{% style_stub mpbaaa 229 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – остатки от деления &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-230.png&quot; style=&quot;{% style_stub npbaaa 230 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-231.png&quot; style=&quot;{% style_stub opbaaa 231 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-232.png&quot; style=&quot;{% style_stub ppbaaa 232 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-233.png&quot; style=&quot;{% style_stub qpbaaa 233 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-234.png&quot; style=&quot;{% style_stub rpbaaa 234 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Вычитая из первого сравнения второе, получаем &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-235.png&quot; style=&quot;{% style_stub spbaaa 235 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Что вместе с
предположением &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-236.png&quot; style=&quot;{% style_stub tpbaaa 236 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; даёт &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-237.png&quot; style=&quot;{% style_stub upbaaa 237 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; или просто &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-238.png&quot; style=&quot;{% style_stub vpbaaa 238 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (ведь &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-239.png&quot; style=&quot;{% style_stub wpbaaa 239 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt; Утверждение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-240.png&quot; style=&quot;{% style_stub xpbaaa 240 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно поэтому интерпретировать как
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-241.png&quot; style=&quot;{% style_stub ypbaaa 241 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-242.png&quot; style=&quot;{% style_stub zpbaaa 242 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – остаток от деления
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-243.png&quot; style=&quot;{% style_stub aqbaaa 243 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-244.png&quot; style=&quot;{% style_stub bqbaaa 244 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.е. все делители, не превышающие простой делитель &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-245.png&quot; style=&quot;{% style_stub cqbaaa 245 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; при делении на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-246.png&quot; style=&quot;{% style_stub dqbaaa 246 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; должны
давать одинаковые остатки.&lt;/p&gt;
&lt;p&gt;Это не просто звучит удивительно (в конце концов, при нечётном &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-247.png&quot; style=&quot;{% style_stub eqbaaa 247 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; все делители дают один и тот
же остаток по модулю 2, и это, честно говоря, не очень удивляет), но и приводит к более
осязаемым последствиям. А именно, первый, минимальный делитель равен единице и при делении на
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-248.png&quot; style=&quot;{% style_stub fqbaaa 248 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в остатке даёт единицу. Уже следующий делитель, двойка (а он всегда есть, из-за чётности
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-249.png&quot; style=&quot;{% style_stub gqbaaa 249 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; ), даёт при делении на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-250.png&quot; style=&quot;{% style_stub hqbaaa 250 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в остатке двойку. Также, каждый последующий простой делитель,
не превышающий &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-251.png&quot; style=&quot;{% style_stub iqbaaa 251 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет, при делении на простое число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-252.png&quot; style=&quot;{% style_stub jqbaaa 252 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; давать остаток не меньший двух.
Кратко, это можно записать так: &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-253.png&quot; style=&quot;{% style_stub kqbaaa 253 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Понятия не имею, можно ли эти рассуждения довести до формального доказательства, но в качестве
подтверждения собственных интуитивных догадок, указанное противоречие (простые делители, не
превышающие &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-254.png&quot; style=&quot;{% style_stub lqbaaa 254 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; не сравнимы по модулю &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-255.png&quot; style=&quot;{% style_stub mqbaaa 255 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с единицей) меня устраивает. Условно буду считать,
что утверждение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-256.png&quot; style=&quot;{% style_stub nqbaaa 256 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; в свете приведённого аргумента, нарушается
для простых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-257.png&quot; style=&quot;{% style_stub oqbaaa 257 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и, соответственно, выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-258.png&quot; style=&quot;{% style_stub pqbaaa 258 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
(По-настоящему подозрительным в случае с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-259.png&quot; style=&quot;{% style_stub qqbaaa 259 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; является игнорирование предположения
индукции, но и незаконного здесь ничего нет – методом от противного выводится существование
искомого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-260.png&quot; style=&quot;{% style_stub rqbaaa 260 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и, т.о., обеспечивается истинность доказываемого утверждения для данного простого
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-261.png&quot; style=&quot;{% style_stub sqbaaa 261 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; что делает возможной работу всех будущих шагов индукции.)&lt;/p&gt;
&lt;p&gt;Всё это могло бы успешно завершить шаг индукции и, как следствие, завершить набросок
доказательства наблюдения 2. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-262.png&quot; style=&quot;{% style_stub tqbaaa 262 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;section-3&quot;&gt;Специальный случай&lt;/h1&gt;
&lt;p&gt;Сначала, возможно, стоит попробовать рассмотреть упрощённую версию гипотезы 2, ограничившись числами &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-263.png&quot; style=&quot;{% style_stub uqbaaa 263 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; все факторы которых различны (или, лучше
сказать, все факторы или простые делители имеют единичную степень). Т.е., если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-264.png&quot; style=&quot;{% style_stub vqbaaa 264 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; –
последовательность всех простых чисел (&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-265.png&quot; style=&quot;{% style_stub wqbaaa 265 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; то разложение такого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-266.png&quot; style=&quot;{% style_stub xqbaaa 266 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на
простые множители выглядит как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-267.png&quot; style=&quot;{% style_stub yqbaaa 267 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-268.png&quot; style=&quot;{% style_stub zqbaaa 268 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Количество различных простых делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-269.png&quot; style=&quot;{% style_stub arbaaa 269 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; обычно обозначают &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-270.png&quot; style=&quot;{% style_stub brbaaa 270 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; с использованием
этого обозначения специальный случай можно охарактировать как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-271.png&quot; style=&quot;{% style_stub crbaaa 271 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Последовательностью [модулей] &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-272.png&quot; style=&quot;{% style_stub drbaaa 272 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; обозначим простые делители числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-273.png&quot; style=&quot;{% style_stub erbaaa 273 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; чуть выше уже
вводилось обозначение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-274.png&quot; style=&quot;{% style_stub frbaaa 274 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для множества простых делителей, поэтому &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-275.png&quot; style=&quot;{% style_stub grbaaa 275 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Последовательностью же модулей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-276.png&quot; style=&quot;{% style_stub hrbaaa 276 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; обозначим простые числа, меньшие числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-277.png&quot; style=&quot;{% style_stub irbaaa 277 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и не делящие
его: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-278.png&quot; style=&quot;{% style_stub jrbaaa 278 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Количество модулей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-279.png&quot; style=&quot;{% style_stub krbaaa 279 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; с использованием ранее придуманной функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-280.png&quot; style=&quot;{% style_stub lrbaaa 280 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; равно
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-281.png&quot; style=&quot;{% style_stub mrbaaa 281 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Очевидно, общее количество модулей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-282.png&quot; style=&quot;{% style_stub nrbaaa 282 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-283.png&quot; style=&quot;{% style_stub orbaaa 283 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
равно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-284.png&quot; style=&quot;{% style_stub prbaaa 284 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-285.png&quot; style=&quot;{% style_stub qrbaaa 285 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – количество простых чисел, не превышающих &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-286.png&quot; style=&quot;{% style_stub rrbaaa 286 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Тогда количество
модулей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-287.png&quot; style=&quot;{% style_stub srbaaa 287 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-288.png&quot; style=&quot;{% style_stub trbaaa 288 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Напомню также, что
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-289.png&quot; style=&quot;{% style_stub urbaaa 289 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; В рассматриваемом случае с различными факторами в числе &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-290.png&quot; style=&quot;{% style_stub vrbaaa 290 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; можно аналогично
записать &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-291.png&quot; style=&quot;{% style_stub wrbaaa 291 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Гипотеза говорит, что если для некоторого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-292.png&quot; style=&quot;{% style_stub xrbaaa 292 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; частичная сумма &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-293.png&quot; style=&quot;{% style_stub yrbaaa 293 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делится на все &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-294.png&quot; style=&quot;{% style_stub zrbaaa 294 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
то она не делится ни на один из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-295.png&quot; style=&quot;{% style_stub asbaaa 295 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Я обозвал числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-296.png&quot; style=&quot;{% style_stub bsbaaa 296 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-297.png&quot; style=&quot;{% style_stub csbaaa 297 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; модулями именно потому что
это условие сильного насыщения может быть записано в виде системы сравнений
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-298.png&quot; style=&quot;{% style_stub dsbaaa 298 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Такая запись интересна хотя-бы потому, что, во-первых, намекает на возможность применения
некоторых интересных результатов теории чисел, вроде китайской теоремы об остатках (например,
К.Т.О. говорит, что, по модулю &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-299.png&quot; style=&quot;{% style_stub esbaaa 299 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; частичная сумма в левых частях всех этих сравнений
определяется остатками однозначно; из чего следует, если я ничего не напутал, что у двух
частичных сумм [при одном и том же &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-300.png&quot; style=&quot;{% style_stub fsbaaa 300 inline %}&quot; class=&quot;latex&quot;&gt;]&lt;/span&gt; не может быть одного и того же вектора остатков), а
во-вторых, подчёркивает удивительность гипотезы 2: делимости
на разные простые числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-301.png&quot; style=&quot;{% style_stub gsbaaa 301 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-302.png&quot; style=&quot;{% style_stub hsbaaa 302 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; вроде как, независимы друг от друга, но, тем не
менее, в гипотезе утверждается их строгая скоррелированность – как только остатки от деления на
все &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-303.png&quot; style=&quot;{% style_stub isbaaa 303 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; обнуляются, остатки от деления на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-304.png&quot; style=&quot;{% style_stub jsbaaa 304 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; как-то об этом «узнают» и
кооперативно, синхронно становятся ненулевыми.&lt;/p&gt;
&lt;p&gt;Очевидно, достаточно рассматривать лишь случай &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-305.png&quot; style=&quot;{% style_stub ksbaaa 305 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.к. если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-306.png&quot; style=&quot;{% style_stub lsbaaa 306 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; насыщенна,
т.е. если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-307.png&quot; style=&quot;{% style_stub msbaaa 307 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-308.png&quot; style=&quot;{% style_stub nsbaaa 308 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но при &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-309.png&quot; style=&quot;{% style_stub osbaaa 309 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; гипотеза
автоматически выполняется (потому что само число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-310.png&quot; style=&quot;{% style_stub psbaaa 310 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; сильно насыщенно).&lt;/p&gt;
&lt;p&gt;Функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-311.png&quot; style=&quot;{% style_stub qsbaaa 311 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; позволяет записать необходимое условие сильной насыщенности в виде
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-312.png&quot; style=&quot;{% style_stub rsbaaa 312 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. переформулировать специальный случай гипотезы как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-313.png&quot; style=&quot;{% style_stub ssbaaa 313 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (причём, тривиально выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-314.png&quot; style=&quot;{% style_stub tsbaaa 314 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а вот усиление &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-315.png&quot; style=&quot;{% style_stub usbaaa 315 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; до &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-316.png&quot; style=&quot;{% style_stub vsbaaa 316 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; – по
видимому, непростая задача).&lt;/p&gt;
&lt;p&gt;Раз уж пошло такое хаотичное перечисление первых попавшихся свойств насыщенных частичных сумм (к
сожалению без какого бы то ни было приближения к доказательству основной гипотезы), то приведу
ещё одно интересное простое наблюдение.&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Лемма 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Если из насыщенной &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-317.png&quot; style=&quot;{% style_stub wsbaaa 317 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выбросить одно слагаемое, то оставшаяся сумма будет делиться на
это удалённое слагаемое.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Доказательство&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Насыщенная &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-318.png&quot; style=&quot;{% style_stub xsbaaa 318 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-319.png&quot; style=&quot;{% style_stub ysbaaa 319 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (по определению), а это означает, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-320.png&quot; style=&quot;{% style_stub zsbaaa 320 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делится на
любой делитель числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-321.png&quot; style=&quot;{% style_stub atbaaa 321 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; в частности, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-322.png&quot; style=&quot;{% style_stub btbaaa 322 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Делители &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-323.png&quot; style=&quot;{% style_stub ctbaaa 323 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
интересны тем, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-324.png&quot; style=&quot;{% style_stub dtbaaa 324 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-325.png&quot; style=&quot;{% style_stub etbaaa 325 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Но такая сумма, очевидно, может быть целым числом только если после вычитания
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-326.png&quot; style=&quot;{% style_stub ftbaaa 326 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; остаётся целая сумма &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-327.png&quot; style=&quot;{% style_stub gtbaaa 327 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-328.png&quot; style=&quot;{% style_stub htbaaa 328 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; или, что
то же самое, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-329.png&quot; style=&quot;{% style_stub itbaaa 329 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-330.png&quot; style=&quot;{% style_stub jtbaaa 330 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-331.png&quot; style=&quot;{% style_stub ktbaaa 331 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-4&quot;&gt;Факторизация с двойкой&lt;/h2&gt;
&lt;p&gt;Если наблюдение 2 выполняется (хотя я и не очень в это
верю), то, возможно, это позволяет немного продвинуться для случая &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-332.png&quot; style=&quot;{% style_stub ltbaaa 332 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. для
факторизаций, содержащих двойку.&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Гипотеза 3 (частный случай гипотезы 2)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-333.png&quot; style=&quot;{% style_stub mtbaaa 333 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – чётное число, то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-334.png&quot; style=&quot;{% style_stub ntbaaa 334 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;(Первая версия доказательства писалась для специального случая попарно-различных факторов числа
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-335.png&quot; style=&quot;{% style_stub otbaaa 335 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но потом стало понятно, что без этого требования можно обойтись; так, в нижеслующем
варианте доказательства, кроме делимости на 2, других явных ограничений на факторизацию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-336.png&quot; style=&quot;{% style_stub ptbaaa 336 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не
накладывается.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Набросок доказательства&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(Предполагается верность [не доказанного окончательно] наблюдения 2.)&lt;/p&gt;
&lt;p&gt;Если для некоторого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-337.png&quot; style=&quot;{% style_stub qtbaaa 337 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; частичная сумма &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-338.png&quot; style=&quot;{% style_stub rtbaaa 338 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; достигла насыщения, то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-339.png&quot; style=&quot;{% style_stub stbaaa 339 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Из этого следует, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-340.png&quot; style=&quot;{% style_stub ttbaaa 340 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и, в частности,
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-341.png&quot; style=&quot;{% style_stub utbaaa 341 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Дальнейшее доказательство будет вестись от противного, поэтому предположим, что
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-342.png&quot; style=&quot;{% style_stub vtbaaa 342 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е., что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-343.png&quot; style=&quot;{% style_stub wtbaaa 343 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такое, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-344.png&quot; style=&quot;{% style_stub xtbaaa 344 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-345.png&quot; style=&quot;{% style_stub ytbaaa 345 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-346.png&quot; style=&quot;{% style_stub ztbaaa 346 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Поэтому, если в факторизации &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-347.png&quot; style=&quot;{% style_stub aubaaa 347 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
содержится &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-348.png&quot; style=&quot;{% style_stub bubaaa 348 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то после деления &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-349.png&quot; style=&quot;{% style_stub cubaaa 349 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-350.png&quot; style=&quot;{% style_stub dubaaa 350 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; частное всё-равно будет делиться на
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-351.png&quot; style=&quot;{% style_stub eubaaa 351 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.е. будет выполняться: &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-352.png&quot; style=&quot;{% style_stub fubaaa 352 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Слагаемое при &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-353.png&quot; style=&quot;{% style_stub gubaaa 353 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно вынести в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-354.png&quot; style=&quot;{% style_stub hubaaa 354 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; за знак суммирования (cf. лемма 1): &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-355.png&quot; style=&quot;{% style_stub iubaaa 355 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Для целочисленности суммы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-356.png&quot; style=&quot;{% style_stub jubaaa 356 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; необходимо, чтобы сумма остатков от деления
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-357.png&quot; style=&quot;{% style_stub kubaaa 357 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и единицы на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-358.png&quot; style=&quot;{% style_stub lubaaa 358 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; была кратна &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-359.png&quot; style=&quot;{% style_stub mubaaa 359 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; С
использованием обозначения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-360.png&quot; style=&quot;{% style_stub nubaaa 360 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; обозначающего остаток от деления &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-361.png&quot; style=&quot;{% style_stub oubaaa 361 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-362.png&quot; style=&quot;{% style_stub pubaaa 362 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; это условие
можно записать как &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-363.png&quot; style=&quot;{% style_stub qubaaa 363 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Т.к. единица не делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-364.png&quot; style=&quot;{% style_stub rubaaa 364 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то первое слагаемое со знаком суммирования тоже не должно
делиться на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-365.png&quot; style=&quot;{% style_stub subaaa 365 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Также следует заметить, что слагаемое &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-366.png&quot; style=&quot;{% style_stub tubaaa 366 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не зависит от &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-367.png&quot; style=&quot;{% style_stub uubaaa 367 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Всё это
приводит к &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-368.png&quot; style=&quot;{% style_stub vubaaa 368 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Если я не ошибаюсь, такое условие можно снова «умножить» на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-369.png&quot; style=&quot;{% style_stub wubaaa 369 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
(т.е. умножить обе части лежащего в основе сравнения по модулю &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-370.png&quot; style=&quot;{% style_stub xubaaa 370 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; и получить выражение
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-371.png&quot; style=&quot;{% style_stub yubaaa 371 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Выражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-372.png&quot; style=&quot;{% style_stub zubaaa 372 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; было получено выбрасыванием &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-373.png&quot; style=&quot;{% style_stub avbaaa 373 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-374.png&quot; style=&quot;{% style_stub bvbaaa 374 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но этот же процесс
можно повторить и для другого индекса &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-375.png&quot; style=&quot;{% style_stub cvbaaa 375 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; в результате чего будет получено аналогичное
выражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-376.png&quot; style=&quot;{% style_stub dvbaaa 376 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Вычитание последнего выражения из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-377.png&quot; style=&quot;{% style_stub evbaaa 377 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; даёт &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-378.png&quot; style=&quot;{% style_stub fvbaaa 378 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; Суммы в левой части этого
сравнения отличаются только наличием/отсутствием слагаемых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-379.png&quot; style=&quot;{% style_stub gvbaaa 379 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-380.png&quot; style=&quot;{% style_stub hvbaaa 380 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; поэтому после
приведения подобных слагаемых мы получим &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-381.png&quot; style=&quot;{% style_stub ivbaaa 381 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Если наблюдение 2 верно, то для случая &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-382.png&quot; style=&quot;{% style_stub jvbaaa 382 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-383.png&quot; style=&quot;{% style_stub kvbaaa 383 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Это входит в
противоречие с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-384.png&quot; style=&quot;{% style_stub lvbaaa 384 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и, т.о., опровергает сделанное ранее предположение о том, что
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-385.png&quot; style=&quot;{% style_stub mvbaaa 385 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-386.png&quot; style=&quot;{% style_stub nvbaaa 386 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-5&quot;&gt;Факторизация без двойки и без повторов&lt;/h2&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Предложение 2 (критерии делителя)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Т.к. число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-387.png&quot; style=&quot;{% style_stub ovbaaa 387 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делится на все «разрешённые» модули &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-388.png&quot; style=&quot;{% style_stub pvbaaa 388 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и не делится на «запретные»
модули &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-389.png&quot; style=&quot;{% style_stub qvbaaa 389 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то любой делитель &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-390.png&quot; style=&quot;{% style_stub rvbaaa 390 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-391.png&quot; style=&quot;{% style_stub svbaaa 391 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; должен делиться хотя-бы на один из модулей
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-392.png&quot; style=&quot;{% style_stub tvbaaa 392 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и не должен делиться ни на один из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-393.png&quot; style=&quot;{% style_stub uvbaaa 393 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Если число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-394.png&quot; style=&quot;{% style_stub vvbaaa 394 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; удовлетворяет этим
необходимым критериям, то оно, возможно, является делителем &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-395.png&quot; style=&quot;{% style_stub wvbaaa 395 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Иначе говоря, если число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-396.png&quot; style=&quot;{% style_stub xvbaaa 396 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не делится ни на один из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-397.png&quot; style=&quot;{% style_stub yvbaaa 397 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и/или делится на один или
несколько модулей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-398.png&quot; style=&quot;{% style_stub zvbaaa 398 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-399.png&quot; style=&quot;{% style_stub awbaaa 399 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – точно не делитель числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-400.png&quot; style=&quot;{% style_stub bwbaaa 400 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (В силу очевидности, я
думаю, предложение 2 в доказательстве не нуждается.)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;В контексте разбора случая факторизуемости &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-401.png&quot; style=&quot;{% style_stub cwbaaa 401 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; без повторов, стоит уделить особое внимание
наблюдению 1. Напомню, что это наблюдение утверждает, что
для нечётных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-402.png&quot; style=&quot;{% style_stub dwbaaa 402 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; насыщенных частичных сумм не бывает вообще (при каноническом порядке
делителей). Я до сих пор не знаю как подступиться к этой проблеме, но хотелось бы сделать
следующее «статистическое» замечание о роли нечётности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-403.png&quot; style=&quot;{% style_stub ewbaaa 403 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и о возможном подходе к
доказательству. Как я уже говорил ранее, при попытке доказательства по индукции, первый и
последний шаги не представляют трудности и могут пока игнорироваться).&lt;/p&gt;
&lt;p&gt;Итак.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Набросок доказательства наблюдения 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Для «общего» шага индукции, предполагается, что очередная &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-404.png&quot; style=&quot;{% style_stub fwbaaa 404 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; ненасыщенна, т.е. она,
возможно, делится на некоторые из модулей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-405.png&quot; style=&quot;{% style_stub gwbaaa 405 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но совершенно точно не делится на некоторые
другие из них. Нужно показать, что новая сумма &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-406.png&quot; style=&quot;{% style_stub hwbaaa 406 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; ведёт себя так же и не делится
хотя-бы на один такой модуль.&lt;/p&gt;
&lt;p&gt;Не все комбинации делимостей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-407.png&quot; style=&quot;{% style_stub iwbaaa 407 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-408.png&quot; style=&quot;{% style_stub jwbaaa 408 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-409.png&quot; style=&quot;{% style_stub kwbaaa 409 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; «интересны». Действительно, если из
чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-410.png&quot; style=&quot;{% style_stub lwbaaa 410 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-411.png&quot; style=&quot;{% style_stub mwbaaa 411 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; только одно делится без остатка на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-412.png&quot; style=&quot;{% style_stub nwbaaa 412 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то результат, новая
частичная сумма &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-413.png&quot; style=&quot;{% style_stub owbaaa 413 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не будет делиться на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-414.png&quot; style=&quot;{% style_stub pwbaaa 414 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и, т.о., новая частичная сумма
автоматически станет ненасыщенной. Если же оба числа делятся на модуль &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-415.png&quot; style=&quot;{% style_stub qwbaaa 415 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то новая частичная
сумма &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-416.png&quot; style=&quot;{% style_stub rwbaaa 416 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет делиться на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-417.png&quot; style=&quot;{% style_stub swbaaa 417 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и здесь уже ничего не поделаешь. Интересным
остаётся только случай при котором ни &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-418.png&quot; style=&quot;{% style_stub twbaaa 418 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; ни &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-419.png&quot; style=&quot;{% style_stub uwbaaa 419 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не делятся на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-420.png&quot; style=&quot;{% style_stub vwbaaa 420 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Именно на этом этапе уместно сделать замечание о возможной роли нечётности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-421.png&quot; style=&quot;{% style_stub wwbaaa 421 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-422.png&quot; style=&quot;{% style_stub xwbaaa 422 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
чётно, то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-423.png&quot; style=&quot;{% style_stub ywbaaa 423 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и вышеописанным интересным сравнением может стать сравнение по модулю
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-424.png&quot; style=&quot;{% style_stub zwbaaa 424 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а именно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-425.png&quot; style=&quot;{% style_stub axbaaa 425 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; выполняющемся если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-426.png&quot; style=&quot;{% style_stub bxbaaa 426 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-427.png&quot; style=&quot;{% style_stub cxbaaa 427 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; нечётны.
Как видите, интересное сравнение становится неинтересным (результат всегда делится на 2) и
шансы, грубо говоря, распределяются поровну для делимости и неделимости &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-428.png&quot; style=&quot;{% style_stub dxbaaa 428 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-429.png&quot; style=&quot;{% style_stub exbaaa 429 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;В то время как при &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-430.png&quot; style=&quot;{% style_stub fxbaaa 430 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; среди &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-431.png&quot; style=&quot;{% style_stub gxbaaa 431 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; двойки нет, и у сравнения
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-432.png&quot; style=&quot;{% style_stub hxbaaa 432 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; с некоторой «вероятностью», остаток &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-433.png&quot; style=&quot;{% style_stub ixbaaa 433 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет
ненулевым и среди всех возможных комбинаций делимостей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-434.png&quot; style=&quot;{% style_stub jxbaaa 434 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-435.png&quot; style=&quot;{% style_stub kxbaaa 435 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-436.png&quot; style=&quot;{% style_stub lxbaaa 436 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет
некоторый статистический перевес в сторону некратности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-437.png&quot; style=&quot;{% style_stub mxbaaa 437 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; модулю &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-438.png&quot; style=&quot;{% style_stub nxbaaa 438 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Заметьте,
что этот аргумент касается только одного сравнения по модулю &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-439.png&quot; style=&quot;{% style_stub oxbaaa 439 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; и мне неизвестно, может ли
всего-лишь это одно сравнение полностью запретить или разрешить насыщенные частичные суммы. Я
лишь поделился самим наблюдением о небольшой асимметрии…&lt;/p&gt;
&lt;p&gt;Но вернёмся к разработке стратегии индуктивного доказательства запрета насыщенных частичных сумм
делителей именно нечётного числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-440.png&quot; style=&quot;{% style_stub pxbaaa 440 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Итак, мы находимся на одном из промежуточных шагов
индукции, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-441.png&quot; style=&quot;{% style_stub qxbaaa 441 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-442.png&quot; style=&quot;{% style_stub rxbaaa 442 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; оба не делятся хотя-бы на некоторые модули &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-443.png&quot; style=&quot;{% style_stub sxbaaa 443 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Более
конкретно, пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-444.png&quot; style=&quot;{% style_stub txbaaa 444 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-445.png&quot; style=&quot;{% style_stub uxbaaa 445 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где остатки
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-446.png&quot; style=&quot;{% style_stub vxbaaa 446 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Сложение этих двух сравнений даёт &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-447.png&quot; style=&quot;{% style_stub wxbaaa 447 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Допустим, что вопреки ожиданиям и целям, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-448.png&quot; style=&quot;{% style_stub xxbaaa 448 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (предположение для опровержения методом «от противного»). Тогда, вычитая из
предпоследнего сравнения последнее получаем &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-449.png&quot; style=&quot;{% style_stub yxbaaa 449 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; откуда
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-450.png&quot; style=&quot;{% style_stub zxbaaa 450 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Вместе с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-451.png&quot; style=&quot;{% style_stub aybaaa 451 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; это даёт &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-452.png&quot; style=&quot;{% style_stub bybaaa 452 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (если я нигде не ошибся).&lt;/p&gt;
&lt;p&gt;Такую систему (при пробегании индексом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-453.png&quot; style=&quot;{% style_stub cybaaa 453 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; всех допустимых значений) можно решить относительно
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-454.png&quot; style=&quot;{% style_stub dybaaa 454 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; с помощью конструктивной версии К.Т.О. Должно получиться что-то вроде &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-455.png&quot; style=&quot;{% style_stub eybaaa 455 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-456.png&quot; style=&quot;{% style_stub fybaaa 456 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;(N.B. Я пишу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-457.png&quot; style=&quot;{% style_stub gybaaa 457 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; вместо &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-458.png&quot; style=&quot;{% style_stub hybaaa 458 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – чтобы
читатель не спутал просто дробь в скобках с каким-нибудь там символом Лежандра. :) )&lt;/p&gt;
&lt;p&gt;Значения полученные с помощью &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-459.png&quot; style=&quot;{% style_stub iybaaa 459 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выглядят подозрительно (слишком большими),
поэтому я решил в качестве решения использовать &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-460.png&quot; style=&quot;{% style_stub jybaaa 460 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; [хотя пока и не знаю как
обосновать законность этого, немного «подгоночного» шага]. Но главная идея здесь заключается в
проверке полученной оценки «делителя» &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-461.png&quot; style=&quot;{% style_stub kybaaa 461 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-462.png&quot; style=&quot;{% style_stub lybaaa 462 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на соответствие её критериям из
предложения 2 – если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-463.png&quot; style=&quot;{% style_stub mybaaa 463 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не делится ни на какие модули
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-464.png&quot; style=&quot;{% style_stub nybaaa 464 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; или, наоборот, делится пусть даже на всего один модуль из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-465.png&quot; style=&quot;{% style_stub oybaaa 465 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то это приведёт к
противоречию (т.к. число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-466.png&quot; style=&quot;{% style_stub pybaaa 466 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; сравнимое с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-467.png&quot; style=&quot;{% style_stub qybaaa 467 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; по модулю &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-468.png&quot; style=&quot;{% style_stub rybaaa 468 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; определённо, по-построению,
является делителем &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-469.png&quot; style=&quot;{% style_stub sybaaa 469 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; и, понятное дело, к опровержению сделанного допущения
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-470.png&quot; style=&quot;{% style_stub tybaaa 470 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Находить остаток от деления суммы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-471.png&quot; style=&quot;{% style_stub uybaaa 471 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-472.png&quot; style=&quot;{% style_stub vybaaa 472 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и проверять его делимости на
допустимые &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-473.png&quot; style=&quot;{% style_stub wybaaa 473 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и запрещённые &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-474.png&quot; style=&quot;{% style_stub xybaaa 474 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; модули страшновато. Но интересно эмпирическое
наблюдение:&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Наблюдение 3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Для рассматриваемого случая, т.е. для нечётных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-475.png&quot; style=&quot;{% style_stub yybaaa 475 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и частичных сумм, отличных от первой,
«аппроксимация» &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-476.png&quot; style=&quot;{% style_stub zybaaa 476 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делителя &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-477.png&quot; style=&quot;{% style_stub azbaaa 477 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; грубо нарушает критерии предложения 2. А именно, эти аппроксимации почему-то не делятся ни на один &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-478.png&quot; style=&quot;{% style_stub bzbaaa 478 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и в
то же самое время делятся хотя-бы на один &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-479.png&quot; style=&quot;{% style_stub czbaaa 479 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Критерий с делимостью на модули &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-480.png&quot; style=&quot;{% style_stub dzbaaa 480 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; проверить, возможно, проще. Это ощущение основано на
следующем факте.&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Предложение:&lt;/strong&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-481.png&quot; style=&quot;{% style_stub ezbaaa 481 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; верно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-482.png&quot; style=&quot;{% style_stub fzbaaa 482 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Доказательство&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Действительно, обозначим &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-483.png&quot; style=&quot;{% style_stub gzbaaa 483 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; тогда &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-484.png&quot; style=&quot;{% style_stub hzbaaa 484 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-485.png&quot; style=&quot;{% style_stub izbaaa 485 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для
некоторых целых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-486.png&quot; style=&quot;{% style_stub jzbaaa 486 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-487.png&quot; style=&quot;{% style_stub kzbaaa 487 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Также, для целых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-488.png&quot; style=&quot;{% style_stub lzbaaa 488 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-489.png&quot; style=&quot;{% style_stub mzbaaa 489 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-490.png&quot; style=&quot;{% style_stub nzbaaa 490 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-491.png&quot; style=&quot;{% style_stub ozbaaa 491 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Подставляя, получаем &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-492.png&quot; style=&quot;{% style_stub pzbaaa 492 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-493.png&quot; style=&quot;{% style_stub qzbaaa 493 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; или
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-494.png&quot; style=&quot;{% style_stub rzbaaa 494 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; как и требовалось. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-495.png&quot; style=&quot;{% style_stub szbaaa 495 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Т.е., т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-496.png&quot; style=&quot;{% style_stub tzbaaa 496 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то вместо деления &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-497.png&quot; style=&quot;{% style_stub uzbaaa 497 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-498.png&quot; style=&quot;{% style_stub vzbaaa 498 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и проверки
делимости полученного остатка на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-499.png&quot; style=&quot;{% style_stub wzbaaa 499 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно ограничиться только нахождением остатка от деления
на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-500.png&quot; style=&quot;{% style_stub xzbaaa 500 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Тогда результат численных экспериментов можно упростить до &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-501.png&quot; style=&quot;{% style_stub yzbaaa 501 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-502.png&quot; style=&quot;{% style_stub zzbaaa 502 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (из-за
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-503.png&quot; style=&quot;{% style_stub aacaaa 503 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Уже не так страшно; но дальше я продвигался очень неуверенно. Непонятно, как формально показать
выполнение этого предположения; и непонятно, действительно ли его выполнение будет искомым
противоречием…&lt;/p&gt;
&lt;p&gt;Что касается первого вопроса (о выполнении условия &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-504.png&quot; style=&quot;{% style_stub bacaaa 504 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; то можно попробовать
рассмотреть игрушечный случай лишь с двумя факторами в числе &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-505.png&quot; style=&quot;{% style_stub cacaaa 505 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Итак, пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-506.png&quot; style=&quot;{% style_stub dacaaa 506 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; при
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-507.png&quot; style=&quot;{% style_stub eacaaa 507 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-508.png&quot; style=&quot;{% style_stub facaaa 508 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Ограничимся проверкой условия &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-509.png&quot; style=&quot;{% style_stub gacaaa 509 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-510.png&quot; style=&quot;{% style_stub hacaaa 510 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
(т.к. ситуация с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-511.png&quot; style=&quot;{% style_stub iacaaa 511 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет полностью аналогичной). Такая проверка тогда сводится к проверке
дробности частного &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-512.png&quot; style=&quot;{% style_stub jacaaa 512 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Видно, что из-за &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-513.png&quot; style=&quot;{% style_stub kacaaa 513 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в обоих слагаемых не менее двух множителей в
числителях (возможно роль нечётности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-514.png&quot; style=&quot;{% style_stub lacaaa 514 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; критически важна и здесь). Поэтому один из множителей
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-515.png&quot; style=&quot;{% style_stub macaaa 515 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в числителе второй дроби сокращается с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-516.png&quot; style=&quot;{% style_stub nacaaa 516 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из знаменателя и как минимум один &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-517.png&quot; style=&quot;{% style_stub oacaaa 517 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
остаётся в числителе, делая эту дробь целой и сводя проверку условия &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-518.png&quot; style=&quot;{% style_stub pacaaa 518 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; к
проверке нецелочисленности первой дроби. Также видно, что в первой дроби ничего не сокращается
(&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-519.png&quot; style=&quot;{% style_stub qacaaa 519 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – суть остатки от деления &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-520.png&quot; style=&quot;{% style_stub racaaa 520 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-521.png&quot; style=&quot;{% style_stub sacaaa 521 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; удовлетворяющие &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-522.png&quot; style=&quot;{% style_stub tacaaa 522 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
в силу этого не могущие сокращаться с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-523.png&quot; style=&quot;{% style_stub uacaaa 523 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; и поэтому её значение обязано быть дробным.&lt;/p&gt;
&lt;p&gt;Раз то же самое можно проделать и с делением на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-524.png&quot; style=&quot;{% style_stub vacaaa 524 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то приходится заключить, что для частного
случая &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-525.png&quot; style=&quot;{% style_stub wacaaa 525 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; полученная с помощью К.Т.О. оценка делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-526.png&quot; style=&quot;{% style_stub xacaaa 526 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не удовлетворяет
критериям делителя и приводит к противоречию, доказывая (при допущении корректности сделанного
ранее подгоночного шага со взятием остатка по модулю &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-527.png&quot; style=&quot;{% style_stub yacaaa 527 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; наблюдение 1 об отсутствии насыщенных частичных сумм для нечётных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-528.png&quot; style=&quot;{% style_stub zacaaa 528 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Для более общего случая &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-529.png&quot; style=&quot;{% style_stub abcaaa 529 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; всё немного сложнее (но схема та же). Для проверки делимости
выражения из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-530.png&quot; style=&quot;{% style_stub bbcaaa 530 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; разделим его на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-531.png&quot; style=&quot;{% style_stub cbcaaa 531 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и разложим сумму, выделив в ней одно
слагаемое: &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-532.png&quot; style=&quot;{% style_stub dbcaaa 532 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;(Минус перед суммой выброшен, т.к. он никак не влияет на целочисленность.)&lt;/p&gt;
&lt;p&gt;Т.к. рассматривается случай &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-533.png&quot; style=&quot;{% style_stub ebcaaa 533 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (для простых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-534.png&quot; style=&quot;{% style_stub fbcaaa 534 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; справедливо утверждение 2), то у числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-535.png&quot; style=&quot;{% style_stub gbcaaa 535 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; больше двух простых делителей, что приводит к
неравенству нулю обоих подвыражений &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-536.png&quot; style=&quot;{% style_stub hbcaaa 536 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-537.png&quot; style=&quot;{% style_stub ibcaaa 537 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (хотя, обращаться к утверждению 2 необязательно – если всё-таки &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-538.png&quot; style=&quot;{% style_stub jbcaaa 538 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то подвыражение
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-539.png&quot; style=&quot;{% style_stub kbcaaa 539 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; и только оно, обратится в ноль, но т.к. ноль есть число целое, то подвыражение
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-540.png&quot; style=&quot;{% style_stub lbcaaa 540 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; всё-равно никак не повлияет на дробность или целочисленность всей суммы подвыражений
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-541.png&quot; style=&quot;{% style_stub mbcaaa 541 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-542.png&quot; style=&quot;{% style_stub nbcaaa 542 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Сначала проанализируем подвыражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-543.png&quot; style=&quot;{% style_stub obcaaa 543 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; более подробно. В каждом слагаемом разделим &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-544.png&quot; style=&quot;{% style_stub pbcaaa 544 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-545.png&quot; style=&quot;{% style_stub qbcaaa 545 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-546.png&quot; style=&quot;{% style_stub rbcaaa 546 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и степень, в которую возводится каждое слагаемое, не меньше двух (из-за
нечётности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-547.png&quot; style=&quot;{% style_stub sbcaaa 547 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-548.png&quot; style=&quot;{% style_stub tbcaaa 548 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и один из этих &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-549.png&quot; style=&quot;{% style_stub ubcaaa 549 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; множителей можно
будет поделить на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-550.png&quot; style=&quot;{% style_stub vbcaaa 550 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; в результате чего в знаменателе вообще ничего не останется, и текущее
слагаемое, — а значит и вся сумма &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-551.png&quot; style=&quot;{% style_stub wbcaaa 551 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; — будет целым числом, из-за чего подвыражение
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-552.png&quot; style=&quot;{% style_stub xbcaaa 552 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно в дальнейшем игнорировать.&lt;/p&gt;
&lt;p&gt;Теперь, по-аналогии, перейдём к подвыражению &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-553.png&quot; style=&quot;{% style_stub ybcaaa 553 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Деление &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-554.png&quot; style=&quot;{% style_stub zbcaaa 554 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-555.png&quot; style=&quot;{% style_stub accaaa 555 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; вычеркивает фактор
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-556.png&quot; style=&quot;{% style_stub bccaaa 556 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-557.png&quot; style=&quot;{% style_stub cccaaa 557 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;  Поэтому, подвыражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-558.png&quot; style=&quot;{% style_stub dccaaa 558 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно преобразовать в
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-559.png&quot; style=&quot;{% style_stub eccaaa 559 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; В произведении, возведённом в степень, можно перегруппировать
множители, и тогда подвыражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-560.png&quot; style=&quot;{% style_stub fccaaa 560 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; запишется как &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/4-561.png&quot; style=&quot;{% style_stub gccaaa 561 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; Видно, что из-за &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-562.png&quot; style=&quot;{% style_stub hccaaa 562 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; вся формула представляет собой дробь, числитель
которой – целое число, не содержащее фактора &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-563.png&quot; style=&quot;{% style_stub iccaaa 563 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-564.png&quot; style=&quot;{% style_stub jccaaa 564 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – есть остаток от деления &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-565.png&quot; style=&quot;{% style_stub kccaaa 565 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-566.png&quot; style=&quot;{% style_stub lccaaa 566 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-567.png&quot; style=&quot;{% style_stub mccaaa 567 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и, следовательно, тоже не может содержать фактор &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-568.png&quot; style=&quot;{% style_stub nccaaa 568 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; а в
знаменателе находится &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-569.png&quot; style=&quot;{% style_stub occaaa 569 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Такая дробь не может быть целой.&lt;/p&gt;
&lt;p&gt;Опять получили нарушение предложения 2, а значит и
противоречие, доказывающее наблюдение 1.&lt;/p&gt;
&lt;p&gt;Строго говоря, чтобы завершить эту попытку доказательства наблюдения 1, понадобится описать ещё базовый случай. При каноническом, возрастающем
порядке следования делителей, база индукции будет соответствовать случаю &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-570.png&quot; style=&quot;{% style_stub pccaaa 570 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Он
очевиден, т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-571.png&quot; style=&quot;{% style_stub qccaaa 571 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и поэтому &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-572.png&quot; style=&quot;{% style_stub rccaaa 572 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не делится ни на какой из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-573.png&quot; style=&quot;{% style_stub sccaaa 573 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е.
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-574.png&quot; style=&quot;{% style_stub tccaaa 574 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – не является насыщенной.&lt;/p&gt;
&lt;p&gt;(Последний шаг интересен сам по себе. Для него, опять же при каноническом порядке делителей,
очередной добавляемый делитель равен самому числу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-575.png&quot; style=&quot;{% style_stub uccaaa 575 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. следующая сумма выглядит как
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-576.png&quot; style=&quot;{% style_stub vccaaa 576 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-577.png&quot; style=&quot;{% style_stub wccaaa 577 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; по предположению индукции, ненасыщенна, т.е. не
делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-578.png&quot; style=&quot;{% style_stub xccaaa 578 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Неделимость на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-579.png&quot; style=&quot;{% style_stub yccaaa 579 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; означает, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-580.png&quot; style=&quot;{% style_stub zccaaa 580 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для некоторых
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-581.png&quot; style=&quot;{% style_stub adcaaa 581 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-582.png&quot; style=&quot;{% style_stub bdcaaa 582 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Тогда &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-583.png&quot; style=&quot;{% style_stub cdcaaa 583 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Набросок доказательства наблюдения 1 для частного случая
факторизации без повторов завершён. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-584.png&quot; style=&quot;{% style_stub ddcaaa 584 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;И на этой ноте, первую часть вводного мини-отчёта об основах «теории насыщения» я пока прерву.
:)&lt;/p&gt;
&lt;h1 id=&quot;section-6&quot;&gt;Заключение&lt;/h1&gt;
&lt;p&gt;Я не знаю, смогут ли приведённые в этом сообщении интуитивные доводы и экспериментальные
наблюдения лечь в основу полноценного доказательства феномена из гипотезы 2. Но, надеюсь, я смог поделиться с читателями моей заинтересованностью в
«теории насыщения». Феномен, лежащий в основе этой небольшой теории, имеет и самостоятельную
ценность и, потенциально, может иметь «прикладное» значение в других задачах теории чисел.&lt;/p&gt;
&lt;p&gt;Рассуждения, в основном, проводились для весьма частного случая разложимости данного числа на
простые множители без повторов. Особых, принципиальных препятствий для обобщения на произвольные
числа пока не видно. (Действительно, что если вместо простых &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-585.png&quot; style=&quot;{% style_stub edcaaa 585 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; брать взаимно простые модули
вида &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-586.png&quot; style=&quot;{% style_stub fdcaaa 586 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из канонического разложения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-587.png&quot; style=&quot;{% style_stub gdcaaa 587 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-588.png&quot; style=&quot;{% style_stub hdcaaa 588 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-589.png&quot; style=&quot;{% style_stub idcaaa 589 inline %}&quot; class=&quot;latex&quot;&gt;?&lt;/span&gt; Китайская теорема об остатках прекрасно
работает с такими модулями; другие фрагменты рассуждений тоже потенциально могут быть
адаптированы к взаимно простым модулям вместо простых… Осталось аккуратно переписать всё для
этого наиболее общего случая, но желательно после «отладки» имеющейся схемы рассуждений; вдруг
там слишком много ошибок?)&lt;/p&gt;
&lt;p&gt;Предварительные итоги: наблюдения 1, 2, а также гипотезы 1, 2 и 3 выполняются для всех
чисел, до которых я только смог и захотел дотянуться. :) Возможно, хотя я и не уверен, что из
наблюдения 1 и гипотезы 3 выводится гипотеза 2 (все связи уже были показаны в этом
сообщении; наблюдение 1 покрывает случаи нечётных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/4-590.png&quot; style=&quot;{% style_stub jdcaaa 590 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
гипотеза 3 – чётных). Ну а сама гипотеза 2 может обобщать некоторые интересные вещи из теории чисел (правда, утверждать
это наверняка, тоже пока преждевременно).&lt;/p&gt;
&lt;p&gt;Гипотеза 1 остаётся открытой, хотя для моих нужд вполне
достаточно и гипотезы 2.&lt;/p&gt;
&lt;p&gt;Идеи и вопросы из теории насыщения не ограничиваются изложенными в этом документе, и, вероятно,
вскоре я напишу вторую часть, рискуя ещё больше озадачить читателя любительскими набросками
доказательств, но попытаюсь при этом сделать акцент именно на приложениях теории.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Обновление (август, 2021):&lt;/strong&gt; &lt;em&gt;Я написал
&lt;a href=&quot;http://circiter.github.io/saturation-theory-part-2&quot;&gt;продолжение&lt;/a&gt;, вторую часть этой серии
сообщений. Среди прочего, там, в приложении после списка литературы, размещена
«заплатка», позволяющая обобщить результаты, полученные ранее для специального случая
равенства степеней факторов единице. По крайней мере, теперь в наличии есть все фрагменты,
необходимые для написания [наброска] полного доказательства гипотезы 2. Ситуация с идейной и технической корректностью рассуждений, впрочем,
всё так же не прояснилась. :)&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;section-7&quot;&gt;Ссылки&lt;/h1&gt;
&lt;ul class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;wiki-saturation&quot;&gt;1. &lt;/span&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/saturation_arithmetic&quot;&gt;http://en.wikipedia.org/wiki/saturation_arithmetic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;benkoski1974&quot;&gt;2. Stan B. и др. On Weird and Pseudoperfect Numbers. 1974&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;euler1760&quot;&gt;3. Euler L. Observation de summis divisorum. 1760&lt;/span&gt; &lt;a href=&quot;http://eulerarchive.maa.org/backup/E243.html&quot;&gt;http://eulerarchive.maa.org/backup/E243.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;euler1760-translation&quot;&gt;4. Euler L. An observation on the sums of divisors / пер. Bell J. 2009&lt;/span&gt; &lt;a href=&quot;http://arxiv.org/abs/math/0411587&quot;&gt;http://arxiv.org/abs/math/0411587&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-smooth&quot;&gt;5. &lt;/span&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/smooth_number&quot;&gt;http://en.wikipedia.org/wiki/smooth_number&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Теория насыщения. Часть II.</title>
   <link href="http://circiter.tk/saturation-theory-part-2"/>
   <updated>2022-05-07T02:05:34+00:00</updated>
   <id>http://circiter.tk/saturation-theory-part-2</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;Введение&lt;/h1&gt;
&lt;p&gt;Я рад, что читатель не сбежал после прочтения аннотации. :) Да, задаче о нечётных совершенных
числах около двух килолет, и её до сих пор официально не решили. Общепринятая гипотеза гласит,
что таких чисел попросту не существует, и именно эта гипотеза будет основных объектом для
«клинических испытаний» теории насыщения.&lt;/p&gt;
&lt;p&gt;Рекомендуется ознакомиться с первой частью &lt;a class=&quot;citation&quot; href=&quot;#saturation-theory-part-1&quot;&gt;[1]&lt;/a&gt; этой серии
сообщений. В ней описаны основы этой небольшой теории, даются необходимые определения. Основным
результатом проведённых изысканий является ряд гипотез и наблюдений вместе с набросками их
доказательств (по крайней мере, для интересного частного случая).&lt;/p&gt;
&lt;p&gt;(Формат этих заметок не подразумевает использования неудобных перекрёстных ссылок между
сообщениями. Поэтому основные результаты и определения я кратко повторю здесь.)&lt;/p&gt;
&lt;h1 id=&quot;section-1&quot;&gt;Определения и старые результаты&lt;/h1&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Кое-какие обозначения&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-0.png&quot; style=&quot;{% style_stub kdcaaa 0 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – количество всех делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-1.png&quot; style=&quot;{% style_stub ldcaaa 1 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-2.png&quot; style=&quot;{% style_stub mdcaaa 2 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – сумма всех делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-3.png&quot; style=&quot;{% style_stub ndcaaa 3 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-4.png&quot; style=&quot;{% style_stub odcaaa 4 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – множество всех простых чисел;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-5.png&quot; style=&quot;{% style_stub pdcaaa 5 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – множество различных простых делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-6.png&quot; style=&quot;{% style_stub qdcaaa 6 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-7.png&quot; style=&quot;{% style_stub rdcaaa 7 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – произвольное число, относительно которого по-умолчанию рассматриваются многие
результаты теории насыщения;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-8.png&quot; style=&quot;{% style_stub sdcaaa 8 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – множество делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-9.png&quot; style=&quot;{% style_stub tdcaaa 9 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (N.B., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-10.png&quot; style=&quot;{% style_stub udcaaa 10 inline %}&quot; class=&quot;latex&quot;&gt;);&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-11.png&quot; style=&quot;{% style_stub vdcaaa 11 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – различные простые числа («запрещённые модули»), меньшие числа
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-12.png&quot; style=&quot;{% style_stub wdcaaa 12 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и взаимно простые с ним;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-13.png&quot; style=&quot;{% style_stub xdcaaa 13 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – число, факторизация которого образована всеми числами &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-14.png&quot; style=&quot;{% style_stub ydcaaa 14 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (N.B., все
факторы различны).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Определения&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-15.png&quot; style=&quot;{% style_stub zdcaaa 15 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – &lt;em&gt;слабо насыщенно&lt;/em&gt; если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-16.png&quot; style=&quot;{% style_stub aecaaa 16 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется импликация &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-17.png&quot; style=&quot;{% style_stub becaaa 17 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-18.png&quot; style=&quot;{% style_stub cecaaa 18 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – &lt;em&gt;насыщенно&lt;/em&gt; если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-19.png&quot; style=&quot;{% style_stub decaaa 19 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-20.png&quot; style=&quot;{% style_stub eecaaa 20 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – &lt;em&gt;сильно насыщенно&lt;/em&gt; если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-21.png&quot; style=&quot;{% style_stub fecaaa 21 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-22.png&quot; style=&quot;{% style_stub gecaaa 22 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Делители числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-23.png&quot; style=&quot;{% style_stub hecaaa 23 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; составляют множество &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-24.png&quot; style=&quot;{% style_stub iecaaa 24 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а будучи упорядоченными некоторым образом,
образуют последовательность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-25.png&quot; style=&quot;{% style_stub jecaaa 25 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Отношение порядка по-умолчанию для множества &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-26.png&quot; style=&quot;{% style_stub kecaaa 26 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; есть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-27.png&quot; style=&quot;{% style_stub lecaaa 27 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; и если делители &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-28.png&quot; style=&quot;{% style_stub mecaaa 28 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
упорядочены относительно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-29.png&quot; style=&quot;{% style_stub necaaa 29 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е., упорядочены по возрастанию, то говорят о
&lt;em&gt;каноническом порядке&lt;/em&gt; делителей;&lt;/li&gt;
&lt;li&gt;Частичные суммы делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-30.png&quot; style=&quot;{% style_stub oecaaa 30 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; образуют последовательность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-31.png&quot; style=&quot;{% style_stub pecaaa 31 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; заданную
рекуррентно: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-32.png&quot; style=&quot;{% style_stub qecaaa 32 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Гипотеза 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-33.png&quot; style=&quot;{% style_stub recaaa 33 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (из
насыщенности следует сильная насыщенность).&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Из 1 вытекает утверждение о логической необходимости
сильной насыщенности и для насыщения частичных сумм делителей, независимо от порядка включения
делителей в сумму. По факту, некоторые из приведённых в предыдущем сообщении набросков
доказательств, подразумевают канонический порядок делителей. Так что, главным инструментом (и
основным объектом попыток доказательства) в текущей версии теории насыщения является следующее
утверждение:&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Гипотеза 2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;При каноническом порядке суммирования делителей, справедливо &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-34.png&quot; style=&quot;{% style_stub secaaa 34 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Наблюдение 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Для нечётных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-35.png&quot; style=&quot;{% style_stub tecaaa 35 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; при каноническом порядке делителей, ни одна из частичных сумм не достигает
насыщения: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-36.png&quot; style=&quot;{% style_stub uecaaa 36 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Наблюдение 2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Для чётных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-37.png&quot; style=&quot;{% style_stub vecaaa 37 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; справедливо &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-38.png&quot; style=&quot;{% style_stub wecaaa 38 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Примерная словесная формулировка: для произвольного, заранее выбранного запрещённого модуля &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-39.png&quot; style=&quot;{% style_stub xecaaa 39 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
среди попарных разностей делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-40.png&quot; style=&quot;{% style_stub yecaaa 40 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; «много» разностей, не делящихся на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-41.png&quot; style=&quot;{% style_stub zecaaa 41 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а именно,
если выбрать какой-нибудь неминимальный (не равный единице) делитель, то найдётся меньший
делитель, такой, что разность между этими двумя делителями не будет кратна &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-42.png&quot; style=&quot;{% style_stub afcaaa 42 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Гипотеза 3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-43.png&quot; style=&quot;{% style_stub bfcaaa 43 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – чётное, то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-44.png&quot; style=&quot;{% style_stub cfcaaa 44 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;section-2&quot;&gt;Связи между утверждениями&lt;/h2&gt;
&lt;p&gt;Ключевые утверждения (гипотезы 1, 2 и 3, наблюдения 1 и 2) и связи между ними
представлены на диаграмме ниже:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/5-45.png&quot; style=&quot;{% style_stub dfcaaa 45 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;В левом столбце размещены утверждения для нечётных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-46.png&quot; style=&quot;{% style_stub efcaaa 46 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; в правом – для чётных.&lt;/p&gt;
&lt;p&gt;Звёздочками &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-47.png&quot; style=&quot;{% style_stub ffcaaa 47 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; помечены версии утверждений, сделанные в предположении попарного различия
всех простых множителей в разложении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-48.png&quot; style=&quot;{% style_stub gfcaaa 48 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (у всех факторов единичные степени). Стрелками
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-49.png&quot; style=&quot;{% style_stub hfcaaa 49 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; помечены обычные логические импликации, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-50.png&quot; style=&quot;{% style_stub ifcaaa 50 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; означает, что из
утверждения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-51.png&quot; style=&quot;{% style_stub jfcaaa 51 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; следует утверждение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-52.png&quot; style=&quot;{% style_stub kfcaaa 52 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Стрелки же &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-53.png&quot; style=&quot;{% style_stub lfcaaa 53 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (могущие быть заменёнными на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-54.png&quot; style=&quot;{% style_stub mfcaaa 54 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; позволяют показать, как одно
утверждение вносит вклад в доказательство другого: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-55.png&quot; style=&quot;{% style_stub nfcaaa 55 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; означает, что утверждение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-56.png&quot; style=&quot;{% style_stub ofcaaa 56 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
возможно наряду с другими утверждениями, «вносит вклад» в утверждение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-57.png&quot; style=&quot;{% style_stub pfcaaa 57 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – к примеру,
доказательство утверждения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-58.png&quot; style=&quot;{% style_stub qfcaaa 58 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; может входить, в качестве фрагмента, в доказательство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-59.png&quot; style=&quot;{% style_stub rfcaaa 59 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt;
понятно, что утверждение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-60.png&quot; style=&quot;{% style_stub sfcaaa 60 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в этом случае обычно логически необходимо для утверждения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-61.png&quot; style=&quot;{% style_stub tfcaaa 61 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е.
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-62.png&quot; style=&quot;{% style_stub ufcaaa 62 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Ну, может быть, это и не самые удачные обозначения… :)&lt;/p&gt;
&lt;h1 id=&quot;section-3&quot;&gt;Новые вспомогательные результаты&lt;/h1&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Гипотеза 4 (следствие гипотезы 2)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-63.png&quot; style=&quot;{% style_stub vfcaaa 63 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Доказательство&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Множество &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-64.png&quot; style=&quot;{% style_stub wfcaaa 64 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; состоит из натуральных чисел, не делящихся на простое &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-65.png&quot; style=&quot;{% style_stub xfcaaa 65 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Гипотеза утверждает,
что если все элементы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-66.png&quot; style=&quot;{% style_stub yfcaaa 66 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – суть делители максимума &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-67.png&quot; style=&quot;{% style_stub zfcaaa 67 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то сумма всех элементов &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-68.png&quot; style=&quot;{% style_stub agcaaa 68 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не равна
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-69.png&quot; style=&quot;{% style_stub bgcaaa 69 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Положим &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-70.png&quot; style=&quot;{% style_stub cgcaaa 70 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Пусть множество всех делителей есть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-71.png&quot; style=&quot;{% style_stub dgcaaa 71 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.к. элементы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-72.png&quot; style=&quot;{% style_stub egcaaa 72 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не делятся на
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-73.png&quot; style=&quot;{% style_stub fgcaaa 73 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то максимальный элемент, M, не делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-74.png&quot; style=&quot;{% style_stub ggcaaa 74 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; следовательно, ни один из элементов &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-75.png&quot; style=&quot;{% style_stub hgcaaa 75 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не
делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-76.png&quot; style=&quot;{% style_stub igcaaa 76 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Упорядочим все делители в возрастающую последовательность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-77.png&quot; style=&quot;{% style_stub jgcaaa 77 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Очевидно, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-78.png&quot; style=&quot;{% style_stub kgcaaa 78 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Теперь образуем частичные суммы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-79.png&quot; style=&quot;{% style_stub lgcaaa 79 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делителей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-80.png&quot; style=&quot;{% style_stub mgcaaa 80 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; по
правилу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-81.png&quot; style=&quot;{% style_stub ngcaaa 81 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-82.png&quot; style=&quot;{% style_stub ogcaaa 82 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-83.png&quot; style=&quot;{% style_stub pgcaaa 83 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-84.png&quot; style=&quot;{% style_stub qgcaaa 84 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-85.png&quot; style=&quot;{% style_stub rgcaaa 85 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; определяется как обычно. При
этом выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-86.png&quot; style=&quot;{% style_stub sgcaaa 86 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-87.png&quot; style=&quot;{% style_stub tgcaaa 87 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; присутствует в разложении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-88.png&quot; style=&quot;{% style_stub ugcaaa 88 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на простые
множители. Все эти условия делают применимой гипотезу 2. Она
утверждает, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-89.png&quot; style=&quot;{% style_stub vgcaaa 89 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; В
частности, т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-90.png&quot; style=&quot;{% style_stub wgcaaa 90 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; входит в факторизацию &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-91.png&quot; style=&quot;{% style_stub xgcaaa 91 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/5-92.png&quot; style=&quot;{% style_stub ygcaaa 92 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Теперь можно завершить доказательство, воспользовавшись методом от противного. Пусть
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-93.png&quot; style=&quot;{% style_stub zgcaaa 93 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Из этого следует, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-94.png&quot; style=&quot;{% style_stub ahcaaa 94 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – насыщенна относительно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-95.png&quot; style=&quot;{% style_stub bhcaaa 95 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е.
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-96.png&quot; style=&quot;{% style_stub chcaaa 96 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Но &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-97.png&quot; style=&quot;{% style_stub dhcaaa 97 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; говорит, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-98.png&quot; style=&quot;{% style_stub ehcaaa 98 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Противоречие. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-99.png&quot; style=&quot;{% style_stub fhcaaa 99 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Лемма 1 (следствие гипотезы 4)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-100.png&quot; style=&quot;{% style_stub ghcaaa 100 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-101.png&quot; style=&quot;{% style_stub hhcaaa 101 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такое, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-102.png&quot; style=&quot;{% style_stub ihcaaa 102 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Пусть также
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-103.png&quot; style=&quot;{% style_stub jhcaaa 103 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такое, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-104.png&quot; style=&quot;{% style_stub khcaaa 104 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Тогда &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-105.png&quot; style=&quot;{% style_stub lhcaaa 105 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Доказательство&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Предположим, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-106.png&quot; style=&quot;{% style_stub mhcaaa 106 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; откуда &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-107.png&quot; style=&quot;{% style_stub nhcaaa 107 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-108.png&quot; style=&quot;{% style_stub ohcaaa 108 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – множество делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-109.png&quot; style=&quot;{% style_stub phcaaa 109 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Тогда &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/5-110.png&quot; style=&quot;{% style_stub qhcaaa 110 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;
Заметим, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-111.png&quot; style=&quot;{% style_stub rhcaaa 111 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; ведь &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-112.png&quot; style=&quot;{% style_stub shcaaa 112 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; является своим делителем. При этом, очевидно, &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/5-113.png&quot; style=&quot;{% style_stub thcaaa 113 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; и, по построению, &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/5-114.png&quot; style=&quot;{% style_stub uhcaaa 114 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Т.к., по условию, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-115.png&quot; style=&quot;{% style_stub vhcaaa 115 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не делится на простое &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-116.png&quot; style=&quot;{% style_stub whcaaa 116 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-117.png&quot; style=&quot;{% style_stub xhcaaa 117 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не содержит &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-118.png&quot; style=&quot;{% style_stub yhcaaa 118 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в своей факторизации,
то в сумме &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-119.png&quot; style=&quot;{% style_stub zhcaaa 119 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; всех делителей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-120.png&quot; style=&quot;{% style_stub aicaaa 120 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; ни одно из слагаемых не делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-121.png&quot; style=&quot;{% style_stub bicaaa 121 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; и,
соответственно, ни один элемент множества &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-122.png&quot; style=&quot;{% style_stub cicaaa 122 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; тоже не кратен &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-123.png&quot; style=&quot;{% style_stub dicaaa 123 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; другими словами
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/5-124.png&quot; style=&quot;{% style_stub eicaaa 124 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Свойства &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-125.png&quot; style=&quot;{% style_stub ficaaa 125 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-126.png&quot; style=&quot;{% style_stub gicaaa 126 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; означают, что ко множеству &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-127.png&quot; style=&quot;{% style_stub hicaaa 127 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
при данном &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-128.png&quot; style=&quot;{% style_stub iicaaa 128 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; применима гипотеза 4. Её заключение
утверждает, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-129.png&quot; style=&quot;{% style_stub jicaaa 129 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; откуда следует, учитывая равенства &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-130.png&quot; style=&quot;{% style_stub kicaaa 130 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-131.png&quot; style=&quot;{% style_stub licaaa 131 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-132.png&quot; style=&quot;{% style_stub micaaa 132 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Противоречие. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-133.png&quot; style=&quot;{% style_stub nicaaa 133 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;section-4&quot;&gt;Практическое применение&lt;/h1&gt;
&lt;h2 id=&quot;section-5&quot;&gt;Нечётные совершенные числа&lt;/h2&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Определение&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-134.png&quot; style=&quot;{% style_stub oicaaa 134 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такое, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-135.png&quot; style=&quot;{% style_stub picaaa 135 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; называется &lt;em&gt;совершенным&lt;/em&gt; числом (половина суммы всех
делителей совершенного числа равна самому числу) &lt;a class=&quot;citation&quot; href=&quot;#wiki-perfect-number&quot;&gt;[2,3]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Гипотеза 5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-136.png&quot; style=&quot;{% style_stub qicaaa 136 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.е. предполагается, что не существует нечётных
совершенных чисел.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Примечание&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Иногда эту гипотезу называют гипотезой Эйлера, но весьма условно, в том смысле, что она восходит
аж к Никомаху Герасскому (&lt;em&gt;circa&lt;/em&gt; 100 лет до н.э.), см. переводы &lt;a class=&quot;citation&quot; href=&quot;#nicomachus-ru&quot;&gt;[4,5]&lt;/a&gt;. Более того, сам я точно не знаю, в какой именно из своих работ Эйлер
высказывался о возможном несуществовании нечётных совершенных чисел (как только узнаю, сразу
добавлю ссылку в список литературы).&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;В XIX веке, Сильвестер приводил известный эвристический аргумент &lt;a class=&quot;citation&quot; href=&quot;#sylvester1887&quot;&gt;[6]&lt;/a&gt; —
«сеть Сильвестра» — в пользу несуществования нечётных совершенных чисел. Он апеллировал к
слишком малой вероятности одновременного удовлетворения нечётным совершенным числом всем
известным ограничениям (а их накопилось немало) на возможный вид таких гипотетических объектов.&lt;/p&gt;
&lt;p&gt;В конце XX – начале XXI века появился теперь широко известный эвристический аргумент Померанса
&lt;a class=&quot;citation&quot; href=&quot;#pomerance-argument&quot;&gt;[7]&lt;/a&gt;. Сначала Карл Померанс вспоминает результат Эйлера о том, что
нечётное совершенное &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-137.png&quot; style=&quot;{% style_stub ricaaa 137 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; должно иметь вид &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-138.png&quot; style=&quot;{% style_stub sicaaa 138 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-139.png&quot; style=&quot;{% style_stub ticaaa 139 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-140.png&quot; style=&quot;{% style_stub uicaaa 140 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-141.png&quot; style=&quot;{% style_stub vicaaa 141 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; Померанс замечает, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-142.png&quot; style=&quot;{% style_stub wicaaa 142 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; должна делиться на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-143.png&quot; style=&quot;{% style_stub xicaaa 143 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Из
определения совершенного числа также вытекает, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-144.png&quot; style=&quot;{% style_stub yicaaa 144 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; должна делиться на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-145.png&quot; style=&quot;{% style_stub zicaaa 145 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Отсюда делается вывод об ограниченности количества таких &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-146.png&quot; style=&quot;{% style_stub ajcaaa 146 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; логарифмом от &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-147.png&quot; style=&quot;{% style_stub bjcaaa 147 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и о том, что
вероятность делимости &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-148.png&quot; style=&quot;{% style_stub cjcaaa 148 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-149.png&quot; style=&quot;{% style_stub djcaaa 149 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равна &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-150.png&quot; style=&quot;{% style_stub ejcaaa 150 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Вероятность же того, что
хотя-бы одно число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-151.png&quot; style=&quot;{% style_stub fjcaaa 151 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; подойдёт равна &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-152.png&quot; style=&quot;{% style_stub gjcaaa 152 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Из сходимости суммы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-153.png&quot; style=&quot;{% style_stub hjcaaa 153 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делается вывод о существовании лишь конечного количества нечётных совершенных
чисел.&lt;/p&gt;
&lt;p&gt;Далее Померанс обращается к фактическим результатам поиска таких чисел. Из того, что искомых
чисел, меньших &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-154.png&quot; style=&quot;{% style_stub ijcaaa 154 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не обнаружено, и из того, что для нечётных совершенных чисел, больших
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-155.png&quot; style=&quot;{% style_stub jjcaaa 155 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; должно выполняться &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-156.png&quot; style=&quot;{% style_stub kjcaaa 156 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; Померанс приходит к тому, что на самом деле лучше
рассматривать сумму &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-157.png&quot; style=&quot;{% style_stub ljcaaa 157 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (как я понимаю, из-за того,
что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-158.png&quot; style=&quot;{% style_stub mjcaaa 158 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; и, численно оценив эту сумму как не превышающую &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-159.png&quot; style=&quot;{% style_stub njcaaa 159 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;
делает заключение о слишком малой вероятности существования нечётных совершенных чисел и даже
сразу усиливает его до несуществования таких чисел.&lt;/p&gt;
&lt;p&gt;В общем, очень многие верили и верят (но не все; Декарт, возможно, являлся важным исключением) в
то, что существуют только чётные совершенные числа (причём, фактически, аргумент Померанса
применим и к чётным совершенных числам тоже, так что, хотя они и существуют, но их количество,
возможно, конечно). И аргументы Сильвестра и Померанса делают справедливость гипотезы 5 весьма вероятной.&lt;/p&gt;
&lt;p&gt;Я же собираюсь применить к гипотезе 5 строящуюся теория
насыщения. :)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство гипотезы 5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Пусть &lt;em&gt;произвольное&lt;/em&gt; нечётное &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-160.png&quot; style=&quot;{% style_stub ojcaaa 160 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; таково, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-161.png&quot; style=&quot;{% style_stub pjcaaa 161 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для некоторого
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-162.png&quot; style=&quot;{% style_stub qjcaaa 162 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; К этому случаю применима лемма 1 при &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-163.png&quot; style=&quot;{% style_stub rjcaaa 163 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Она говорит, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-164.png&quot; style=&quot;{% style_stub sjcaaa 164 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; А из
произвольности выбора нечётного &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-165.png&quot; style=&quot;{% style_stub tjcaaa 165 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; следует, что ни одно нечётное &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-166.png&quot; style=&quot;{% style_stub ujcaaa 166 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не может удовлетворять
уравнению &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-167.png&quot; style=&quot;{% style_stub vjcaaa 167 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. не может быть совершенным. Иначе говоря, все совершенные числа
являются чётными. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-168.png&quot; style=&quot;{% style_stub wjcaaa 168 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Это доказательство опиралось на гипотезу 2 (или более общую
гипотезу 1), утверждающую, что из насыщенности следует
сильная насыщенность. Но так получилось, что наблюдение 1
об отсутствии насыщенных сумм делителей нечётных чисел может использоваться для упрощённого
доказательства гипотезы 5 напрямую (т.е., на текущий момент,
теория насыщения включает в себя больше чем требуется для доказательства отсутствия нечётных
совершенных чисел).&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-169.png&quot; style=&quot;{% style_stub xjcaaa 169 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – &lt;em&gt;сумма собственных делителей&lt;/em&gt; числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-170.png&quot; style=&quot;{% style_stub yjcaaa 170 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (ещё её
называют &lt;em&gt;аликватной суммой&lt;/em&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Доказательство 2 гипотезы 5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Очевидно, совершенные числа могут быть определены как неподвижные точки функции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-171.png&quot; style=&quot;{% style_stub zjcaaa 171 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Так если
некоторое нечётное &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-172.png&quot; style=&quot;{% style_stub akcaaa 172 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; является неподвижной точкой &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-173.png&quot; style=&quot;{% style_stub bkcaaa 173 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-174.png&quot; style=&quot;{% style_stub ckcaaa 174 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; откуда
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-175.png&quot; style=&quot;{% style_stub dkcaaa 175 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Но наблюдение 1 говорит, что для
нечётного &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-176.png&quot; style=&quot;{% style_stub ekcaaa 176 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; никакая частичная сумма делителей, в т.ч. и аликватная сумма, не может быть
насыщенной и, соответственно, не может делиться на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-177.png&quot; style=&quot;{% style_stub fkcaaa 177 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Противоречие. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-178.png&quot; style=&quot;{% style_stub gkcaaa 178 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Эйлер показал, что у нечётных совершенных чисел один фактор должен иметь степень, сравнимую с
единицей по модулю 4, остальные – чётные степени. Поэтому, рассмотренного в предыдущем
сообщении специального случая факторизации без повторов, при которой все степени нечётны и равны
единице, явно не достаточно для применения к гипотезе 5 (хотя
в заключительной части того сообщения я указал на возможный путь обобщения).&lt;/p&gt;
&lt;p&gt;Выше я продемонстрировал возможный подход к проблеме нечётных совершенных чисел. И как только
общее доказательство гипотезы 2 будет готово, это сразу же
будет означать, что действительно не существует ни одного нечётного совершенного числа. :)&lt;/p&gt;
&lt;p&gt;В приложении A может быть найдена заплатка, обеспечивающая искомое обобщение выполненного ранее
доказательства наблюдения 1. Неявно подразумевается, что
адаптация других доказательств из первой части этой серии сообщений, тоже может быть выполнена
без особых трудностей или же вовсе не требуется.&lt;/p&gt;
&lt;h1 id=&quot;section-6&quot;&gt;Заключение&lt;/h1&gt;
&lt;p&gt;Сам срок, прошедший с выхода «Введения в арифметику» Никомаха из Герасы, превысивший уже две
тысячи лет, намекает на некоторую подозрительность моего результата.&lt;/p&gt;
&lt;p&gt;Вероятностный аргумент Померанса так и вовсе есть образец неоднозначности типа «стакан полон
&lt;em&gt;versus&lt;/em&gt; стакан пуст» – можно делать акцент на исчезающе малой вероятности и, соответственно,
делать вывод о несуществовании нечётных совершенных чисел (даже несмотря, ещё раз повторюсь, на
потенциальную применимость этого аргумента к чётным совершенным числам при их явном
существовании), а можно обратить внимание на возможное не равенство этой вероятности нулю и
сделать вывод (противоположный!) о их возможном существовании, – хотя, в то же самое время,
подходящая вариация аргумента Померанса, по-видимому, могла бы оказаться ценной для обоснования
гипотезы о конечности всех совершенных чисел.&lt;/p&gt;
&lt;p&gt;Таким образом, убедительной независимой поддержки верности или ошибочности моего доказательства
мне найти не удалось. Но сам феномен насыщения не становится от этого менее интересным.&lt;/p&gt;
&lt;p&gt;Вопросы и задачи, остающиеся пока открытыми:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Верна ли гипотеза 1? Я лишь высказал её, но &lt;em&gt;de facto&lt;/em&gt;
вместо неё доказывал и применял гипотезу 2;&lt;/li&gt;
&lt;li&gt;Каковы другие возможные применения теории насыщения?&lt;/li&gt;
&lt;li&gt;Потенциально интересной целевой задачей для настоящей теории мог бы стать [тоже пока открытый]
вопрос о конечности количества совершенных чисел вообще (т.е. &lt;em&gt;чётных&lt;/em&gt;, раз нечётных
скорее-всего не существует). Но пригоден ли этот математический аппарат для решения задач такого
рода?&lt;/li&gt;
&lt;li&gt;Можно временно проигнорировать возраст «гипотезы Никомаха-Эйлера», вспомнив, что теорема
Гёделя о неполноте появилась только в веке XX, и задаться вопросом, а не обусловлено ли
перманентное ускользания нечётных совершенных чисел от попыток их поиска именно подобными
явлениями. Другими словами, не является ли гипотеза 5
недоказуемой?&lt;/li&gt;
&lt;li&gt;Требуется исправить, обобщить и скомпилировать имеющиеся фрагментарные наброски доказательств,
придав теории насыщения достаточную формализованность.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;section-7&quot;&gt;Ссылки&lt;/h1&gt;
&lt;ul class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;saturation-theory-part-1&quot;&gt;1. &lt;/span&gt; &lt;a href=&quot;http://circiter.github.io/saturation-theory-part-1&quot;&gt;http://circiter.github.io/saturation-theory-part-1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-perfect-number&quot;&gt;2. &lt;/span&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/perfect_number&quot;&gt;http://en.wikipedia.org/wiki/perfect_number&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-perfect-number-ru&quot;&gt;3. &lt;/span&gt; &lt;a href=&quot;http://ru.wikipedia.org/wiki/совершенное_число&quot;&gt;http://ru.wikipedia.org/wiki/совершенное_число&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;nicomachus-ru&quot;&gt;4. Никомах Геразский. Введение в арифметику / пер. Щетников А.И.&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;nicomachus-en&quot;&gt;5. Nicomachus of Gerasa. Introduction to Arithmetic / пер. Martin Luther D’Ooge&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;sylvester1887&quot;&gt;6. Sylvester J.J. Sur les nombres dits de Hamilton. 1887&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;pomerance-argument&quot;&gt;7. Pomerance’s Heuristic that Odd Perfect Numbers are Unlikely&lt;/span&gt; &lt;a href=&quot;http://web.archive.org/web/20061229094011/http://oddperfect.org/pomerance.html&quot;&gt;http://web.archive.org/web/20061229094011/http://oddperfect.org/pomerance.html&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;h1 id=&quot;a&quot;&gt;Приложение A&lt;/h1&gt;
&lt;p&gt;В данном приложении представлена «заплатка», предположительно исправляющая (обобщающая)
доказательство наблюдения 1 (само доказательство находится
в &lt;a href=&quot;http://circiter.github.io/saturation-theory-part-1&quot;&gt;первой части&lt;/a&gt; этой серии сообщений).&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt; Функция Эйлера &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-179.png&quot; style=&quot;{% style_stub hkcaaa 179 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равна количеству чисел, меньших &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-180.png&quot; style=&quot;{% style_stub ikcaaa 180 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и взаимно
простых с ним.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Предложение:&lt;/strong&gt; Известно, что для степени &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-181.png&quot; style=&quot;{% style_stub jkcaaa 181 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; простого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-182.png&quot; style=&quot;{% style_stub kkcaaa 182 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/5-183.png&quot; style=&quot;{% style_stub lkcaaa 183 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;В наброске доказательства наблюдения 1 использовалась
конструктивная китайская теорема об остатках, дававшая решение (по модулю &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-184.png&quot; style=&quot;{% style_stub mkcaaa 184 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; вида
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/5-185.png&quot; style=&quot;{% style_stub nkcaaa 185 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; где
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-186.png&quot; style=&quot;{% style_stub okcaaa 186 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – все различные факторы числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-187.png&quot; style=&quot;{% style_stub pkcaaa 187 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для случае его факторизации без повторов:
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-188.png&quot; style=&quot;{% style_stub qkcaaa 188 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;В общем случае, число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-189.png&quot; style=&quot;{% style_stub rkcaaa 189 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; факторизуется в виде &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-190.png&quot; style=&quot;{% style_stub skcaaa 190 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (каноническое
разложение), где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-191.png&quot; style=&quot;{% style_stub tkcaaa 191 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – максимальная степень простого делителя &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-192.png&quot; style=&quot;{% style_stub ukcaaa 192 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; на которую делится
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-193.png&quot; style=&quot;{% style_stub vkcaaa 193 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; В заключительной части предыдущего сообщения я предположил, что можно, при применении
К.Т.О., вместо простых чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-194.png&quot; style=&quot;{% style_stub wkcaaa 194 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; использовать взаимно простые модули &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-195.png&quot; style=&quot;{% style_stub xkcaaa 195 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Теперь
я уверен, что это действительно можно сделать.&lt;/p&gt;
&lt;p&gt;Обозначим &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-196.png&quot; style=&quot;{% style_stub ykcaaa 196 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Очевидно, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-197.png&quot; style=&quot;{% style_stub zkcaaa 197 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (т.е. модули &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-198.png&quot; style=&quot;{% style_stub alcaaa 198 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; попарно взаимно просты). Тогда конструктивная версия К.Т.О.
даст решение в виде &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/5-199.png&quot; style=&quot;{% style_stub blcaaa 199 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; заменяющим решение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-200.png&quot; style=&quot;{% style_stub clcaaa 200 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-201.png&quot; style=&quot;{% style_stub dlcaaa 201 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; следует, что показатель степени в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-202.png&quot; style=&quot;{% style_stub elcaaa 202 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
равен &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-203.png&quot; style=&quot;{% style_stub flcaaa 203 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Очевидно,
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-204.png&quot; style=&quot;{% style_stub glcaaa 204 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а из-за нечётности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-205.png&quot; style=&quot;{% style_stub hlcaaa 205 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-206.png&quot; style=&quot;{% style_stub ilcaaa 206 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Отсюда,
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/5-207.png&quot; style=&quot;{% style_stub jlcaaa 207 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;(Полная роль этого неравенства мне пока неясна, а далее пока будет достаточно условия &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-208.png&quot; style=&quot;{% style_stub klcaaa 208 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Здесь будут пропущены рассуждения, аналогичные рассуждениям из первого сообщения (выполненным
для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-209.png&quot; style=&quot;{% style_stub llcaaa 209 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а не для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-210.png&quot; style=&quot;{% style_stub mlcaaa 210 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; приводящие в настоящем случае к необходимости проверки делимости
выражения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-211.png&quot; style=&quot;{% style_stub nlcaaa 211 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на модули &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-212.png&quot; style=&quot;{% style_stub olcaaa 212 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Из этих рассуждений вытекает задача
проверки дробности выражения &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/5-213.png&quot; style=&quot;{% style_stub plcaaa 213 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; полученного из
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-214.png&quot; style=&quot;{% style_stub qlcaaa 214 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делением его на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-215.png&quot; style=&quot;{% style_stub rlcaaa 215 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (для произвольного &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-216.png&quot; style=&quot;{% style_stub slcaaa 216 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; и выноса одного из
слагаемых суммы за её пределы.&lt;/p&gt;
&lt;p&gt;Легко видеть, что подвыражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-217.png&quot; style=&quot;{% style_stub tlcaaa 217 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; всегда больше нуля, а вот подвыражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-218.png&quot; style=&quot;{% style_stub ulcaaa 218 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
может быть равно нулю (если все факторы числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-219.png&quot; style=&quot;{% style_stub vlcaaa 219 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равны друг другу).&lt;/p&gt;
&lt;p&gt;Дальнейшие рассуждения полностью аналогичны уже выполненным в первом сообщении. Я лишь кратко
повторю самое важное. Итак, в подвыражении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-220.png&quot; style=&quot;{% style_stub wlcaaa 220 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; мы можем поделить &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-221.png&quot; style=&quot;{% style_stub xlcaaa 221 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-222.png&quot; style=&quot;{% style_stub ylcaaa 222 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; что
даст целое число, большее единицы. Единица могла бы получиться только если в наличии имелся бы
ровно один модуль &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-223.png&quot; style=&quot;{% style_stub zlcaaa 223 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но в таком случае всё подвыражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-224.png&quot; style=&quot;{% style_stub amcaaa 224 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; было бы нулём (см.
предыдущий абзац), а значит – целым числом. Если же дробь &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-225.png&quot; style=&quot;{% style_stub bmcaaa 225 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то после
возведения в &lt;em&gt;ненулевую&lt;/em&gt; степень — &lt;em&gt;cf.&lt;/em&gt; неравенство &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-226.png&quot; style=&quot;{% style_stub cmcaaa 226 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; — получится целое
число, большее единицы и делящееся на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-227.png&quot; style=&quot;{% style_stub dmcaaa 227 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (т.к. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-228.png&quot; style=&quot;{% style_stub emcaaa 228 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt; Это приводит к целочисленности
подвыражения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-229.png&quot; style=&quot;{% style_stub fmcaaa 229 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;В подвыражении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-230.png&quot; style=&quot;{% style_stub gmcaaa 230 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; дробь &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-231.png&quot; style=&quot;{% style_stub hmcaaa 231 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – целая. Но важно, что такая дробь
«вычеркивает» &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-232.png&quot; style=&quot;{% style_stub imcaaa 232 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-233.png&quot; style=&quot;{% style_stub jmcaaa 233 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; и, поэтому, сама дробь на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-234.png&quot; style=&quot;{% style_stub kmcaaa 234 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; второй раз уже не делится.
Результат возведения в степень &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-235.png&quot; style=&quot;{% style_stub lmcaaa 235 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; тоже не будет делиться на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-236.png&quot; style=&quot;{% style_stub mmcaaa 236 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (составляющим
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-237.png&quot; style=&quot;{% style_stub nmcaaa 237 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; факторам неоткуда взяться). Число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-238.png&quot; style=&quot;{% style_stub omcaaa 238 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; по аналогии с предыдущим сообщением, определим
как остаток от деления частичной суммы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-239.png&quot; style=&quot;{% style_stub pmcaaa 239 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на модуль &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-240.png&quot; style=&quot;{% style_stub qmcaaa 240 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Такой остаток меньше
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-241.png&quot; style=&quot;{% style_stub rmcaaa 241 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и делиться на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-242.png&quot; style=&quot;{% style_stub smcaaa 242 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не может. В итоге получается, что подвыражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-243.png&quot; style=&quot;{% style_stub tmcaaa 243 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – есть
дробь со знаменателем &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-244.png&quot; style=&quot;{% style_stub umcaaa 244 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и числителем, не делящимся на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-245.png&quot; style=&quot;{% style_stub vmcaaa 245 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.е. подвыражение
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-246.png&quot; style=&quot;{% style_stub wmcaaa 246 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – дробное число. (Здесь стоит подчеркнуть ещё раз, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-247.png&quot; style=&quot;{% style_stub xmcaaa 247 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; вычеркивается из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-248.png&quot; style=&quot;{% style_stub ymcaaa 248 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
и, в результате, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-249.png&quot; style=&quot;{% style_stub zmcaaa 249 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; поэтому дробность или
целочисленность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-250.png&quot; style=&quot;{% style_stub ancaaa 250 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; полностью определяется делимостью &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-251.png&quot; style=&quot;{% style_stub bncaaa 251 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-252.png&quot; style=&quot;{% style_stub cncaaa 252 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Всё это говорит о том, что выражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-253.png&quot; style=&quot;{% style_stub dncaaa 253 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; как сумма дробного и
целого чисел, – есть число дробное. Другими словами, выражение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-254.png&quot; style=&quot;{% style_stub encaaa 254 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не
делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-255.png&quot; style=&quot;{% style_stub fncaaa 255 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а из произвольности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-256.png&quot; style=&quot;{% style_stub gncaaa 256 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; получается, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-257.png&quot; style=&quot;{% style_stub hncaaa 257 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не
делится вообще ни на один из модулей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-258.png&quot; style=&quot;{% style_stub incaaa 258 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Можно ли считать, как думал я при написании предварительной версии этого сообщения, что, по
аналогии с доказательством из первого сообщения, некратность делителя каждому из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-259.png&quot; style=&quot;{% style_stub jncaaa 259 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
доказывает шаг индукции из-за противоречия с «критериями делителя» (см. первое сообщение;
кратко: делитель &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-260.png&quot; style=&quot;{% style_stub kncaaa 260 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; должен делиться хотя бы на один из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-261.png&quot; style=&quot;{% style_stub lncaaa 261 inline %}&quot; class=&quot;latex&quot;&gt;)?&lt;/span&gt; Нет! Если текущий делитель
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-262.png&quot; style=&quot;{% style_stub mncaaa 262 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не делится на некоторый &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-263.png&quot; style=&quot;{% style_stub nncaaa 263 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то это не значит, что он не делится,
скажем для примера, на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-264.png&quot; style=&quot;{% style_stub oncaaa 264 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Фактически, рассуждения, приведённые выше в этой заплатке действуют только если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-265.png&quot; style=&quot;{% style_stub pncaaa 265 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
принадлежит подходящему подмножеству множества &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-266.png&quot; style=&quot;{% style_stub qncaaa 266 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-267.png&quot; style=&quot;{% style_stub rncaaa 267 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Такое подмножество
должно состоять из делителей, могущих быть «собранными» из модулей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-268.png&quot; style=&quot;{% style_stub sncaaa 268 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Для других
делителей описанный аргумент не работает. Но это же и подсказывает возможный гипотетический путь
завершения доказательства шага индукции.&lt;/p&gt;
&lt;p&gt;В первом сообщении мы имели дело с &lt;em&gt;системой модулей&lt;/em&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-269.png&quot; style=&quot;{% style_stub tncaaa 269 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; в настоящем сообщении – с
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-270.png&quot; style=&quot;{% style_stub uncaaa 270 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Это – предельные, крайние случаи, и, возможно, разрешить возникшую проблему
удастся с помощью введения большего количества «промежуточных» систем модулей. Этот зыбкий
путь опирается на ряд вспомогательных [остающихся пока недоказанными] гипотез.&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Определение&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-271.png&quot; style=&quot;{% style_stub vncaaa 271 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – семейство всех возможных систем модулей (для данного числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-272.png&quot; style=&quot;{% style_stub wncaaa 272 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt; Для
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-273.png&quot; style=&quot;{% style_stub xncaaa 273 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; обозначим &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-274.png&quot; style=&quot;{% style_stub yncaaa 274 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Для нужд К.Т.О.
необходимо, чтобы выполнялось &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-275.png&quot; style=&quot;{% style_stub zncaaa 275 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Каждая система &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-276.png&quot; style=&quot;{% style_stub aocaaa 276 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; порождает подмножество &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-277.png&quot; style=&quot;{% style_stub bocaaa 277 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; такое, что каждый
делитель &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-278.png&quot; style=&quot;{% style_stub cocaaa 278 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; конструируется из этих модулей, т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-279.png&quot; style=&quot;{% style_stub docaaa 279 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Гипотеза 6 (без доказательства):&lt;/strong&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-280.png&quot; style=&quot;{% style_stub eocaaa 280 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.е. гипотетическая функция
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-281.png&quot; style=&quot;{% style_stub focaaa 281 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; классифицирует делители по их индексам в последовательности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-282.png&quot; style=&quot;{% style_stub gocaaa 282 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и
сопоставляет им подходящие системы модулей.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Идея доказательства:&lt;/strong&gt; Может быть эту гипотезу и не надо доказывать. :) Может быть сгодится
аргумент «по определению». Будем просто перебирать всевозможные системы модулей из
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-283.png&quot; style=&quot;{% style_stub hocaaa 283 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и для каждой &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-284.png&quot; style=&quot;{% style_stub iocaaa 284 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; находить подходящее подмножество (максимальное по
включению) &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-285.png&quot; style=&quot;{% style_stub jocaaa 285 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Табулирование индексов входящих в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-286.png&quot; style=&quot;{% style_stub kocaaa 286 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; делителей и даст требуемое
отображение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-287.png&quot; style=&quot;{% style_stub locaaa 287 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-288.png&quot; style=&quot;{% style_stub mocaaa 288 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Предложение 1:&lt;/strong&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-289.png&quot; style=&quot;{% style_stub nocaaa 289 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Это просто обновлённый критерий делителя; само утверждения я нахожу достаточно
очевидным.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sentence-block&quot;&gt;
&lt;p&gt;&lt;strong&gt;Гипотеза 7 (без доказательства)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-290.png&quot; style=&quot;{% style_stub oocaaa 290 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для некоторого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-291.png&quot; style=&quot;{% style_stub pocaaa 291 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (см. гипотезу 6) и пусть система сравнений &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-292.png&quot; style=&quot;{% style_stub qocaaa 292 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-293.png&quot; style=&quot;{% style_stub rocaaa 293 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; пробегает все возможные
значения) имеет решение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-294.png&quot; style=&quot;{% style_stub socaaa 294 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (N.B., по модулю &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-295.png&quot; style=&quot;{% style_stub tocaaa 295 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а не
обязательно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-296.png&quot; style=&quot;{% style_stub uocaaa 296 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; для некоторого числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-297.png&quot; style=&quot;{% style_stub vocaaa 297 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; [даваемого К.Т.О.]. Тогда, если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-298.png&quot; style=&quot;{% style_stub wocaaa 298 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не делится на
некоторый &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-299.png&quot; style=&quot;{% style_stub xocaaa 299 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-300.png&quot; style=&quot;{% style_stub yocaaa 300 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-301.png&quot; style=&quot;{% style_stub zocaaa 301 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Кратко: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-302.png&quot; style=&quot;{% style_stub apcaaa 302 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Соображения по доказательству:&lt;/strong&gt; Я не знаю как доказать эту гипотезу, но все претензии здесь к
китайской теореме об остатках. :) Я просто принимаю за должное, что если оценка делителя, т.е.
решение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-303.png&quot; style=&quot;{% style_stub bpcaaa 303 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; полученное применением этой теоремы, делится на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-304.png&quot; style=&quot;{% style_stub cpcaaa 304 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то и настоящий делитель
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-305.png&quot; style=&quot;{% style_stub dpcaaa 305 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; должен делиться на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-306.png&quot; style=&quot;{% style_stub epcaaa 306 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (разве не разумно ожидать, что оценка или приближение некоторого
объекта, должны обладать большинством свойств этого объекта?). Проблема здесь в том, что
основная теорема арифметики, в таком случае, приводит к равенству &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-307.png&quot; style=&quot;{% style_stub fpcaaa 307 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но в реальности
численные значения делителя и его К.Т.О.-оценки вроде как не обязаны совпадать… Одна из
«дырок» теории насыщения, возможно, находится именно здесь.&lt;/p&gt;
&lt;p&gt;На основе этих дополнительных определений и гипотез можно продолжить говорить об основном
доказательстве [наблюдения 1].&lt;/p&gt;
&lt;p&gt;Итак, подразумевается, что для любой &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-308.png&quot; style=&quot;{% style_stub gpcaaa 308 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; действительна прямая адаптация
аргумента, приведённого в начале описания этой заплатки. Применение такого аргумента приводит к
выводу о том, что на некотором шаге индуктивного доказательства наблюдения 1, решение системы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-309.png&quot; style=&quot;{% style_stub hpcaaa 309 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а именно
число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-310.png&quot; style=&quot;{% style_stub ipcaaa 310 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; оказывается некратным каждому из модулей &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-311.png&quot; style=&quot;{% style_stub jpcaaa 311 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Из гипотезы 7 тогда следует, что и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-312.png&quot; style=&quot;{% style_stub kpcaaa 312 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не делится ни на один из
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/5-313.png&quot; style=&quot;{% style_stub lpcaaa 313 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Но это нарушает новый критерий делителя из предложения 1 и приводит к желаемому противоречию, доказывая, т.о., шаг индукции (от
противного) и теперь наконец-то завершает доказательство.&lt;/p&gt;
&lt;p&gt;Ещё раз подчёркиваю, что приведённый в настоящем приложении фрагмент является именно
«заплаткой», требующей своего наложения на исходное доказательство наблюдения 1 из первого сообщения. Как нибудь потом я обязательно напишу
полное доказательство, но пока заплатка лучше чем ничего… :)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Небольшая коллекция sed-скриптов.</title>
   <link href="http://circiter.tk/sed-collection"/>
   <updated>2022-05-07T02:05:34+00:00</updated>
   <id>http://circiter.tk/sed-collection</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;Нецелевое использование поточного редактора.&lt;/h1&gt;
&lt;p&gt;На данной странице представлен краткий аннотированный список некоторых непрактичных сценариев для
широко известного поточного редактора &lt;a href=&quot;http://en.wikipedia.org/wiki/sed&quot;&gt;sed&lt;/a&gt;. В работе этой утилиты основное место занимает команда
&lt;code&gt;s/&amp;lt;шаблон&amp;gt;/&amp;lt;замещающий_текст&amp;gt;/&lt;/code&gt; (вместо символа &lt;code&gt;/&lt;/code&gt; может использоваться и другой разделитель),
ищущая и заменяющая фрагмент текста, удовлетворяющий некоторому регулярному выражению-шаблону.&lt;/p&gt;
&lt;p&gt;Эта команда, могущая показаться далёкой по своей функциональности от обеспечения Тьюринг-полноты
входного языка sed, вместе с метками и командами перехода (условного и безусловного) всё же
делает данный редактор вычислительно-универсальным. Фактически, он может рассматриваться в
качестве реализации &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC&quot;&gt;нормальных алгорифмов Маркова&lt;/a&gt; (хотя это и не общепринятое мнение), а
полнота по-Тьюрингу обуславливает саму возможность всех произошедших с sed приключений [с его
нестандартным использованием].&lt;/p&gt;
&lt;p&gt;В основном, здесь представлены мои скрипты, но в конце приводится список некоторых из похожих
на них в своей непрактичности (а нередко кратно превышающих мои поделки в своей удивительности
и технологической сложности реализации) скриптов других авторов.&lt;/p&gt;
&lt;p&gt;Сложно, а быть может уже и вовсе невозможно сказать, какие ещё необычные сценарии писались за всю
историю существования этого редактора, использовавшегося с начала/середины семидесятых годов
прошлого века; так что остаётся лишь продолжать неспешные поиски аналогичных артефактов и, конечно,
писать свои.&lt;/p&gt;
&lt;p&gt;Итак, моя учетная запись на GitHub содержит следующие репозитории со скриптами для sed:&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcirciterocr-in-sedocr-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/ocr-in-sed&quot;&gt;ocr-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Этот скрипт написан под впечатлением от однострочной C-программы некоего Эрика Копчинского
(&lt;a href=&quot;http://www.mimuw.edu.pl/~erykk&quot;&gt;Eryk Kopczynski&lt;/a&gt;), написанной для небезызвестного
конкурса &lt;a href=&quot;http://ioccc.org&quot;&gt;ioccc&lt;/a&gt; за 2004 год и выполняющей оптическое распознавание
текста находя эйлерову характеристику его «триангуляции» (насколько
вообще можно говорить о триангуляции для картинки в стиле ASCII-арт).&lt;/p&gt;
&lt;p&gt;Да, меня тоже сначала сбила с толку возможность распознавания на основе именно этого
топологического инварианта, очевидно имеющего одинаковые значения вообще для всех планарных
графов; поэтому интересующихся пока переадресую на статью (S.B.Gray, Local Properties
of Binary Images in Two Dimensions, 1971), предположительно являющуюся основой для программы
Копчинского. По-сути, авторы расчитывают инвариант, равный разности между количеством связных
областей и количеством дырок, но расчитывают его подсчитывая различные чисто локальные конфигурации
пикселей в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-0.png&quot; style=&quot;{% style_stub mpcaaa 0 inline %}&quot; class=&quot;latex&quot;&gt;-окне,&lt;/span&gt; пробегая им по всему изображению (в статье этот сверточный подход
распространен и на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-1.png&quot; style=&quot;{% style_stub npcaaa 1 inline %}&quot; class=&quot;latex&quot;&gt;-окна,&lt;/span&gt; но у Копчинского применено маленькое окно).&lt;/p&gt;
&lt;p&gt;Увы, особая простота этой логики сильно ограничивает функциональность основанной на ней программы
распознования символов… И кроме целых из, скажем так, не очень большого промежутка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-2.png&quot; style=&quot;{% style_stub opcaaa 2 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; эта
OCR-программа ничего распознать толком не может.&lt;/p&gt;
&lt;p&gt;В любом случая, я решил реализовать этот же алгоритм, написав аналогичный скрипт для sed;
естественно вообще не стремясь к однострочности.&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcirciterdrawing-in-seddrawing-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/drawing-in-sed&quot;&gt;drawing-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Простой графический редактор, выполняющий команды со стандартного ввода и реализующий
некоторое подмножество/версию &lt;a href=&quot;http://en.wikipedia.org/wiki/Turtle_graphics&quot;&gt;черепашьей графики&lt;/a&gt; и
&lt;a href=&quot;http://en.wikipedia.org/wiki/L-system&quot;&gt;систем Линденмайера&lt;/a&gt;. Сгодится для рисования
некоторых геометрических фигур, символов, фракталов. Не самое очевидное применение sed,
не так ли?&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcircitercomputus-in-sedcomputus-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/computus-in-sed&quot;&gt;computus-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;А это почти полезный скрипт, &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%BF%D0%B0%D1%81%D1%85%D0%B0%D0%BB%D0%B8%D1%8F&quot;&gt;расчитывающий&lt;/a&gt; дату православной
Пасхи. Теоретически, может быть легко модифицирован для расчета дат католической, еврейской,
астрономической Пасхи. Больше информации можно найти в
&lt;a href=&quot;http://circiter.github.io/computus-in-sed&quot;&gt;отдельном сообщении&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcirciterlangton-ant-in-sedlangton-ant-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/langton-ant-in-sed&quot;&gt;langton-ant-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Симуляция известного автомата «&lt;a href=&quot;http://en.wikipedia.org/wiki/Langton%27s_ant&quot;&gt;муравей
Лангтона&lt;/a&gt;», интересного, среди прочего, своей
Тьюринг-полнотой и интересной открытой проблемой, связанной с аттракторами («дорога» с
периодом 104 шага) этой динамической системы для всех конечных начальных конфигураций.&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcirciterelementary-ca-in-sedelementary-ca-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/elementary-ca-in-sed&quot;&gt;elementary-ca-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/elementary_cellular_automaton&quot;&gt;Элементарные&lt;/a&gt; одномерные конечные
автоматы по-Вольфраму. Достаточно полезная возможность для sed, позволяющая создавать узоры,
генерировать псевдослучайные числа, моделировать некоторые физические процессы.&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcirciterlife-in-sedlife-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/life-in-sed&quot;&gt;life-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life&quot;&gt;Игра «жизнь»&lt;/a&gt; Конвея, теперь и на sed.&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcircitermusic-in-sedmusic-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/music-in-sed&quot;&gt;music-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Пианино на sed! Кто же не делал что-то вроде &lt;code&gt;cat /dev/urandom &amp;gt; /dev/audio&lt;/code&gt; или
&lt;code&gt;sudo cat /dev/mem &amp;gt; /dev/audio&lt;/code&gt;? Редактор sed вполне может приняв со стандартного ввода
нотную запись, синтезировать последовательность символов, которая будучи отправленной в
&lt;a href=&quot;http://www.opensound.com&quot;&gt;oss&lt;/a&gt;-устройство &lt;code&gt;/dev/audio&lt;/code&gt; (или его аналог), приводит к проигрыванию
соответствующей мелодии через звуковую карту. Всё очень просто. :)&lt;/p&gt;
&lt;p&gt;Поводом для написания этого скрипта явилось &lt;a href=&quot;http://kmkeen.com/awk-music&quot;&gt;сообщение&lt;/a&gt; Kyle Keen об
этом способе генерации звука. Но там был применен полноценный язык программирования awk,
позволивший легко получить более качественный чем у меня звук за счет использования треугольной формы
сигнала. Так появилась музыкальная программа-синтезатор на гораздо более ограниченном sed, именно
в силу ограниченности и представляющем больший спортивный интерес.&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcircitermaze-in-sedmaze-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/maze-in-sed&quot;&gt;maze-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;В попытке понять написанную на sed одним [предположительно Сингапурским]
&lt;a href=&quot;https://github.com/xsot&quot;&gt;хакером&lt;/a&gt; программу поиска выхода из лабиринта я
написал свою версию, включив в поставку [пока не полностью работоспособный]
комплементарный генератор лабиринтов (естественно тоже на sed).&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcircitersieve-in-sedsieve-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/sieve-in-sed&quot;&gt;sieve-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&quot;&gt;Решето Эратосфена&lt;/a&gt; на sed. Кроме собственно
решета, реализованного в &lt;code&gt;sieve.sed&lt;/code&gt;, в репозитории можно найти скрипт &lt;code&gt;factor.sed&lt;/code&gt;, разлагающий
данное число на его простые делители. А для демонстрации применения простых чисел (и в
соответствии с эзотерической направленностью подобных развлечений с редактором sed) позже были
добавлены скрипты &lt;code&gt;anagram.sed&lt;/code&gt; и &lt;code&gt;collatz.sed&lt;/code&gt;, – для детектирования анаграмм, и для
реализации динамической системы из гипотезы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-3.png&quot; style=&quot;{% style_stub ppcaaa 3 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (&lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%B3%D0%B8%D0%BF%D0%BE%D1%82%D0%B5%D0%B7%D0%B0_%D0%9A%D0%BE%D0%BB%D0%BB%D0%B0%D1%82%D1%86%D0%B0&quot;&gt;гипотезы
Коллатца&lt;/a&gt;), соответственно.&lt;/p&gt;
&lt;p&gt;Позже была написана реализация решета Эйлера, вычеркивающего каждое составное число только один
раз (см. &lt;code&gt;euler-sieve.sed&lt;/code&gt; в том же репозитории). Правда, как потом выяснилось, этот код не
имеет вообще никаких преимуществ перед обычным решетом Эратосфена из-за слишком дорогой операции
умножения на sed или, по крайней мере, из-за выбранного способа осуществления умножения.&lt;/p&gt;
&lt;p&gt;Объяснение работы данных скриптов содержится в отдельном
&lt;a href=&quot;http://circiter.github.io/sieve-of-eratosthenes-in-sed&quot;&gt;сообщении&lt;/a&gt; этого дневника.&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcircitersuperpermutations-in-sedsuperpermutations-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/superpermutations-in-sed&quot;&gt;superpermutations-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Генерация [вообще говоря, не являющихся минимальными]
&lt;a href=&quot;http://en.wikipedia.org/wiki/superpermutation&quot;&gt;суперперестановок&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcircitercw-in-sedcw-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/cw-in-sed&quot;&gt;cw-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Этот скрипт принимает на вход текстовое сообщение и генерирует тональный телеграфный сигнал
(код Морзе), проигрываемый звуковой картой компьютера по принципу, описанному выше в разделе
о синтезаторе мелодий.&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcirciterr2d2-in-sedr2d2-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/r2d2-in-sed&quot;&gt;r2d2-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Синтезатор «речи» робота &lt;a href=&quot;http://en.wikipedia.org/wiki/R2-D2&quot;&gt;r2d2&lt;/a&gt; из вселенной «Звёздных Войн»
Д.Лукаса. Применен тот же принцип генерации текстового потока, озвучиваемого перенаправлением в
&lt;code&gt;/dev/audio&lt;/code&gt;. В отличии от программы-пианино или от генератора «морзянки», здесь кроме чистых нот
(на самом деле всего-лишь прямоугольного сигнала вместо синусоиды) имеется возможность создания
белого шума, а также возможность случайного выбора нот.&lt;/p&gt;
&lt;p&gt;Интересно, можно ли научить r2d2 говорить [по-человечески]? Пора внести синтезатор речи в TODO-список. :)&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcirciterinfix-compiler-in-sedinfix-compiler-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/infix-compiler-in-sed&quot;&gt;infix-compiler-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Даже будучи &lt;em&gt;текстовым&lt;/em&gt; редактором, sed не предоставляет удобных инструментов для разбора
(синтаксического анализа) контекстно-свободных грамматик. Наиболее простой метод разбора, а именно
рекурсивно-нисходящий анализ, сложен в реализации на sed из-за отсутствия адекватной поддержки
рекурсии. Однако в теории ничто не мешает написать рекурсивно-нисходящий парсер, и даже компилятор,
для какого-нибудь простого языка, например для арифметических формул (с обычной инфиксной нотацией).&lt;/p&gt;
&lt;p&gt;Конкретно этот проект является маленьким (и страшно неэффективным) компилятором формул, принимающим
арифметическое выражение (скажем, &lt;code&gt;(1+2)*3&lt;/code&gt;) и продуцирующим настоящий машинный код ([пока] только для
x86-архитектуры и для 32 битного Linux в качестве ОС). На данный момент, мой скрипт не умеет
генерировать полноценный исполняемый файл (хотя это в принципе и возможно), поэтому для добавления
всех необходимых заголовков я рекомендую воспользоваться
Perl-скриптом &lt;a href=&quot;https://github.com/XlogicX/m2elf&quot;&gt;m2elf.pl&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcirciterbanner-in-sedbanner-in-seda&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/banner-in-sed&quot;&gt;banner-in-sed&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Упрощенный аналог утилит типа &lt;code&gt;banner&lt;/code&gt;/&lt;code&gt;sysvbanner&lt;/code&gt; или &lt;a href=&quot;http://www.figlet.org&quot;&gt;figlet&lt;/a&gt;. Для данной строки печатает
её «ASCII-art» вариант (c большими символами), просто склеивая соответствующие её знакам фрагменты
текста из специально подготовленного «шрифта». Поддерживается автоматическая коррекция межбуквенных
интервалов, т.е. автокернинг (с возможностью наблюдения за  бесполезной, но забавной анимацией
этого процесса).&lt;/p&gt;
&lt;h2 id=&quot;a-hrefhttpsgithubcomcirciterquine-kleene-generatorquine-kleene-generatora&quot;&gt;&lt;a href=&quot;https://github.com/Circiter/quine-kleene-generator&quot;&gt;quine-kleene-generator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Генератор (неэффективных) квайнов для sed. Правда, сам генератор представляет собой набор как
sed-скриптов, так и скриптов оболочки. Для генерации квайнов используется доказательство второй
рекурсивной теоремы Клини о неподвижных точках частично-рекурсивных функций. N.B., квайны
получаются очень большими по размеру, но генератор всё-равно оказался полезен в моих небольших
экспериментах/упражнениях по теории вычислимости.&lt;/p&gt;
&lt;p&gt;Подробности можно найти в серии сообщений &lt;a href=&quot;http://circiter.github.io/quinelogy-part-1&quot;&gt;«Занимательное квайноводство»&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;section-1&quot;&gt;Минирепозитории&lt;/h1&gt;
&lt;p&gt;Кроме этого на &lt;a href=&quot;http://gist.github.com/Circiter/&quot;&gt;http://gist.github.com/Circiter/&lt;/a&gt; хранятся следующие «минирепозитории» (gists):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Circiter/ffa8c2875457c1f45da4c08268e7e076&quot;&gt;sleep-sort.sed&lt;/a&gt; – реализация
алгоритма «спящей сортировки».&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Circiter/09f0866d18e77d487c3308fcfce0be5c&quot;&gt;von-neumann-extractor.sed&lt;/a&gt;
– скрипт преобразует данную &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-4.png&quot; style=&quot;{% style_stub qpcaaa 4 inline %}&quot; class=&quot;latex&quot;&gt;-битную&lt;/span&gt; последовательность в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-5.png&quot; style=&quot;{% style_stub rpcaaa 5 inline %}&quot; class=&quot;latex&quot;&gt;-битную&lt;/span&gt; с выравниванием
частот/количеств единиц и нулей. Скрипт написан по мотивам работы (Von Neumann, Various
techniques used in connection with random digits, 1951).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Circiter/042264eb9e9ee360d0eafa10eedf3f21&quot;&gt;binary-multiplication.sed&lt;/a&gt;
– реализация алгоритма умножения двоичных чисел, написанная по мотивам (и путем упрощения)
кода умножения десятичных чисел, взятого со страницы
&lt;a href=&quot;http://codegolf.stackexchange.com/a/49442&quot;&gt;http://codegolf.stackexchange.com/a/49442&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Пусть &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-6.png&quot; style=&quot;{% style_stub spcaaa 6 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – цифры двоичного представления числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-7.png&quot; style=&quot;{% style_stub tpcaaa 7 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; причём &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-8.png&quot; style=&quot;{% style_stub upcaaa 8 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – младший
бит &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-9.png&quot; style=&quot;{% style_stub vpcaaa 9 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; тогда примерный вид алгоритма для умножения чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-10.png&quot; style=&quot;{% style_stub wpcaaa 10 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-11.png&quot; style=&quot;{% style_stub xpcaaa 11 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет таков:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-12.png&quot; style=&quot;{% style_stub ypcaaa 12 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (инициализация аккумулятора).&lt;/li&gt;
&lt;li&gt;Конец если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-13.png&quot; style=&quot;{% style_stub zpcaaa 13 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; результат лежит в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-14.png&quot; style=&quot;{% style_stub aqcaaa 14 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-15.png&quot; style=&quot;{% style_stub bqcaaa 15 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-16.png&quot; style=&quot;{% style_stub cqcaaa 16 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-17.png&quot; style=&quot;{% style_stub dqcaaa 17 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-18.png&quot; style=&quot;{% style_stub eqcaaa 18 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Перейти к шагу 2.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Алгоритм непосредственно следует из двоичного разложения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-19.png&quot; style=&quot;{% style_stub fqcaaa 19 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Действительно, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-20.png&quot; style=&quot;{% style_stub gqcaaa 20 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-21.png&quot; style=&quot;{% style_stub hqcaaa 21 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
(Операция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-22.png&quot; style=&quot;{% style_stub iqcaaa 22 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на каждой итерации удаляет один самый младший бит числа
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-23.png&quot; style=&quot;{% style_stub jqcaaa 23 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.о. сдвигая двоичную запись числа: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-24.png&quot; style=&quot;{% style_stub kqcaaa 24 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Актуальный код на sed достаточно точно следует этому наброску.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Circiter/46456d2f568f07960a1d9e1c15464c04&quot;&gt;binary-addition.sed&lt;/a&gt; –
реализация алгоритма сложения двоичных чисел, используется в вышеприведенном коде умножения
чисел.&lt;/p&gt;
&lt;p&gt;Если, как и прежде, подразумевается, что числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-25.png&quot; style=&quot;{% style_stub lqcaaa 25 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-26.png&quot; style=&quot;{% style_stub mqcaaa 26 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; я &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-27.png&quot; style=&quot;{% style_stub nqcaaa 27 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; могут быть представлены как
строки цифр &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-28.png&quot; style=&quot;{% style_stub oqcaaa 28 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-29.png&quot; style=&quot;{% style_stub pqcaaa 29 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-30.png&quot; style=&quot;{% style_stub qqcaaa 30 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; соответственно, а нулевые элементы этих
последовательностей суть младшие цифры чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-31.png&quot; style=&quot;{% style_stub rqcaaa 31 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-32.png&quot; style=&quot;{% style_stub sqcaaa 32 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-33.png&quot; style=&quot;{% style_stub tqcaaa 33 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то псевдокод для вычисления
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-34.png&quot; style=&quot;{% style_stub uqcaaa 34 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; может быть таким:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-35.png&quot; style=&quot;{% style_stub vqcaaa 35 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-36.png&quot; style=&quot;{% style_stub wqcaaa 36 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; или &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-37.png&quot; style=&quot;{% style_stub xqcaaa 37 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то конец (ответ находится в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-38.png&quot; style=&quot;{% style_stub yqcaaa 38 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-39.png&quot; style=&quot;{% style_stub zqcaaa 39 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-40.png&quot; style=&quot;{% style_stub arcaaa 40 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-41.png&quot; style=&quot;{% style_stub brcaaa 41 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-42.png&quot; style=&quot;{% style_stub crcaaa 42 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Иначе &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-43.png&quot; style=&quot;{% style_stub drcaaa 43 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-44.png&quot; style=&quot;{% style_stub ercaaa 44 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-45.png&quot; style=&quot;{% style_stub frcaaa 45 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-46.png&quot; style=&quot;{% style_stub grcaaa 46 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Перейти к шагу 2.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;N.B., здесь «цифры» &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-47.png&quot; style=&quot;{% style_stub hrcaaa 47 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – это произвольные неотрицательные целые, необязательно
удовлетворяющие &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-48.png&quot; style=&quot;{% style_stub ircaaa 48 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; также следует учесть, что при модификации одного из представлений,
автоматически обновляется и другое.&lt;/p&gt;
&lt;p&gt;Соответствующий код на sed следует этому плану, за исключением работы со счётчиком &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-49.png&quot; style=&quot;{% style_stub jrcaaa 49 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – для
добавления очередной цифры к результату, эта цифра просто приписывается в начало хранящей его
строки, без какого либо счётчика.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Circiter/8d19dee9ca046ceae534f40e2ec10ff0&quot;&gt;dec-to-bin.sed&lt;/a&gt; – перевод
десятичного числа в двоичную систему счисления.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Circiter/28532a371eeea8d497c53ae81b8d7a80&quot;&gt;dec-to-hex.sed&lt;/a&gt; – основанный на предыдущем скрипте
(&lt;code&gt;dec-to-bin.sed&lt;/code&gt;) код преобразования числа из десятичной системы счисления в шестнадцатиричную. При необходимости
оба примера сравнительно легко обобщаются и на другие системы счисления по основанию 2 (e.g. на восьмиричную).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Circiter/ab4f8538d3882562e38a2e7525acc480&quot;&gt;permutations.sed&lt;/a&gt; – перестановки,
самые обычные перестановки.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Circiter/b4fcf325a0de308771799bbd60208a31&quot;&gt;sushi.sed&lt;/a&gt; – попытка
имитации эффекта «цифровой дождь», популяризованного в одном известном артефакте массовой
культуры (имеется ввиду экранизация Вачовскими эсхатологических мотивов из «откровений
Иоанна» с привлечением идей в двухе лемовских «странных ящиков профессора Конкорана»).&lt;/p&gt;
&lt;p&gt;Выглядит как осыпающийся набор типографских символов (в оригинале, модифицированных японских,
но здесь используется всего-лишь маленькое подмножество ASCII), оставляющих за собой
послесвечение как на старых ЭЛТ-мониторах или осциллографах.&lt;/p&gt;
&lt;p&gt;(В моей апокрифической интерпретации, этот эффект можно рассматривать как дискретизированный
вариант водопадной визуализации временной развертки РЧ-спектра, хорошо известной всем
знакомым с SDR-техникой; в фильме этот инструмент применялся для отладки эмулятора, а также
для «обратной отладки» – не только хакеры, несанкционированно подключившиеся к
эмулятору/симулятору, но и некоторые программы, запущенные в эмуляторе, могли каким-то
образом получать инженерный доступ к его недокументированным функциям и
изучать/модифицировать перехватываемые потоки данных.)&lt;/p&gt;
&lt;p&gt;Скрипт, с гастрономическим названием &lt;code&gt;sushi.sed&lt;/code&gt;, написан в некотором смысле «по-ошибке»,
но пригоден для демонстрации возможности генерации псевдослучайных чисел в редакторе sed (тот
же самый ГПСЧ применён, например, в &lt;a href=&quot;https://github.com/Circiter/sedtris&quot;&gt;модифицированном&lt;/a&gt;
sed-тетрисе или в &lt;a href=&quot;https://github.com/Circiter/r2d2-in-sed&quot;&gt;имитаторе&lt;/a&gt; вокально-речевых
звуков r2d2).&lt;/p&gt;
&lt;p&gt;Реализация с вызовом датчика случайных чисел по необходимости для каждого очередного символа
отрисовываемых треков работает достаточно медленно, поэтому я выложил небольшую
&lt;a href=&quot;https://gist.github.com/Circiter/679cf4686ec0b7070a752fda5b4e6d06&quot;&gt;заплатку&lt;/a&gt;, позволяющую
вычислять некоторое количество случайных чисел заранее, а затем просто брать их из этого
резервуара энтропии по очереди. Такая модификация требует дополнительного времени для запуска
скрипта, но после инициализации работает быстрее (хотя и с ожидаемым снижением качества
случайности). После скачивания обеих файлов, &lt;code&gt;sushi.sed&lt;/code&gt; и &lt;code&gt;sushi.patch&lt;/code&gt;, можно выполнить
следующие команды:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x sushi.sed
&lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;sushi.sed sushi.fast.sed
patch sushi.fast.sed sushi.patch
 ...
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; | ./sushi.fast.sed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Circiter/aadaad1cc3ddce7cf13b333a65b0f78b&quot;&gt;up-n-down.sed&lt;/a&gt; –
экспериментальный способ перемещения вверх и вниз в sed путем матричного транспонирования
буфера редактирования.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Circiter/93281adfd2cdf142da5837d1dec6c770&quot;&gt;transpose.sed&lt;/a&gt; – транспонирование
матрицы.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Circiter/77951d75b6b0e3b4ecc9b689e17863c3&quot;&gt;sliding-window.sed&lt;/a&gt; – другой
подход к перемещению вверх и вниз. Последняя строка матрицы дублируется и используется как референсный
счетчик. От текущей клетки движутся два маркера в противоположных направлениях (вправо и влево),
на каждом шаге декрементируя референсный счётчик. Как только счётчик обнулится, мы можем утверждать,
что один (левый) маркер находится над текущей клеткой (т.е. выше неё), правый – под ней. Далее вокруг
текущей клетки выделяется 8-окрестность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/6-50.png&quot; style=&quot;{% style_stub krcaaa 50 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; окрашивается, отображается. И так для всех клеток с их
последовательным обходом (слева-направо, сверху-вниз).&lt;/p&gt;
&lt;p&gt;Сам я последнее время использую другой подход к вертикальной навигации в sed, основанный на
добавлении маркеров в начало каждой строки с последующим синхронным перемещением всех маркеров
вправо до столкновения одного из них с текущей выбранной клеткой. В этот момент мы можем двигаться
вверх-вниз вдоль маркеров, затем удалить их и начать работать с другой клеткой (счетчик не нужен).
Элементарно.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Nota bene,&lt;/em&gt; я почти всегда пишу на диалекте &lt;a href=&quot;http://www.gnu.org/software/sed&quot;&gt;GNU sed&lt;/a&gt;, что,
увы, создаёт проблемы с использованием моих sed-скриптов на всяких там Mac’ах, BSD’ях и этих
ваших Android’ах. Возможен ли конвертер (может быть даже написанный, о ужас, на самом sed) из
GNU в Posix и смогло ли бы это решить проблему портабельности?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Post scriptum.&lt;/em&gt; Многие из моих sed-сценариев, — ровно как и настоящий список, — носят чисто
развлекательно-экспериментальный характер и перманентно находятся в режиме
написания/дописывания; функциональность может менятся кардинально без предварительных
уведомлений и рациональных обоснований.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;section-2&quot;&gt;Скрипты других авторов.&lt;/h1&gt;
&lt;p&gt;Выше была описана задача трансляции между диалектами sed. Ближайшие по смыслу найденные мною
проекты – &lt;a href=&quot;http://lvogel.free.fr/sed/sedcheck.sed&quot;&gt;sedcheck.sed&lt;/a&gt; за авторством
&lt;a href=&quot;http://lvogel.free.fr&quot;&gt;Laurent Vogel&lt;/a&gt;, проверяющий скрипты на Posix-совместимость;
и транслятор &lt;a href=&quot;https://github.com/lhoursquentin/sed-bin&quot;&gt;sed-bin&lt;/a&gt; от Quentin L’Hours,
конвертирующий sed в C (примечательно, что оба проекта сами являются sed-скриптами).&lt;/p&gt;
&lt;p&gt;Наконец, транслятор &lt;a href=&quot;https://github.com/shinh/elvm&quot;&gt;https://github.com/shinh/elvm&lt;/a&gt; позволяет преобразовать C-код снова в sed. И
хотя сам он и не написан на sed, но может оттранслировать самого себя с C на sed. Поэтому, можно
считать, что sed-bin и elvm совместно могли бы использоваться для «нормализации» sed-скриптов.&lt;/p&gt;
&lt;p&gt;Продолжим обзор мира sed.&lt;/p&gt;
&lt;p&gt;На страницах &lt;a href=&quot;http://sed.sourceforge.net&quot;&gt;http://sed.sourceforge.net&lt;/a&gt; и &lt;a href=&quot;http://sed.sourceforge.net/grabbag&quot;&gt;http://sed.sourceforge.net/grabbag&lt;/a&gt; (автор: Paolo Bonzini)
можно найти неплохую коллекцию sed-скриптов разной степени полезности. Стоить отметить некоторые из
представленных там вещей:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://sed.sourceforge.net/grabbag/scripts/dc.sed&quot;&gt;http://sed.sourceforge.net/grabbag/scripts/dc.sed&lt;/a&gt; – постфиксный калькулятор
(использует обратную польскую нотацию); поддерживает арифметику, корни, перевод
между системами счисления и т.д.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sed.sf.net/grabbag/tutorials/hanoi.htm&quot;&gt;http://sed.sf.net/grabbag/tutorials/hanoi.htm&lt;/a&gt; – &lt;a href=&quot;en.wikipedia.org/wiki/Tower_of_Hanoi&quot;&gt;Ханойские башни&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.oocities.org/mettw/personal/software/src/sedhttpd.txt&quot;&gt;http://www.oocities.org/mettw/personal/software/src/sedhttpd.txt&lt;/a&gt; – http-сервер на sed.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sed.sourceforge.net/grabbag/scripts/turing.sed&quot;&gt;http://sed.sourceforge.net/grabbag/scripts/turing.sed&lt;/a&gt; – машина Тьюринга на sed; да,
это – готовое [конструктивное] доказательство вычислительной универсальности языка sed.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sed.sourceforge.net/grabbag/scripts/sokoban.sed&quot;&gt;http://sed.sourceforge.net/grabbag/scripts/sokoban.sed&lt;/a&gt; – широко известная игра
&lt;span class=&quot;inline&quot;&gt;&lt;img src=&quot;/public/images/sokoban.png&quot; alt=&quot;i18n-sokoban&quot; /&gt;&lt;/span&gt; (сокобан); эта
реализация интересна, разумеется, перемещением персонажа во всех направлениях (в т.ч.
вверх-вниз), чего обычно на sed достичь не так-то просто.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sed.sourceforge.net/grabbag/scripts/bf2c.sed&quot;&gt;http://sed.sourceforge.net/grabbag/scripts/bf2c.sed&lt;/a&gt; – транслятор из, — ну кто
же его не знает, — bf в C. (Т.к. bf является разновидностью универсальной машины Тьюринга,
то такой транслятор тоже является «простым» доказательством Тьюринг-полноты sed.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Так же на просторах интернета были найдены:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/shinh/sedlisp&quot;&gt;sedlisp&lt;/a&gt; – написанный японцем &lt;a href=&quot;https://github.com/shinh&quot;&gt;Shinichiro Hamaji&lt;/a&gt;
интерпретатор небольшого подмножества lisp’а.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mb64/sel&quot;&gt;sel&lt;/a&gt; – аналогичная реализация lisp-интерпретатора на sed,
написанная Mark Barbone.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/stedolan/bf.sed&quot;&gt;bf.sed&lt;/a&gt; – написанный &lt;a href=&quot;http://stedolan.net&quot;&gt;Stephen Dolan&lt;/a&gt;
компилятор bf, генерирующий x86-код, обернутый в готовый к выполнению elf-файл [для Linux].&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bolknote/SedChess&quot;&gt;SedChess&lt;/a&gt; – шахматы, реализованные
&lt;a href=&quot;https://github.com/bolknote&quot;&gt;Евгением Степанищевым&lt;/a&gt; из Казани; больше 1000 строк. Описание
можно найти в &lt;a href=&quot;https://habr.com/ru/post/191006&quot;&gt;habr/191006&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/uuner/sedtris&quot;&gt;sedtris&lt;/a&gt; – реализация игры «тетрис», выполненная
&lt;a href=&quot;https://github.com/uuner&quot;&gt;Юлией Йомантайте&lt;/a&gt; (из Нью-Йорка). У меня есть
&lt;a href=&quot;https://github.com/Circiter/sedtris&quot;&gt;производный репозиторий&lt;/a&gt;, «fork», с небольшим
улучшением (добавлен ГПСЧ на основе клеточного автомата, реализующего «правило 30» по-Вольфраму).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/xsot/99a8a4304660916455ba2c2c774e623a&quot;&gt;https://gist.github.com/xsot/99a8a4304660916455ba2c2c774e623a&lt;/a&gt; – написанная
Wei Heng (aka &lt;a href=&quot;https://github.com/xsot&quot;&gt;xsot&lt;/a&gt;) программа решения лабиринтов (т.е. поиска пути,
в данном случае обходом в ширину).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://laurent.le-brun.eu/pub/path.sed&quot;&gt;http://laurent.le-brun.eu/pub/path.sed&lt;/a&gt; – другая, более минималистичная, реализация обхода
лабиринтов, написанная &lt;a href=&quot;http://laurent.le-brun.eu&quot;&gt;Laurent Le Brun&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://codegolf.stackexchange.com/a/49442&quot;&gt;http://codegolf.stackexchange.com/a/49442&lt;/a&gt; – умножение чисел на sed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MakeNowJust/quine/blob/master/quine.sed&quot;&gt;quine.sed&lt;/a&gt; из
&lt;a href=&quot;https://github.com/MakeNowJust/quine&quot;&gt;«музея квайнов»&lt;/a&gt; – квайн на sed; самостоятельно его
написать &lt;a href=&quot;http://circiter.github.io/quinelogy-part-1&quot;&gt;не так-то и просто&lt;/a&gt;, но у его
&lt;a href=&quot;https://github.com/MakeNowJust&quot;&gt;автора&lt;/a&gt;, Tsuyusato Kitsune (см. &lt;a href=&quot;http://quine.codes/&quot;&gt;http://quine.codes/&lt;/a&gt;),
богатый опыт в квайноводстве (им были написаны квайны для более чем 260 (да, двухсот
шестидесяти [или даже двухсот шестидесяти семи, кажется]) разных языков программирования).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mame/quine-relay&quot;&gt;https://github.com/mame/quine-relay&lt;/a&gt; – «итеративный»
многоязыковой квайн, или цепной квайн (авторы: &lt;a href=&quot;https://github.com/mame&quot;&gt;Yusuke Endoh&lt;/a&gt;, даже
написавший &lt;a href=&quot;http://gihyo.jp/book/2015/978-4-7741-7643-7&quot;&gt;книжку&lt;/a&gt;, на японском, об
эзотерическом программировании вообще и квайнах в частности; и
&lt;a href=&quot;https://twitter.com/hirekoke&quot;&gt;hirekoke&lt;/a&gt;), а именно программа, написанная на одном языке, при
запуске выдающая программу на другом языке, в свою очередь печатающую программу на третьем, и
т.д., пока последняя программа не напечатает снова самую первую. Конкретно этот многоязыковой
квайн, пробегает при своей работе 128 языков (на начало 2020 года), в том числе и sed.&lt;/p&gt;
&lt;p&gt;К сожалению, хотя такие «квайны», на первый взгляд, могут показаться достаточно сложными,
на деле же сложность их написания оказывается несколько меньше сложности обычных, истинных
квайнов. Также не следует путать такие программы с квайнами-полиглотами (квайн-полиглот, или,
как я его кратко называю, поликвайн, является корректной программой одновременно на
нескольких языках) и мультиквайнами (программами, печатающими подобные программы на разных
языках в зависимости от аргументов командной строки, в т.ч. ведущими себя как обычные квайны
будучи запущенными без аргументов).&lt;/p&gt;
&lt;p&gt;(Термины «итеративный/цепной квайн», «поликвайн», «мультиквайн» нельзя назвать
общепринятыми и они используются здесь просто чтобы дать соответствующим понятиям подходящие
имена; официальной квайнологической терминологии, боюсь, пока нет.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jinchizhong/sed-snake&quot;&gt;https://github.com/jinchizhong/sed-snake&lt;/a&gt; – игра
&lt;a href=&quot;https://en.wikipedia.org/wiki/Snake_(video_game_genre)&quot;&gt;«змейка»&lt;/a&gt;;
автор – &lt;a href=&quot;https://github.com/jinchizhong&quot;&gt;Chizhong Jin&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ValeriyKr/sfb&quot;&gt;https://github.com/ValeriyKr/sfb&lt;/a&gt; – sed-реализация игры
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flappy_Bird&quot;&gt;«flappy bird»&lt;/a&gt;; автор – Валерий Киреев.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ValeriyKr/gravity-defied&quot;&gt;https://github.com/ValeriyKr/gravity-defied&lt;/a&gt; – ещё одна sed-игрушка, от
&lt;a href=&quot;https://github.com/Firemoon777&quot;&gt;Вольдемара&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jinchizhong/sed-nqueens&quot;&gt;https://github.com/jinchizhong/sed-nqueens&lt;/a&gt; – классическая
задачка о &lt;a href=&quot;http://en.wikipedia.org/wiki/eight_queens_puzzle&quot;&gt;расстановке нескольких ферзей&lt;/a&gt; на шахматной
доске. Обычно решается с помощью обхода в глубину, что
подразумевает использование рекурсии, поддержки которой
в sed нет (и её как обычно приходится эмулировать с помощью
искусственного &lt;s&gt;интеллекта&lt;/s&gt; стека и команды &lt;code&gt;b&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Решето Эратосфена на sed.</title>
   <link href="http://circiter.tk/sieve-of-eratosthenes-in-sed"/>
   <updated>2022-05-07T02:05:34+00:00</updated>
   <id>http://circiter.tk/sieve-of-eratosthenes-in-sed</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;Введение&lt;/h1&gt;
&lt;p&gt;Иногда в сценариях (скриптах) для поточного редактора sed требуются простые числа. И, учитывая
отсутствие в sed нормальной поддержки арифметики, использование решета Эратосфена &lt;a class=&quot;citation&quot; href=&quot;#wiki-sieve&quot;&gt;[1]&lt;/a&gt; выглядит удачным решением для генерации простых чисел прямо в sed-скрипте.
Поверхностный поиск в поисковых машинах интернета не дал конкретных результатов, поэтому я решил
написать этот скрипт самостоятельно, а в этой заметке рассказать о его работе.&lt;/p&gt;
&lt;p&gt;Скрипт (&lt;code&gt;sieve.sed&lt;/code&gt;) получился довольно компактным, по крайней мере в том смысле, что код печати
результатов занимает лишь немного меньше половины всего исходного текста. Интересно, что на
основе этой реализации решета не составляет труда написать утилиту факторизации чисел (см.
&lt;code&gt;factor.sed&lt;/code&gt;). Фактически, первая версия &lt;code&gt;factor.sed&lt;/code&gt; была получена удалением кода печати
результатов (i.e. удалением почти половины кода, см. выше) и добавлением всего одной
строчки/инструкции в код решета. Она печатала факторы в унарной системе счисления и не
определяла степени найденных простых делителей (т.е., строго говоря, находила не все делители).
Её улучшение потребовало некоторых усилий и привело к некоторому увеличению и дублированию кода
(другими словами, существует потенциал для сокращения объема кода &lt;code&gt;factor.sed&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;(Обсуждаемые скрипты могут быть найдены в &lt;a class=&quot;citation&quot; href=&quot;#sieve-in-sed&quot;&gt;[2]&lt;/a&gt;.)&lt;/p&gt;
&lt;h1 id=&quot;section-1&quot;&gt;Теоретическая основа просеивания&lt;/h1&gt;
&lt;p&gt;Работа решета заключается в итеративном удалении — вычеркивании — составных чисел из
текущего рабочего множества чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-0.png&quot; style=&quot;{% style_stub lrcaaa 0 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; На каждом шаге &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-1.png&quot; style=&quot;{% style_stub mrcaaa 1 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; удаляются все
числа, кратные очередному найденному простому числу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-2.png&quot; style=&quot;{% style_stub nrcaaa 2 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Новым простым числом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-3.png&quot; style=&quot;{% style_stub orcaaa 3 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
становится наименьшее невычеркнутое число, большее &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-4.png&quot; style=&quot;{% style_stub prcaaa 4 inline %}&quot; class=&quot;latex&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-5.png&quot; style=&quot;{% style_stub qrcaaa 5 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-6.png&quot; style=&quot;{% style_stub rrcaaa 6 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Если же &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-7.png&quot; style=&quot;{% style_stub srcaaa 7 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то процесс
завершается, а последнее множество &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-8.png&quot; style=&quot;{% style_stub trcaaa 8 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (N.B., равное &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-9.png&quot; style=&quot;{% style_stub urcaaa 9 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt; становится результатом
его работы.&lt;/p&gt;
&lt;p&gt;В качестве начального приближения выбирается интервал &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-10.png&quot; style=&quot;{% style_stub vrcaaa 10 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для данного &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-11.png&quot; style=&quot;{% style_stub wrcaaa 11 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; — длины
решета, — и полагается &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-12.png&quot; style=&quot;{% style_stub xrcaaa 12 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Более структурированно:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/7-13.png&quot; style=&quot;{% style_stub yrcaaa 13 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Утверждается, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-14.png&quot; style=&quot;{% style_stub zrcaaa 14 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-15.png&quot; style=&quot;{% style_stub ascaaa 15 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – множество
простых чисел.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Набросок доказательства&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Озвученный алгоритм порождает индуктивное доказательство.&lt;/p&gt;
&lt;p&gt;База: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-16.png&quot; style=&quot;{% style_stub bscaaa 16 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Предположение индукции: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-17.png&quot; style=&quot;{% style_stub cscaaa 17 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-18.png&quot; style=&quot;{% style_stub dscaaa 18 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Эта рекуррентная формула своим следствием имеет &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/7-19.png&quot; style=&quot;{% style_stub escaaa 19 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Шаг индукции: необходимо показать, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-20.png&quot; style=&quot;{% style_stub fscaaa 20 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – следующее простое число. Итак, допустим мы
выбрали &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-21.png&quot; style=&quot;{% style_stub gscaaa 21 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Факторизуем его, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-22.png&quot; style=&quot;{% style_stub hscaaa 22 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-23.png&quot; style=&quot;{% style_stub iscaaa 23 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Формула (1) говорит, что числа, кратные простым &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-24.png&quot; style=&quot;{% style_stub jscaaa 24 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; уже
удалены из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-25.png&quot; style=&quot;{% style_stub kscaaa 25 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а значит и из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-26.png&quot; style=&quot;{% style_stub lscaaa 26 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; поэтому &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-27.png&quot; style=&quot;{% style_stub mscaaa 27 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(Имеется в виду, что для некоторого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-28.png&quot; style=&quot;{% style_stub nscaaa 28 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-29.png&quot; style=&quot;{% style_stub oscaaa 29 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно вынести за знак произведения:
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-30.png&quot; style=&quot;{% style_stub pscaaa 30 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; и именно поэтому &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-31.png&quot; style=&quot;{% style_stub qscaaa 31 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не может быть меньше или равен &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-32.png&quot; style=&quot;{% style_stub rscaaa 32 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; –
такие кратные уже вычеркнуты; если же &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-33.png&quot; style=&quot;{% style_stub sscaaa 33 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; есть единственный множитель, то тем более он
должен быть больше &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-34.png&quot; style=&quot;{% style_stub tscaaa 34 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – по определению множества &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-35.png&quot; style=&quot;{% style_stub uscaaa 35 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; по которому и берется
минимум для нахождения разлагаемого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-36.png&quot; style=&quot;{% style_stub vscaaa 36 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Также понятно, что множители &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-37.png&quot; style=&quot;{% style_stub wscaaa 37 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не превышают самого числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-38.png&quot; style=&quot;{% style_stub xscaaa 38 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-39.png&quot; style=&quot;{% style_stub yscaaa 39 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Конкретно, из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-40.png&quot; style=&quot;{% style_stub zscaaa 40 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и нефакторизуемости &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-41.png&quot; style=&quot;{% style_stub atcaaa 41 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; следует, что
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-42.png&quot; style=&quot;{% style_stub btcaaa 42 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (i.e., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-43.png&quot; style=&quot;{% style_stub ctcaaa 43 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; никогда не вычеркивалось и не будет вычеркиваться). А из
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-44.png&quot; style=&quot;{% style_stub dtcaaa 44 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; следует, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-45.png&quot; style=&quot;{% style_stub etcaaa 45 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; При этом, если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-46.png&quot; style=&quot;{% style_stub ftcaaa 46 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (а не
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-47.png&quot; style=&quot;{% style_stub gtcaaa 47 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; то это противоречит минимальности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-48.png&quot; style=&quot;{% style_stub htcaaa 48 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Значит, от противного, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-49.png&quot; style=&quot;{% style_stub itcaaa 49 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.е. &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-50.png&quot; style=&quot;{% style_stub jtcaaa 50 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и других простых между
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-51.png&quot; style=&quot;{% style_stub ktcaaa 51 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-52.png&quot; style=&quot;{% style_stub ltcaaa 52 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; нет (иначе они не были бы вычеркнуты на предыдущих шагах и входили бы в
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-53.png&quot; style=&quot;{% style_stub mtcaaa 53 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; что опять противоречило бы минимальности &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-54.png&quot; style=&quot;{% style_stub ntcaaa 54 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-55.png&quot; style=&quot;{% style_stub otcaaa 55 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-56.png&quot; style=&quot;{% style_stub ptcaaa 56 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;section-2&quot;&gt;Реализация&lt;/h1&gt;
&lt;h2 id=&quot;codesievesedcode&quot;&gt;Принцип работы &lt;code&gt;sieve.sed&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Общий пошаговый вид алгоритма:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Чтение длины решета (конвертация десятичного числа в унарное).&lt;/li&gt;
&lt;li&gt;Просеивание бинарной строки, полученной на основе унарного числа из предыдущего шага.
&lt;ul&gt;
&lt;li&gt;Поиск следующего простого, т.е. первой ближайшей единицы, лежащей правее текущего простого.&lt;/li&gt;
&lt;li&gt;Вычеркивание чисел, кратных найденному простому; под вычеркиванием понимается изменение 1 на
0 в соответствующих позициях решета.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Печать решета.
&lt;ul&gt;
&lt;li&gt;Решето проходится слева-направо.&lt;/li&gt;
&lt;li&gt;На каждом шаге инкрементируется счетчик (изначально обнулённый).&lt;/li&gt;
&lt;li&gt;Если в текущей позиции решета записана единица, то значание счётчика выводится на экран.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Возможно есть смысл немного детализировать работу решета на этапе поиска следующего простого
числа. Сначала перед решетом приписывается маркер &lt;code&gt;#&lt;/code&gt;. Далее, в уже частично заполненном решете
отыскивается первая единица, лежащая правее маркера &lt;code&gt;#&lt;/code&gt;, после чего этот маркер перемещается на
позицию сразу после этой единицы. Длина части решета, лежащей левее маркера есть новое простое
число. Этот префикс копируется на следующую строчку и может считаться записью найденного
простого числа в унарной системе счисления.&lt;/p&gt;
&lt;p&gt;После символа &lt;code&gt;#&lt;/code&gt; добавляется вспомогательный маркер &lt;code&gt;@&lt;/code&gt;, а в начало следующей строки – маркер
&lt;code&gt;:&lt;/code&gt;, после чего оба маркера начинают сдвигаться вправо на один символ за раз. Если маркер &lt;code&gt;:&lt;/code&gt;
оказывается в конце второй строки, а &lt;code&gt;@&lt;/code&gt; ещё не дошёл до конца первой, то маркер &lt;code&gt;@&lt;/code&gt; с
необходимостью оказывается сразу после следующего составного числа и мы можем записать в эту
позицию ноль, независимо от значения, которое было там ранее. Теперь маркер &lt;code&gt;:&lt;/code&gt; возвращается в
начало второй строки.&lt;/p&gt;
&lt;p&gt;Процесс перемещения маркеров &lt;code&gt;@&lt;/code&gt; и &lt;code&gt;:&lt;/code&gt; продолжается до вычеркивания всех множителей текущего
простого числа (i.e., пока &lt;code&gt;@&lt;/code&gt; не дойдёт до конца первой строки), после чего эти маркеры
удаляются и описанный процесс повторяется.&lt;/p&gt;
&lt;h2 id=&quot;codefactorsedcode&quot;&gt;Принцип работы &lt;code&gt;factor.sed&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Этот скрипт написан на основе вышеописанного &lt;code&gt;sieve.sed&lt;/code&gt;, но код обнаружения нового
простого числа слегка модифицирован, а после него добавлен код определения показателя степени
для найденного простого множителя.&lt;/p&gt;
&lt;p&gt;Число, подлежащее факторизации используется просто в качестве длины решета. Понятно, что
простые, входящие в этого решето (и только они) будут входить в разложение данного числа на
простые множители.&lt;/p&gt;
&lt;p&gt;Поиск следующего простого отличается от аналогичного кода в скрипте &lt;code&gt;sieve.sed&lt;/code&gt; фактически лишь
тем, что при обнаружении простого числа обнуляется отдельный счетчик, а при вычеркивании каждого
составного числа этот счётчик инкрементируется. Очевидно, что после вычеркивания всех множителей
текущего простого числа (не выходящих за пределы решета, естественно) значение счётчика будет
равно целой части результата деления исходного факторизуемого числа на текущий простой
множитель.&lt;/p&gt;
&lt;p&gt;Далее мы должны просто продолжать делить значение этого счётчика на текущее простое число, пока
счётчик не обнулится. Причём после каждой операции деления мы снова переходим к коду,
выполненному после обнаружения текущего простого числа (т.е. мы печатаем тоже самое простое
число ещё раз, делим счётчик на это простое и т.д.).&lt;/p&gt;
&lt;p&gt;В результате, скрипт печатает текущий простой множитель нужное количество раз, а после печати
всех простых множителей, мы получаем полное разложение исходного числа, равного длине решета.&lt;/p&gt;
&lt;h1 id=&quot;section-3&quot;&gt;Больше эзотерики&lt;/h1&gt;
&lt;p&gt;Также были написаны два демонстрационных скрипта, &lt;code&gt;anagram.sed&lt;/code&gt; и &lt;code&gt;collatz.sed&lt;/code&gt;, использующих
простые числа и факторизацию для решения задач, в которых в явном виде простые числа обычно не
применяют. Первый скрипт (вместо которого, естественно, гораздо эффективнее было бы использовать
композицию сортировки символов в строках и сравнения результирующих строк-последовательностей)
реализует идею из &lt;a class=&quot;citation&quot; href=&quot;#anagrams-alg&quot;&gt;[3,4]&lt;/a&gt; и эксплуатирует основную теорему
арифметики &lt;a class=&quot;citation&quot; href=&quot;#wiki-fta&quot;&gt;[5]&lt;/a&gt; для детектирования анаграмм, т.е. для определения, являются ли
две данные строки-последовательности перестановками друг-друга. Каждому символу
последовательностей сопоставляется единственным образом некоторое простое число, после чего все
эти числа, соответствующие символам из конкретной строки, перемножаются. Основная теорема
арифметики вместе с коммутативностью умножения гарантируют, что анаграммы будут давать
одинаковые произведения-сигнатуры.&lt;/p&gt;
&lt;p&gt;Ранее написанный алгоритм просеивания был модифицирован/упрощён для работы только с двоичными
числами. Для умножения двоичных чисел я использовал код из gist’а &lt;a class=&quot;citation&quot; href=&quot;#gist-mult&quot;&gt;[6]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Второй скрипт, &lt;code&gt;collatz.sed&lt;/code&gt;, реализует известную динамическую систему из гипотезы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-57.png&quot; style=&quot;{% style_stub qtcaaa 57 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (см.
&lt;a class=&quot;citation&quot; href=&quot;#wiki-collatz&quot;&gt;[7,8]&lt;/a&gt;), но вместо привычных операций &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-58.png&quot; style=&quot;{% style_stub rtcaaa 58 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-59.png&quot; style=&quot;{% style_stub stcaaa 59 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; используются
манипуляции с простыми числами, на мой взгляд лучше показывающие истинную теоретико-числовую
суть гипотезы Коллатца.&lt;/p&gt;
&lt;p&gt;Пусть дана функция &lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/7-60.png&quot; style=&quot;{% style_stub ttcaaa 60 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Гипотеза Коллатца утверждает, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-61.png&quot; style=&quot;{% style_stub utcaaa 61 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Более точно, похоже, что для всех натуральных &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-62.png&quot; style=&quot;{% style_stub vtcaaa 62 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; итерации &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-63.png&quot; style=&quot;{% style_stub wtcaaa 63 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; сходятся к циклу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-64.png&quot; style=&quot;{% style_stub xtcaaa 64 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Если при каждом применении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-65.png&quot; style=&quot;{% style_stub ytcaaa 65 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; сначала производить разложение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-66.png&quot; style=&quot;{% style_stub ztcaaa 66 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на простые множители, то
деление на два будет сводится к вычеркиванию двойки (на деле, можно заодно вычеркивать все
двойки сразу) из факторизации. Операция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-67.png&quot; style=&quot;{% style_stub aucaaa 67 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет соответствовать приписыванию тройки,
перемножению оставшихся факторов и прибавлению единицы к результату.&lt;/p&gt;
&lt;p&gt;Прибавление единицы гарантирует, что результат не будет делиться на всё, на что делилось число
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-68.png&quot; style=&quot;{% style_stub bucaaa 68 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; или, другими словами, в факторизации результата операции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-69.png&quot; style=&quot;{% style_stub cucaaa 69 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будут задействованы совсем
другие множители, ни одного из которых не было в факторизации &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-70.png&quot; style=&quot;{% style_stub ducaaa 70 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; с использованием наибольшего
общего делителя, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-71.png&quot; style=&quot;{% style_stub eucaaa 71 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Добавление же тройки гарантирует, что в
разложении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-72.png&quot; style=&quot;{% style_stub fucaaa 72 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; никаких троек тоже не будет, даже если их и не было в разложении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-73.png&quot; style=&quot;{% style_stub gucaaa 73 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
изначально.&lt;/p&gt;
&lt;p&gt;Если достаточно разнообразных множителей для формирования &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-74.png&quot; style=&quot;{% style_stub hucaaa 74 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не найдется, это будет
означать, что после вычеркивания двоек у нас останется пустая факторизация, т.е. результат
превратится в единицу.&lt;/p&gt;
&lt;p&gt;(Фактически, мы имеем дело с гонкой двух процессов – процессом «генерации» простых чисел,
скажем, решетом, и процессом их «потребления» за счёт прибавления единицы; судя по
экспериментам, процесс потребления работает быстрее – в какой-то момент, независимо от
стартового значения, новых простых не оказывается в наличии и итерации сходятся к уже
упоминавшемуся циклу &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-75.png&quot; style=&quot;{% style_stub iucaaa 75 inline %}&quot; class=&quot;latex&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Гипотеза &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-76.png&quot; style=&quot;{% style_stub jucaaa 76 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; по праву относится к классу задач, многими называемыми «математическими
болезнями»; в таких задачах сочетается предельная простота формулировки условия с неподдающейся
многим математикам сложностью решения, а в данном случае, по всей видимости, вообще с полной
неготовностью современной математики к доказательству этой гипотезы.&lt;/p&gt;
&lt;h1 id=&quot;section-4&quot;&gt;Об оптимизации&lt;/h1&gt;
&lt;p&gt;В этом сообщении и в предложенных скриптах вообще не применяются распространённые оптимизации
решета Эратосфена. Но для полноты картины, наверное стоит упомянуть возможные направления для
улучшения. Во-первых, можно ограничиться рассмотрением только чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-77.png&quot; style=&quot;{% style_stub kucaaa 77 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; таких, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-78.png&quot; style=&quot;{% style_stub lucaaa 78 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; для некоторого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-79.png&quot; style=&quot;{% style_stub mucaaa 79 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt;
e.g., при &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-80.png&quot; style=&quot;{% style_stub nucaaa 80 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; это соответствует игнорированию всех чётных чисел, больших двух, всегда
по-определению являющихся составными.&lt;/p&gt;
&lt;p&gt;Во-вторых, перебор кратных для нечётных простых чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-81.png&quot; style=&quot;{% style_stub oucaaa 81 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно вести с шагом &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-82.png&quot; style=&quot;{% style_stub pucaaa 82 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а не &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-83.png&quot; style=&quot;{% style_stub qucaaa 83 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt;
при использовании вышеописанного обобщения на случай чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-84.png&quot; style=&quot;{% style_stub rucaaa 84 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; взаимно простых с несколькими
первыми простыми числами [не превышающими &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-85.png&quot; style=&quot;{% style_stub sucaaa 85 inline %}&quot; class=&quot;latex&quot;&gt;],&lt;/span&gt; можно генерировать кратные так, чтобы они
тоже были взаимно простыми с числами из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-86.png&quot; style=&quot;{% style_stub tucaaa 86 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; См. также &lt;a class=&quot;citation&quot; href=&quot;#wiki-wheel&quot;&gt;[9]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В-третьих, процесс вычеркивания чисел, кратных очередному найденному простому &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-87.png&quot; style=&quot;{% style_stub uucaaa 87 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; можно
начинать сразу с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-88.png&quot; style=&quot;{% style_stub vucaaa 88 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а не с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-89.png&quot; style=&quot;{% style_stub wucaaa 89 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; как следствие, не имеет смысла продолжать вычеркивание
кратных если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-90.png&quot; style=&quot;{% style_stub xucaaa 90 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Т.е., множители для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-91.png&quot; style=&quot;{% style_stub yucaaa 91 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; использующиеся при вычеркивании составных чисел,
образуют множество &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-92.png&quot; style=&quot;{% style_stub zucaaa 92 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (максимум здесь выбран так, чтобы после
умножения на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-93.png&quot; style=&quot;{% style_stub avcaaa 93 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; получилось &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-94.png&quot; style=&quot;{% style_stub bvcaaa 94 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; а минимум соответствует началу
вычеркивания с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-95.png&quot; style=&quot;{% style_stub cvcaaa 95 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(Естественно, желающие могут попробовать добавить эти оптимизации в обсуждаемый скрипт, хотя с
квадратами в sed, наверное, лучше не связываться).&lt;/p&gt;
&lt;h2 id=&quot;section-5&quot;&gt;Решето Эйлера&lt;/h2&gt;
&lt;p&gt;Решето Эратосфена может вычеркивать одни и те же числа по нескольку раз. Эйлер придумал (для
решаемой им в тот момент вполне практической математической задачи) модификацию &lt;a class=&quot;citation&quot; href=&quot;#euler1737&quot;&gt;[10]&lt;/a&gt; решета, позволяющую вычеркивать составные числа только один раз. Алгоритм можно
описать так:
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/7-96.png&quot; style=&quot;{% style_stub dvcaaa 96 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Здесь &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-97.png&quot; style=&quot;{% style_stub evcaaa 97 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; является длиной решета (как и в ранее описанном алгоритме для решета Эратосфена).
Сгенерированные простые числа коллекционируются в множестве &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-98.png&quot; style=&quot;{% style_stub fvcaaa 98 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; которое и возвращается
при завершении работы алгоритма.&lt;/p&gt;
&lt;p&gt;Все операции производятся с рабочим множеством чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-99.png&quot; style=&quot;{% style_stub gvcaaa 99 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; изначально равным отрезку &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-100.png&quot; style=&quot;{% style_stub hvcaaa 100 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; На
каждой итерации выбирается минимальный элемент &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-101.png&quot; style=&quot;{% style_stub ivcaaa 101 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; этого множества и объявляется следующим
простым числом (сразу же сохраняемым в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-102.png&quot; style=&quot;{% style_stub jvcaaa 102 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; при текущем значении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-103.png&quot; style=&quot;{% style_stub kvcaaa 103 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; после чего формируется
новое множество произведений &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-104.png&quot; style=&quot;{% style_stub lvcaaa 104 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е., числа кратные &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-105.png&quot; style=&quot;{% style_stub mvcaaa 105 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; но ещё не
ни разу не вычеркнутые, помечаются для последующего удаления. После этого, помеченные числа
удаляются из рабочего множества с помощью теоретико-множественной операции вычитания &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-106.png&quot; style=&quot;{% style_stub nvcaaa 106 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Ставший теперь ненужным элемент &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-107.png&quot; style=&quot;{% style_stub ovcaaa 107 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; до сих пор остававшийся в множестве &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-108.png&quot; style=&quot;{% style_stub pvcaaa 108 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
(т.к. до этого, при формировании вспомогательного множества помеченных чисел &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-109.png&quot; style=&quot;{% style_stub qvcaaa 109 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; умножался как
минимум на 2), удаляется из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-110.png&quot; style=&quot;{% style_stub rvcaaa 110 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; И если это множество стало пустым, то алгоритм завершается, в
противном же случае инкрементируется счётчик итераций &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-111.png&quot; style=&quot;{% style_stub svcaaa 111 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и процесс повторяется (с поиска нового
минимального элемента &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-112.png&quot; style=&quot;{% style_stub tvcaaa 112 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Несмотря на некоторые внешние различия, суть этого алгоритма всё та же: для каждого очередного
простого числа из решета удаляются/вычеркиваются все числа, кратные ему, в результате чего
следующее невычеркнутое число тоже оказывается простым. Итерирование этих манипуляций приводит к
«просеиванию» исходного набора чисел и к удалению всех составных чисел (в решете Эйлера, в
отличии от оригинального решета Эратосфена, простые числа тоже удаляются из рабочего множества,
но по мере их обнаружения они накапливаются в другом множестве или, скажем, выводятся на
печать).&lt;/p&gt;
&lt;p&gt;Важно, что элементы, помечаемые для удаления (т.е. добавляемые в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-113.png&quot; style=&quot;{% style_stub uvcaaa 113 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; по прежнему участвуют в
процессе пополнения множества &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-114.png&quot; style=&quot;{% style_stub vvcaaa 114 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(Нижеследующий материал написан по мотивам &lt;a class=&quot;citation&quot; href=&quot;#sorenson1990&quot;&gt;[11]&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;Чем же обеспечивается главное свойство решета Эйлера, т.е. почему в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-115.png&quot; style=&quot;{% style_stub wvcaaa 115 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; никогда не попадают уже
удаленные из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-116.png&quot; style=&quot;{% style_stub xvcaaa 116 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; числа? Если в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-117.png&quot; style=&quot;{% style_stub yvcaaa 117 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; попало число, большее &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-118.png&quot; style=&quot;{% style_stub zvcaaa 118 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то оно, очевидно, не может быть
удалено повторно из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-119.png&quot; style=&quot;{% style_stub awcaaa 119 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; так как там таких больших чисел просто не было изначально: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-120.png&quot; style=&quot;{% style_stub bwcaaa 120 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; по построению. Если же &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-121.png&quot; style=&quot;{% style_stub cwcaaa 121 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не превышает &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-122.png&quot; style=&quot;{% style_stub dwcaaa 122 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то исходя из смысла
присваивания &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-123.png&quot; style=&quot;{% style_stub ewcaaa 123 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (см. шаг 4 вышеприведенного алгоритма), &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-124.png&quot; style=&quot;{% style_stub fwcaaa 124 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-125.png&quot; style=&quot;{% style_stub gwcaaa 125 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Суть в том, что любое натуральное число &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-126.png&quot; style=&quot;{% style_stub hwcaaa 126 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; можно единственным образом представить в виде
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-127.png&quot; style=&quot;{% style_stub iwcaaa 127 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-128.png&quot; style=&quot;{% style_stub jwcaaa 128 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – наименьший простой делитель (фактор) числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-129.png&quot; style=&quot;{% style_stub kwcaaa 129 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; При этом среди факторов числа
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-130.png&quot; style=&quot;{% style_stub lwcaaa 130 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; очевидно, не будет чисел, меньших &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-131.png&quot; style=&quot;{% style_stub mwcaaa 131 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (Т.е. мы просто «отсоединяем» наименьший фактор
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-132.png&quot; style=&quot;{% style_stub nwcaaa 132 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; от &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-133.png&quot; style=&quot;{% style_stub owcaaa 133 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и формируем разложение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-134.png&quot; style=&quot;{% style_stub pwcaaa 134 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; полагая &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-135.png&quot; style=&quot;{% style_stub qwcaaa 135 inline %}&quot; class=&quot;latex&quot;&gt;;&lt;/span&gt; тогда из основной теоремы арифметики
&lt;a class=&quot;citation&quot; href=&quot;#wiki-fta&quot;&gt;[5]&lt;/a&gt;, т.е. из единственности факторизации, как раз и следует единственность
требуемого разложения &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-136.png&quot; style=&quot;{% style_stub rwcaaa 136 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Применительно к решету, это означает, что для текущего найденного простого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-137.png&quot; style=&quot;{% style_stub swcaaa 137 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; множество
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-138.png&quot; style=&quot;{% style_stub twcaaa 138 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; множителей, при перемножении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-139.png&quot; style=&quot;{% style_stub uwcaaa 139 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на которые будут получаться новые составные
числа, подлежащие вычеркиванию, равно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-140.png&quot; style=&quot;{% style_stub vwcaaa 140 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Покажем, что такое определение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-141.png&quot; style=&quot;{% style_stub wwcaaa 141 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; совпадает с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-142.png&quot; style=&quot;{% style_stub xwcaaa 142 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из алгоритма (см. выше). На
каждой итерации, если &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-143.png&quot; style=&quot;{% style_stub ywcaaa 143 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-144.png&quot; style=&quot;{% style_stub zwcaaa 144 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. все числа из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-145.png&quot; style=&quot;{% style_stub axcaaa 145 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; большие чем &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-146.png&quot; style=&quot;{% style_stub bxcaaa 146 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; не делятся на простые меньшие &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-147.png&quot; style=&quot;{% style_stub cxcaaa 147 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; ведь
составные числа, делящиеся на &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-148.png&quot; style=&quot;{% style_stub dxcaaa 148 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; уже были вычеркнуты на предыдущих итерациях алгоритма.
(Здесь идет речь об &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-149.png&quot; style=&quot;{% style_stub excaaa 149 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; до шага 5, т.е. до операции &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-150.png&quot; style=&quot;{% style_stub fxcaaa 150 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Т.о., &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-151.png&quot; style=&quot;{% style_stub gxcaaa 151 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; содержит числа из промежутка &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-152.png&quot; style=&quot;{% style_stub hxcaaa 152 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; не делящиеся на простые, меньшие &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-153.png&quot; style=&quot;{% style_stub ixcaaa 153 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е.
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-154.png&quot; style=&quot;{% style_stub jxcaaa 154 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Это совпадает с
выражением для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-155.png&quot; style=&quot;{% style_stub kxcaaa 155 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Осталось показать, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-156.png&quot; style=&quot;{% style_stub lxcaaa 156 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е., что подлежащие
вычеркиванию числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-157.png&quot; style=&quot;{% style_stub mxcaaa 157 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; уже присутствуют в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-158.png&quot; style=&quot;{% style_stub nxcaaa 158 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (либо просто выходят за пределы решета) и их не
придётся вычеркивать повторно. Как мы уже выяснили, каждый такой &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-159.png&quot; style=&quot;{% style_stub oxcaaa 159 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; для некоторого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-160.png&quot; style=&quot;{% style_stub pxcaaa 160 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; единственен и так как на всех предыдущих итерациях алгоритма мы удаляли лишь
числа, наименьший фактор которых был меньше &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-161.png&quot; style=&quot;{% style_stub qxcaaa 161 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то из &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-162.png&quot; style=&quot;{% style_stub rxcaaa 162 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и начального приближения
для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-163.png&quot; style=&quot;{% style_stub sxcaaa 163 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; равного &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-164.png&quot; style=&quot;{% style_stub txcaaa 164 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; как раз и следует, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-165.png&quot; style=&quot;{% style_stub uxcaaa 165 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;За более подробной информацией о решете Эйлера следует обратиться, e.g., к &lt;a class=&quot;citation&quot; href=&quot;#wiki-sieve&quot;&gt;[1,12,11]&lt;/a&gt; . Интересно, что в некоторых работах, например, в той же &lt;a class=&quot;citation&quot; href=&quot;#gries-misra&quot;&gt;[12]&lt;/a&gt;, прямые отсылы к Эйлеру отсутствуют, поэтому иногда говорят, что это решето
неоднократно переизобреталось различными авторами.&lt;/p&gt;
&lt;p&gt;Возможно, что причиной этого библиографического казуса является некоторая неявность введения
решета в работе Эйлера. Эйлер игрался с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-166.png&quot; style=&quot;{% style_stub vxcaaa 166 inline %}&quot; class=&quot;latex&quot;&gt;-функцией&lt;/span&gt; Римана, разлагающейся в ряд Дирихле
&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/eq/7-167.png&quot; style=&quot;{% style_stub wxcaaa 167 block %}&quot; class=&quot;latex&quot;&gt;&lt;/center&gt;&lt;br&gt; для &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-168.png&quot; style=&quot;{% style_stub xxcaaa 168 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Для доказательства важного
тождества &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-169.png&quot; style=&quot;{% style_stub yxcaaa 169 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; Эйлер строил последовательность
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-170.png&quot; style=&quot;{% style_stub zxcaaa 170 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; начиная с &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-171.png&quot; style=&quot;{% style_stub aycaaa 171 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Здесь &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-172.png&quot; style=&quot;{% style_stub bycaaa 172 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; – такое множество, что &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-173.png&quot; style=&quot;{% style_stub cycaaa 173 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Сначала, естественно, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-174.png&quot; style=&quot;{% style_stub dycaaa 174 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; и поэтому &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-175.png&quot; style=&quot;{% style_stub eycaaa 175 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равен 2,
т.е. первому простому числу. Умножение &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-176.png&quot; style=&quot;{% style_stub fycaaa 176 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; на сумму &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-177.png&quot; style=&quot;{% style_stub gycaaa 177 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; равную &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-178.png&quot; style=&quot;{% style_stub hycaaa 178 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; даёт новую
сумму, в которой все основания кратны двум. Соответственно, вычитание &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-179.png&quot; style=&quot;{% style_stub iycaaa 179 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
обнулит в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-180.png&quot; style=&quot;{% style_stub jycaaa 180 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; такие слагаемые (в данном случае, с чётными основаниями степеней). Если
построить для только что полученной суммы &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-181.png&quot; style=&quot;{% style_stub kycaaa 181 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; множество оснований &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-182.png&quot; style=&quot;{% style_stub lycaaa 182 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; то окажется, что
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-183.png&quot; style=&quot;{% style_stub mycaaa 183 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равно трём – второму простому числу. Продолжая этот процесс мы
будем на каждом шаге получать новое простое число и использовать его для обнуления/вычеркивания
слагаемых с основаниями, кратными ему, фактически, воспроизводя просеивание Эратосфена/Эйлера
без повторных вычеркиваний. (Кстати, нетрудно видеть, что здесь множество &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-184.png&quot; style=&quot;{% style_stub nycaaa 184 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; почти полностью
соответствует множеству &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-185.png&quot; style=&quot;{% style_stub oycaaa 185 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; из разобранного ранее алгоритма решета Эйлера; разве что в &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-186.png&quot; style=&quot;{% style_stub pycaaa 186 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
есть лишняя единица…)&lt;/p&gt;
&lt;h2 id=&quot;section-6&quot;&gt;Даёт ли решето Эйлера ускорение?&lt;/h2&gt;
&lt;p&gt;При работе решета Эратосфена требуется вычеркнуть числа, кратные всем простым &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-187.png&quot; style=&quot;{% style_stub qycaaa 187 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;
Для каждого &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-188.png&quot; style=&quot;{% style_stub rycaaa 188 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; очевидно, требуется &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-189.png&quot; style=&quot;{% style_stub sycaaa 189 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; вычеркиваний. Т.о. для оценки количества
требуемых операций нужно просуммировать это выражение по всем простым, не превышающим &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-190.png&quot; style=&quot;{% style_stub tycaaa 190 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е.
общее количество операций равно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-191.png&quot; style=&quot;{% style_stub uycaaa 191 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Известно, что
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-192.png&quot; style=&quot;{% style_stub vycaaa 192 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Таким образом,
временна́я асимптотическая сложность решета Эратосфена оценивается как
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-193.png&quot; style=&quot;{% style_stub wycaaa 193 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-194.png&quot; style=&quot;{% style_stub xycaaa 194 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; выполняет роль среднего количества
различных делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-195.png&quot; style=&quot;{% style_stub yycaaa 195 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; (N.B., за &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-196.png&quot; style=&quot;{% style_stub zycaaa 196 inline %}&quot; class=&quot;latex&quot;&gt;-нотацией&lt;/span&gt; ещё прячется слагаемое
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-197.png&quot; style=&quot;{% style_stub azcaaa 197 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. время, требуемое на инициализацию решета построением множества &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-198.png&quot; style=&quot;{% style_stub bzcaaa 198 inline %}&quot; class=&quot;latex&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Эта асимптотическая оценка становится линейной (если вычеркивание очередного числа выполняется
за константное &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-199.png&quot; style=&quot;{% style_stub czcaaa 199 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; время) в случае решета Эйлера. Для языка программирования с
дешёвым умножением это позволяет работать решету Эйлера быстрее (в теории): &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-200.png&quot; style=&quot;{% style_stub dzcaaa 200 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt;
против &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-201.png&quot; style=&quot;{% style_stub ezcaaa 201 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Но sed, очевидно, не относится к таким языкам – в нём вообще нет понятия умножения, хотя
универсальность sed и позволяет реализовать умножение низкоуровневыми средствами. Причем,
выбранный для рассматриваемой здесь реализации решета Эйлера способ умножения в унарной системе
счисления, полностью нивелирует какие бы то ни было преимущества этого варианта решета.&lt;/p&gt;
&lt;p&gt;Фактически, поличившийся код работает даже медленнее чем исходное решето Эратосфена или его
наивная «эйлерофикация» заменой &lt;code&gt;s/1@/0@/&lt;/code&gt; на &lt;code&gt;/1@/ s/1@/0@/&lt;/code&gt;. :) Но раз он всё-таки был
написан, то я включил файл &lt;code&gt;euler-sieve.sed&lt;/code&gt; в основной репозиторий &lt;a class=&quot;citation&quot; href=&quot;#sieve-in-sed&quot;&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Решето Эйлера могло бы быть полезным в гипотетическом случае просеивания чисел, находящихся не в
оперативной памяти, а на носителе типа flash-микросхем, имеющем ограничение на количество
операций перезаписи содержимого. Кроме этого, можно вообразить ситуацию с просеиванием чисел в
удалённой базе данных: в этом случае решето Эйлера позволяет минимизировать как восходящий (для
отправки команд записи/вычеркивания), так и нисходящий (для считывания содержимого ячеек решета)
сетевой трафик. Наконец, при теоретико-игровой интерпретации, это решето сгодилось бы при [даже
ещё более гипотетической] игре типа «морской бой», в которой состояние поля-решета
замаскировано «туманом войны» и можно получать лишь прореженные сведения о последнем найденном
простом числе. При этом нельзя попадать в «своих» (в простые числа) или тратить «боеприпасы»
и время впустую в попытках вычеркивания уже вычеркнутых чисел.&lt;/p&gt;
&lt;p&gt;Похоже, что у решета Эйлера в реальности два применения – ускорение генерации простых чисел при
использовании подходящих языков программирования типа C, и применение теоретическое (для чего,
собственно, Эйлер и придумал это решето &lt;a class=&quot;citation&quot; href=&quot;#euler1737&quot;&gt;[10]&lt;/a&gt;), e.g. в задачах, требующих
единственности каждого генерируемого решетом составного числа.&lt;/p&gt;
&lt;h3 id=&quot;codeeuler-sievesedcode&quot;&gt;Принцип работы &lt;code&gt;euler-sieve.sed&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Скрипт &lt;code&gt;euler-sieve.sed&lt;/code&gt; получен из &lt;code&gt;sieve.sed&lt;/code&gt; исправлением нескольких строчек. Набор
вспомогательных маркеров был расширен с &lt;code&gt;#@:&lt;/code&gt; до &lt;code&gt;#_@:,&lt;/code&gt;. Маркет &lt;code&gt;#&lt;/code&gt; как и прежде находится
после очередного найденного простого числа. Справа от него находится маркер &lt;code&gt;_&lt;/code&gt;, отмечающий
очередной множитель, на который требуется умножить текущее простое число (N.B., если &lt;code&gt;_&lt;/code&gt; стоит
сразу после &lt;code&gt;#&lt;/code&gt;, то это означает, что множителем будет само простое число, т.е. это
соответствует вычислению &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-202.png&quot; style=&quot;{% style_stub fzcaaa 202 inline %}&quot; class=&quot;latex&quot;&gt;).&lt;/span&gt; Маркер движется вправо и устанавливается на следующее
невычеркнутое число.&lt;/p&gt;
&lt;p&gt;Для каждого положения маркеров &lt;code&gt;#&lt;/code&gt; и &lt;code&gt;_&lt;/code&gt;, префиксы, состоящие из символов, расположенных левее
каждого из этих маркеров, копируются на две следующие за решетом строки. Из префиксов удаляются
лишние символы (в т.ч. вышеупомянутые маркеры), а перед префиксами добавляются новые маркеры:
маркер &lt;code&gt;:&lt;/code&gt; перед первым префиксом и &lt;code&gt;,&lt;/code&gt; – перед вторым. Оба префикса, т.о., всего-лишь
обозначают подлежащие перемножению числа [в унарной системе счисления]. Их произведение следует
вычеркнуть из решета.&lt;/p&gt;
&lt;p&gt;Для этого перед решетом добавляется маркер &lt;code&gt;@&lt;/code&gt; (N.B., изначально &lt;em&gt;левее&lt;/em&gt; маркеров &lt;code&gt;#&lt;/code&gt; и &lt;code&gt;_&lt;/code&gt;, что
контрастирует с вышеописанным кодом для решета Эратосфена). Далее, в двух вложенных циклах
начинают смещаться вправо маркеры &lt;code&gt;:&lt;/code&gt; и &lt;code&gt;,&lt;/code&gt;. Причем маркер &lt;code&gt;,&lt;/code&gt; смещается на одну позицию когда
маркер &lt;code&gt;:&lt;/code&gt; доходит до конца его строки. После каждого смещения маркера &lt;code&gt;,&lt;/code&gt; маркер &lt;code&gt;:&lt;/code&gt;
реинициализируется и вновь оказывается перед своей строкой. При каждом перемещении маркера &lt;code&gt;:&lt;/code&gt;
на одну позицию, на одну позицию вправо смещается и маркер &lt;code&gt;@&lt;/code&gt;. Т.к. на пути маркера &lt;code&gt;@&lt;/code&gt; лежат
маркеры &lt;code&gt;#&lt;/code&gt; и &lt;code&gt;_&lt;/code&gt; (которых он гарантированно обгонит), то после окончания работы обоих циклов,
т.е. по достижению маркером &lt;code&gt;,&lt;/code&gt; конца своей строки, позиция &lt;code&gt;@&lt;/code&gt; корректируется, смещаясь вправо
на две позиции.&lt;/p&gt;
&lt;p&gt;В конечном счета, маркер &lt;code&gt;@&lt;/code&gt; оказывается сразу после составного числа, равного произведению двух
выделенных префиксов и подлежащего вычеркиванию. Однако, если в реализации решета Эратосфена, на
аналогичном этапе производилось, собственно, вычеркивание командой &lt;code&gt;s/1@/0@/&lt;/code&gt;, то сейчас
выбранный элемент решета лишь помечается к удалению, заменяясь не на &lt;code&gt;0&lt;/code&gt;, а на &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;После всего этого мы можем перейти к новой итерации по перемещению маркера &lt;code&gt;_&lt;/code&gt;, отмечающего
следующий множитель для текущего простого числа (маркер &lt;code&gt;_&lt;/code&gt; перепрыгивает к первому ненулевому
символу, лежащему правее него). Если же правее маркера &lt;code&gt;_&lt;/code&gt; не оказалось ни одного символа &lt;code&gt;1&lt;/code&gt;
или &lt;code&gt;x&lt;/code&gt; (т.е. невычеркнутого, хотя, возможно, и помеченного числа), то все помеченные к удалению
числа вычеркиваются окончательно командой &lt;code&gt;s/x/0/g&lt;/code&gt; и мы переходим к следующей итерации смещения
маркера &lt;code&gt;#&lt;/code&gt;. Если правее от маркера &lt;code&gt;#&lt;/code&gt; не оказывается простых чисел, т.е. если нет ячеек со
значением &lt;code&gt;1&lt;/code&gt;, то алгоритм просеивания завершает свою работу, передавая управление финальной
части скрипта, производящей печать результатов.&lt;/p&gt;
&lt;h1 id=&quot;section-7&quot;&gt;Вычисление некоторых теоретико-числовых функций просеиванием&lt;/h1&gt;
&lt;p&gt;(Этот раздел был добавлен в апреле 2021 г.)&lt;/p&gt;
&lt;p&gt;[Модифицированное] решето Эратосфена может применяться для вычисления некоторых функций,
хорошо известных в теории чисел. Примеры таких функций &lt;a class=&quot;citation&quot; href=&quot;#versatile-sieve&quot;&gt;[13]&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Простота числа; основное применение обычного решета Эратосфена.&lt;/li&gt;
&lt;li&gt;Радикал целого числа (функция &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-203.png&quot; style=&quot;{% style_stub gzcaaa 203 inline %}&quot; class=&quot;latex&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-204.png&quot; style=&quot;{% style_stub hzcaaa 204 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равен
произведению всех различных простых делителей числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-205.png&quot; style=&quot;{% style_stub izcaaa 205 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Функция Эйлера (&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-206.png&quot; style=&quot;{% style_stub jzcaaa 206 inline %}&quot; class=&quot;latex&quot;&gt;-функция);&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-207.png&quot; style=&quot;{% style_stub kzcaaa 207 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; равно количеству чисел, взаимно простых с
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-208.png&quot; style=&quot;{% style_stub lzcaaa 208 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Количество различных простых делителей (&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-209.png&quot; style=&quot;{% style_stub mzcaaa 209 inline %}&quot; class=&quot;latex&quot;&gt;-функция).&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Наименьший простой делитель.&lt;/li&gt;
&lt;li&gt;Факторизация (разложение на простые множители).&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;section-8&quot;&gt;Комплектация поставки&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;plain-sieve.sed&lt;/code&gt; – принимает длину решета и возвращает бинарную последовательность с
единицами только в позициях, соответствующих простым числам (самая первая, левая позиция
соответствует единице и поэтому всегда равна 0).&lt;/p&gt;
&lt;p&gt;Пример: &lt;code&gt;echo 10 | ./plain-sieve.sed&lt;/code&gt; вернёт &lt;code&gt;0110101000&lt;/code&gt; (единицы в позициях 2, 3, 5 и 7).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sieve.sed&lt;/code&gt; – основной скрипт (кратко описанный в разделе «Реализация»; см. выше),
принимающий длину решета и возвращающий (точнее говоря, печатающий) список (с разделением
переводом строки) простых чисел, не превышающих данной длины.&lt;/p&gt;
&lt;p&gt;Пример: &lt;code&gt;echo 10 | ./sieve.sed&lt;/code&gt; возвращает:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2
3
5
7
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;binary-sieve.sed&lt;/code&gt; – скрипт аналогичен предыдущему, но работает в двоичной системе счисления
(i.e. и длину решета принимает в виде бинарного числа и простые числа печатает тоже в
двоичной записи; это немного упрощает код чтения и печати чисел) .&lt;/p&gt;
&lt;p&gt;Пример:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo 1010 | ./binary-sieve.sed

10
11
101
111
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Действительно, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-210.png&quot; style=&quot;{% style_stub nzcaaa 210 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-211.png&quot; style=&quot;{% style_stub ozcaaa 211 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-212.png&quot; style=&quot;{% style_stub pzcaaa 212 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-213.png&quot; style=&quot;{% style_stub qzcaaa 213 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-214.png&quot; style=&quot;{% style_stub rzcaaa 214 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;anagram.sed&lt;/code&gt; и &lt;code&gt;collatz.sed&lt;/code&gt; были описаны в предыдущем разделе этого сообщения. Скрипт
&lt;code&gt;anagram.sed&lt;/code&gt; сейчас поддерживает только латинские символы, а &lt;code&gt;collatz.sed&lt;/code&gt; печатает только
«ключевые» точки траектории &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-215.png&quot; style=&quot;{% style_stub szcaaa 215 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; т.е. строит последовательность итерируя отображение
&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-216.png&quot; style=&quot;{% style_stub tzcaaa 216 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; где &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-217.png&quot; style=&quot;{% style_stub uzcaaa 217 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; есть [максимальная] степень множителя 2 в факторизации
числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-218.png&quot; style=&quot;{% style_stub vzcaaa 218 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; E.g. для начального числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-219.png&quot; style=&quot;{% style_stub wzcaaa 219 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; будет построена последовательность &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-220.png&quot; style=&quot;{% style_stub xzcaaa 220 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; i.e. 10 будет поделено на 2, затем этот результат без печати на экране будет
утроен и инкрементирован, что даст 16 (&lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-221.png&quot; style=&quot;{% style_stub yzcaaa 221 inline %}&quot; class=&quot;latex&quot;&gt;),&lt;/span&gt; а это последнее число будет напечатано и
сразу же [целочисленно] разделено на максимально возможную здесь степень двойки, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-222.png&quot; style=&quot;{% style_stub zzcaaa 222 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; что
даст последнюю точку траектории, 1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;anagrams.txt&lt;/code&gt; – примеры анаграмм для тестирования &lt;code&gt;anagram.sed&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;factor.sed&lt;/code&gt; – производит разложение данного числа на простые множители (работа скрипта уже
была описана в резделе «Реализация»).&lt;/p&gt;
&lt;p&gt;Пример:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo 18 | ./factor.sed

2
3
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как и ожидалось, &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-223.png&quot; style=&quot;{% style_stub aadaaa 223 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;factor-hack-unary.sed&lt;/code&gt; – простой скрипт, вместо решета использующий «обратные ссылки» в
регулярном выражении (следуя &lt;a class=&quot;citation&quot; href=&quot;#factor-hack&quot;&gt;[14,15,16]&lt;/a&gt;) для
факторизации числа, представленного в унарной системе счисления.&lt;/p&gt;
&lt;p&gt;Примечание: здесь используются расширенные «регулярные» выражения, поддерживающие ссылки
вида &lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;, etc., и не являющиеся именно регулярными в привычном смысле – такие
выражения с обратными ссылками не удастся скомпилировать в конечный автомат.&lt;/p&gt;
&lt;p&gt;Скрипт на самом деле имеет дело со списком чисел (разделенных переводом строки), подлежащих
разложению. Но разложению подвергается только одно из них, помеченное специальным маркером.&lt;/p&gt;
&lt;p&gt;Для числа &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-224.png&quot; style=&quot;{% style_stub badaaa 224 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; используется регулярное выражение, аналогичное выражению &lt;code&gt;/^(11+)(\1+)$/&lt;/code&gt;. Как видно, оно выделяет некую группу из не менее чем двух
единиц при помощи подвыражения &lt;code&gt;(11+)&lt;/code&gt;, т.е. выделяет один множитель &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-225.png&quot; style=&quot;{% style_stub cadaaa 225 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (возможно составной),
и с помощью подвыражения &lt;code&gt;(\1+)&lt;/code&gt; проверяет, можно ли представить оставшуюся часть числа
конкатенацией некоторого ненулевого количества копий этой группы (без остатка).&lt;/p&gt;
&lt;p&gt;Если это не удалось сделать, то &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-226.png&quot; style=&quot;{% style_stub dadaaa 226 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; либо равно единице, либо является простым. В противном
случае скрипт производит деление числа на найденный множитель: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-227.png&quot; style=&quot;{% style_stub eadaaa 227 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt; Для этого, в цикле,
найденная ранее группа единиц, находящаяся в самом начале числа, заменяется на подходящий
маркер (в данном случае используется символ &lt;code&gt;_&lt;/code&gt;). Т.о., по завершению цикла, количество
символов подчеркивания равно &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-228.png&quot; style=&quot;{% style_stub fadaaa 228 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и заменой &lt;code&gt;s/_/1/g&lt;/code&gt; можно получить этот второй, возможно тоже
составной множитель. Множитель &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-229.png&quot; style=&quot;{% style_stub gadaaa 229 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; добавляется в список чисел.&lt;/p&gt;
&lt;p&gt;Теперь скрипт рекурсивно обрабатывает найденный множитель &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-230.png&quot; style=&quot;{% style_stub hadaaa 230 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; (пометив его специальным
маркером и начав факторизацию заново) по уже описанной схеме и продолжает процесс, перемащая
маркер к следующему числу в списке при каждой «неудачной» факторизации (т.е. когда
помеченный множитель оказывается простым или равным единице), пока всё исходное число не
окажется разложенным на простые множители.&lt;/p&gt;
&lt;p&gt;В других диалектах регулярных выражений могут поддерживаться те или иные средства управления
жадностью – так в источнике &lt;a class=&quot;citation&quot; href=&quot;#nongreedy-factor&quot;&gt;[16]&lt;/a&gt; вместо &lt;code&gt;11+&lt;/code&gt; применено подвыражение
&lt;code&gt;11+?&lt;/code&gt;, которое как раз и указывает механизму сопоставления с образцом действовать нежадно,
минимизируя длину найденной подстроки; но в sed таких средств, кажется, нет, а в данном
конкретном случае, за счёт рекурсивной обработки всё вновь получаемых множителей,
неопределенной жадности вполне достаточно.&lt;/p&gt;
&lt;p&gt;Интересно, что если для сопоставления с образцом &lt;code&gt;11+&lt;/code&gt; используется гарантированно жадная
стратегия, то, коль скоро это соответствует максимизации &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-231.png&quot; style=&quot;{% style_stub iadaaa 231 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; в разложении &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-232.png&quot; style=&quot;{% style_stub jadaaa 232 inline %}&quot; class=&quot;latex&quot;&gt;,&lt;/span&gt; это
минимизирует &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-233.png&quot; style=&quot;{% style_stub kadaaa 233 inline %}&quot; class=&quot;latex&quot;&gt;&lt;/span&gt; и обеспечивает т.о. его простоту. Данное наблюдение могло бы позволить слегка
сократить и ускорить скрипт, но я не воспользовался такой возможностью (потому что всё и так
работает, да ещё и не зависит от стратегии поиска, выбранной конкретной реализацией регулярных
выражений).&lt;/p&gt;
&lt;p&gt;Пример работы скрипта:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo 111111111111111111 | ./factor-hack-unary.sed

111
111
11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Так и должно быть: &lt;span class=&quot;nolinebreak&quot;&gt;&lt;img src=&quot;/eq/7-234.png&quot; style=&quot;{% style_stub ladaaa 234 inline %}&quot; class=&quot;latex&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;euler-sieve.sed&lt;/code&gt; – попытка реализации решета Эйлера. Детальное описание приведено в
предыдущем разделе. С точки зрения запуска и использования, скрипт должен работать в точности
как и &lt;code&gt;sieve.sed&lt;/code&gt; (см. выше).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;section-9&quot;&gt;Ссылки&lt;/h1&gt;
&lt;ul class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;wiki-sieve&quot;&gt;1. &lt;/span&gt; &lt;a href=&quot;http://ru.wikipedia.org/wiki/решето_Эратосфена&quot;&gt;http://ru.wikipedia.org/wiki/решето_Эратосфена&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;sieve-in-sed&quot;&gt;2. &lt;/span&gt; &lt;a href=&quot;https://github.com/Circiter/sieve-in-sed&quot;&gt;https://github.com/Circiter/sieve-in-sed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;anagrams-alg&quot;&gt;3. &lt;/span&gt; &lt;a href=&quot;http://skerritt.blog/an-algorithm-for-finding-anagrams&quot;&gt;http://skerritt.blog/an-algorithm-for-finding-anagrams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;anagrams-math&quot;&gt;4. &lt;/span&gt; &lt;a href=&quot;http://quanterocapital.com/anagrams-mathematically-speaking&quot;&gt;http://quanterocapital.com/anagrams-mathematically-speaking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-fta&quot;&gt;5. &lt;/span&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/fundamental_theorem_of_arithmetic&quot;&gt;http://en.wikipedia.org/wiki/fundamental_theorem_of_arithmetic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;gist-mult&quot;&gt;6. &lt;/span&gt; &lt;a href=&quot;https://gist.github.com/Circiter/042264eb9e9ee360d0eafa10eedf3f21&quot;&gt;https://gist.github.com/Circiter/042264eb9e9ee360d0eafa10eedf3f21&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-collatz&quot;&gt;7. &lt;/span&gt; &lt;a href=&quot;http://ru.wikipedia.org/wiki/гипотеза_Коллатца&quot;&gt;http://ru.wikipedia.org/wiki/гипотеза_Коллатца&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;lagarias2010&quot;&gt;8. Lagarias J. The Ultimate Challenge: the 3x+1 problem. 2010&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;wiki-wheel&quot;&gt;9. &lt;/span&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/wheel_factorization&quot;&gt;http://en.wikipedia.org/wiki/wheel_factorization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;euler1737&quot;&gt;10. Euler L. Variae observationes circa series infinitas. 1737&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;sorenson1990&quot;&gt;11. Sorenson J. An Introduction to Prime Number Sieves. 1990&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;gries-misra&quot;&gt;12. Gries D. и др. A Linear Sieve Algorithm for Finding Prime Numbers&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;versatile-sieve&quot;&gt;13. &lt;/span&gt; &lt;a href=&quot;http://www.nayuki.io/page/the-versatile-sieve-of-eratosthenes&quot;&gt;http://www.nayuki.io/page/the-versatile-sieve-of-eratosthenes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;factor-hack&quot;&gt;14. &lt;/span&gt; &lt;a href=&quot;http://news.ycombinator.com/item?id=9039537&quot;&gt;http://news.ycombinator.com/item?id=9039537&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;another-factor-hack&quot;&gt;15. &lt;/span&gt; &lt;a href=&quot;http://montreal.pm.org/tech/neil_kandalgaonkar.shtml&quot;&gt;http://montreal.pm.org/tech/neil_kandalgaonkar.shtml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;nongreedy-factor&quot;&gt;16. &lt;/span&gt; &lt;a href=&quot;http://www.mit.edu:8008/bloom-picayune.mit.edu/perl/10138&quot;&gt;http://www.mit.edu:8008/bloom-picayune.mit.edu/perl/10138&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</content>
 </entry>
 

</feed>
